/*
A exact p-adic field is represented by either a prime number (for prime fields) or a polynomial (for extensions). At all times it has a precision (a positive integer) which can only increase and a FldPad which is an approximation to the field to this precision. When an approximation to a field element is made, it is always made in the current approximation field (which may be made more precise first, if necessary). If the approximation field is made more precise, then approximated field elements are out of date, but can easily be case into the current field at any time.

A field element is represented by a (precision,approximation) pair, with the precision identifying the precision of the approximation field, and an element of that approximation field. The precision can be compared against the precision of the approximation field at any time, and when there is a discrepancy, the approximation can be cast into the current approximation field. An element also carries with it an update procedure, which takes an absolute precision and updates the (precision,approximation) pair to an approximation with at least that absolute precision.
*/

// TODO: change the Magma sublime package to put scopes around definitions of functions, intrinsics, types and verbose flags, including prototypes (e.g. "function foo(x, y)", "intrinsic Foo(a :: RngIntElt)", "declare type FldPadExact", "declare verbose ExactpAdics") and make sublime include these in the symbol definitions list (magma-symbols.tmPreferences: http://docs.sublimetext.info/en/latest/reference/symbols.html)

// TODO: the word "FUDGE" appears here and there in the code, it signals that we are working around precision errors in FldPadElt computations (which seem to occur when casting between the top and bottom field of a totally ramified extension); when these are resolved, remove them. NOTE: Previously, "CAST" and "ELTSEQ" were redefinitions of "!" and "Eltseq" to work around these problems, but I couldn't find a single neat workaround; the current approach is to work around it in each place where it is a problem by taking the inputs to higher precision (the "FUDGE") and then lowering the precision of the output.

// TODO: implement more Tmp stuff

// TODO: rootsOfValuation, which returns the roots of a given valuation (without Newton polygon factoring)
// TODO: modify Roots(f) to use rootsOfValuation, Newton polygons, etc.

// TODO: use Tmp stuff to do all coercion?

// TODO: magma has IsIdentical; with this, remove all the id stuff which has two purposes: (a) equality checking and (b) dependency ordering. We can do (a) using IsIdentical. We can do (b) without a global counter: when satisfying dependencies, record against each object the objects depending on it. Hmmm except we need a unique id to keep track of when the same object comes up multiple times during dependency checking... can we get at the pointer value?

// TODO: '*', LeftDivide, IsLeftDivisible, RightDivide='/', IsRightDivisible, LeftDerivative and RightDerivative for transition functions

// TODO: a more general piecewise linear map type, represented as a function taking an x coordinate and returning [L, R] where L describes what's to the left (either the next vertex or a gradient which continues for infinity) and R similarly describes what's to the right, at least one of L or R must be a vertex. Given <left gradient, vertices, right gradient> we can deduce such a function, perhaps using binary search to find vertices. Have LeftDerivative, RightDerivative, Inverse, and composition all defined. Implement transition functions on top of these?

// TODO: it's convenient to the user to have default strategies like Strategy:="default" everywhere, but it's a little dangerous to the programmer who forgets to pass strategies from caller to callee, which instead uses the default strategy. Think about this. Time to think about strategy stacks?

// TODO: give each element a "baseline" valuation, which is a lower bound on its valuation and is never changed; by default, use the weak valuation of the initial value; then have BaselinePrecision, IncreaseBaselinePrecision, etc which work relative to this baseline; this is a way of removing valuation=0 as a special value

// TODO: represent an absolute precision of a FldPadExactElt as a new object consisting of the element and the precision; have creation functions for these; pass them around instead of just passing around integers; e.g. intrinsic AbsolutePrecisionInfo(x : Pr:=10, Absolute, Baseline, NewtonPolygon, Weak, ...); Value(a :: APr_FldPadExactElt); do the same for polynomials; ShiftValuation(a :: APr_FldPadExactElt, n :: RngIntElt); ShiftSlope(a :: APr_RngIntElt_FldPadExact, n :: RngIntElt); Exponents(a :: APr_FldPadExact); Max(a :: APr_FldPadExact); Image(a :: APr_FldPadExactElt);

// TODO: implement "Promote(x,y)" which tries to return x and y with the same parent (and IsPromotable(x,y)); the default behaviour should be to 

// freeze;


import "Getter.mag": satisfy_deps_list, satisfy_dep;
import "Promotion.mag": do_binop;

Z := IntegerRing();
Q := RationalField();
OO := Infinity();

// when true, Update() checks for consistency (STRONGLY RECOMMENDED)
UPDATE_CONSISTENCY_CHECK := true;
// this is used in two places to try to work around precision issues in totally ramified extensions:
// 1. each x`update function is modified so that it adds GLOBAL_FUDGE onto its input
// 2. the Update intrinsic is modified so that is takes precision GLOBAL_FUDGE off its input
GLOBAL_FUDGE := func<K | 0>;

PRIME := 1; // prime p-adic fields Q_p
INERT := 2; // unramified extensions defined by inertial polynomials
EISEN := 3; // totally ramified extensions defined by Eisenstein polynomials
EMBED := 4; // subfields defined by embedding maps
COMPOUND := 5;

CAST := '!';
CAP_PR := _ExactpAdics_CapPrecision;
CAP_APR := _ExactpAdics_CapAbsolutePrecision;
CHANGE_APR := _ExactpAdics_ChangeAbsolutePrecision;
CHANGE_PR := _ExactpAdics_ChangePrecision;
ELTSEQ := Eltseq;
PR := Precision;
APR := AbsolutePrecision;
WVAL := WeakValuation;
VAL := Valuation;
DEG := Degree;
WDEG := WeakDegree;
INC_APR := IncreaseAbsolutePrecision;
INC_APR_Z := IncreaseAbsolutePrecision_Lazy;
APPROX := Approximation;
APPROX_Z := Approximation_Lazy;
WEQ := _ExactpAdics_IsWeaklyEqual;
WZERO := _ExactpAdics_IsWeaklyZero;
IS_VALID_APPROX := _ExactpAdics_IsValidApproximation;
SHIFT_VAL := ShiftValuation;
SHIFT_SLOPE := ShiftSlope;
RES := Resultant;
WRES := WeakResultant;
CHANGE_DPR := _ExactpAdics_ChangeDefaultPrecision;
TRIM_APR := func<x, n | CHANGE_APR(x, APR(x)-n)>;
NEXTID := ExactpAdics_NextId;
IS_PREC_ERR := _ExactpAdics_IsPrecisionError;
PREC_ERR := func<msg | Error("Insufficient precision: " cat msg)>;
IS_INSTANCE := func<x, C | ISA(ExtendedType(x), C)>;
TOWER := _ExactpAdics_Tower;
LAST := func<x | x[#x]>;
function THE(x)
  assert #x eq 1;
  return Rep(x);
end function;
LIST := _ExactpAdics_List;
ZERO := _ExactpAdics_Zero;
SORT := _ExactpAdics_Sort;
function CAPR(x : PrCap:=1)
  return AbsolutePrecision(x) meet (WeakValuation(x) + PrCap);
end function;
BVAL := BaselineValuation;
BPR := BaselinePrecision;
MONOMIAL := _ExactpAdics_Monomial;

// the level of recursion to check in _ExactpAdics_Cast and _ExactpAdics_Eltseq when working in totally ramified extensions; 0 means no checking; recommend 1 or 2 in development
// TOT_RAM_CAST_CHECK := 0;

procedure record_time(~times, ~last_time, label)
  t := Cputime();
  if not assigned times then
    times := AssociativeArray();
  else
    ok, T := IsDefined(times, label);
    dt := t - last_time;
    if ok then
      times[label] := T + dt;
    else
      times[label] := dt;
    end if;
  end if;
  last_time := t;
end procedure;

// UTILITY FUNCTIONS
///hide-all

intrinsic _ExactpAdics_Monomial(R :: RngMPol, e :: [RngIntElt]) -> RngMPolElt
  {The monomial x^e in R.}
  // MAGMA BUG: R.i is cached, so its coefficient may be to a lower precision than the precision of the base ring!
  // this forces the coefficient to be to the full current precision of the base ring
  return Polynomial([BaseRing(R) ! 1], [Monomial(R, e)]);
end intrinsic;

intrinsic _ExactpAdics_Sort(xs) -> .
  {Sort.}
  return Sort(xs);
end intrinsic;

intrinsic _ExactpAdics_Sort(xs :: {}) -> .
  {"}
  return Sort(SetToSequence(xs));
end intrinsic;

intrinsic _ExactpAdics_List(xs) -> List
  {Converts xs to a list.}
  return [*x : x in xs*];
end intrinsic;

intrinsic _ExactpAdics_List(xs :: List) -> List
  {"}
  return xs;
end intrinsic;

intrinsic _ExactpAdics_List(xs :: []) -> List
  {"}
  return SequenceToList(xs);
end intrinsic;

intrinsic _ExactpAdics_List(xs :: Tup) -> List
  {"}
  return TupleToList(xs);
end intrinsic;

intrinsic _ExactpAdics_ChangeDefaultPrecision(F :: FldPad, n :: RngIntElt)
  {Changes the default precision of F to n, and changes the default precisions of its subfields too.}
  while true do
    F`DefaultPrecision := n;
    if IsPrimeField(F) then
      return;
    else
      n := Ceiling(n / RamificationDegree(F));
      F := BaseField(F);
    end if;
  end while;
end intrinsic;

intrinsic _ExactpAdics_ChangeDefaultPrecision(F :: FldPad, n :: Val_FldPadElt)
  {"}
  CHANGE_DPR(F, IntegerValue(n));
end intrinsic;

intrinsic _ExactpAdics_IsValidApproximation(F :: FldPadExact, app :: FldPadElt) -> BoolElt, FldPadElt
  {True if app is a valid approximation to an element of F, and the coerced version.}
  xF := F`approximation_field;
  xF2 := Parent(app);
  pr := Precision(xF2);
  if pr eq OO and xF2 eq xF then
    return true, app;
  elif ChangePrecision(xF, pr) eq xF2 then
    return true, CAST(xF, app);
  end if;
  return false, _;
end intrinsic;

intrinsic _ExactpAdics_IsValidApproximation(R :: RngUPol_FldPadExact, app :: RngUPolElt[FldPad]) -> BoolElt, RngUPolElt
  {True if app is a valid approximation to an element of R, and the coerced version.}
  xR := R`approximation_ring;
  xR2 := Parent(app);
  xF := BaseRing(xR);
  xF2 := BaseRing(xR2);
  pr := Precision(xF2);
  if pr eq OO and xF2 eq xF then
    return true, CAST(xR, app);
  elif ChangePrecision(xF, pr) eq xF2 then
    return true, CAST(xR, app);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyZero(x) -> BoolElt
  {IsWeaklyZero(x).}
  return IsWeaklyZero(x);
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyZero(f :: RngUPolElt[FldPad]) -> BoolElt
  {"}
  return forall{c : c in Coefficients(f) | WZERO(c)};
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyEqual(x, y) -> BoolElt
  {IsWeaklyEqual(x, y).}
  return IsWeaklyEqual(x, y);
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyEqual(x :: FldPadElt, y :: FldPadElt) -> BoolElt
  {"}
  // when the absolute precisions are way different, it can cause an infinite-precision FldPad
  assert Parent(x) eq Parent(y);
  apr := Min(APR(x), APR(y));
  return IsWeaklyEqual(CHANGE_APR(x, apr), CHANGE_APR(y, apr));
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyEqual(x :: RngUPolElt[FldPad], y :: RngUPolElt[FldPad]) -> BoolElt
  {"}
  assert Parent(x) eq Parent(y);
  dx := Degree(x);
  dy := Degree(y);
  d := Min(dx, dy);
  C := Coefficient;
  return forall{i : i in [0..d] | WEQ(C(x,i), C(y,i))} and forall{i : i in [d+1..dx] | WZERO(C(x,i))} and forall{i : i in [d+1..dy] | WZERO(C(y,i))};
end intrinsic;

intrinsic _ExactpAdics_ChangePrecision(x :: FldPadElt, n :: RngIntElt) -> FldPadElt
  {Change the precision of x.}
  require n ge 0: "Argument 2 must be at least 0";
  require not WZERO(x): "Argument 1 must be nonzero";
  if n eq 0 then
    return ZERO(Parent(x), VAL(x));
  else
    return ChangePrecision(x, n);
  end if;
end intrinsic;

intrinsic _ExactpAdics_ChangePrecision(x :: FldPadElt, n :: Infty) -> FldPadElt
  {"}
  assert PR(x) eq n;
  return x;
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(x :: FldPadElt, n :: RngIntElt) -> FldPadElt
  {Change the absolute precision of x.}
  if WZERO(x) then
    return ZERO(Parent(x), n);
  else
    v := VAL(x);
    if n le v then
      return ZERO(Parent(x), n);
    else
      return CHANGE_PR(x, n-v);
    end if;
  end if;
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(x :: FldPadElt, n :: Infty) -> FldPadElt
  {"}
  assert APR(x) eq n;
  return x;
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(x :: FldPadElt, n :: Val_FldPadElt) -> FldPadElt
  {"}
  return CHANGE_APR(x, n`value);
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(f :: RngUPolElt[FldPad], n :: RngIntElt) -> RngUPolElt
  {"}
  return Parent(f) ! [CHANGE_APR(c, n) : c in Coefficients(f)];
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(f :: RngUPolElt[FldPad], n :: Infty) -> RngUPolElt
  {"}
  return Parent(f) ! [CHANGE_APR(c, n) : c in Coefficients(f)];
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(f :: RngUPolElt[FldPad], n :: []) -> RngUPolElt
  {"}
  assert #n ge Degree(f)+1;
  return Parent(f) ! [CHANGE_APR(Coefficient(f,i), n[i+1]) : i in [0..Degree(f)]];
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(f :: RngUPolElt[FldPad], n :: Val_RngUPolElt_FldPad) -> RngUPolElt
  {"}
  return Parent(f) ! [CHANGE_APR(Coefficient(f,i), n(i)) : i in [0..Degree(f)]];
end intrinsic;

intrinsic _ExactpAdics_Zero(K :: FldPad, n :: RngIntElt) -> FldPadElt
  {Zero to absolute precision n.}
  x := CHANGE_PR(SHIFT_VAL(K!1, n-1), 1);
  z := x - x;
  assert APR(z) eq n;
  assert WZERO(z);
  return z;
end intrinsic;

intrinsic _ExactpAdics_Zero(K :: FldPad, n :: Infty) -> FldPadElt
  {"}
  assert n eq OO;
  return K ! 0;
end intrinsic;

intrinsic _ExactpAdics_CapPrecision(x :: FldPadElt, pr) -> FldPadElt
  {Caps the precision of x.}
  y := (PR(x) le pr) select x else CHANGE_PR(x, pr);
  assert PR(y) le pr;
  return y;
end intrinsic;

intrinsic _ExactpAdics_CapPrecision(f :: RngUPolElt[FldPad], pr) -> RngUPolElt
  {"}
  return Parent(f) ! [CAP_PR(c,pr) : c in Coefficients(f)];
end intrinsic;

VAL_FLDPADELT_MIN := Val_FldPadElt_Make(-99999);

intrinsic _ExactpAdics_CapAbsolutePrecision(x :: FldPadElt, apr) -> FldPadElt
  {Caps the absolute precision of x.}
  // <HACK>
  // you can't make a FldPadElt with valuation -OO
  apr join:= VAL_FLDPADELT_MIN;
  // </HACK>
  y := (APR(x) le apr) select x else CHANGE_APR(x, apr);
  assert APR(y) le apr;
  return y;
end intrinsic;

intrinsic _ExactpAdics_IsPrecisionError(e :: Err) -> BoolElt
  {True if e looks like a precision error.}
  x := e`Object;
  if (Type(x) eq MonStgElt) and (("Insufficient precision" in x) or ("Insufficient prec in" in x) or ("Field 'res_fact' is not assigned" in x) or ("valuation overflow in mult" in x) or ("List of factors must have length >= 2" in x) or ("Could not find the correct factor" in x) or ("Field 'f' is not assigned" in x)) then
    return true;
  end if;
  if (assigned e`Position) and (("assert &and[Degree(fact[j][1]) eq Degree(Phi) div cert[i]" in e`Position) or ("assert 2*Valuation(Discriminant(Pi_new`chi)) lt Precision" in e`Position)) then
    return true;
  end if;
  return false;
end intrinsic;

intrinsic _ExactpAdics_Tower(L :: FldPad, K :: FldPad) -> SeqEnum
  {The tower of extensions from K up to L.}
  tower := [L];
  while tower[1] ne K do
    Insert(~tower, 1, BaseField(tower[1]));
  end while;
  return tower;
end intrinsic;

///hide-none

// TYPE DECLARATIONS

declare type FldPadExact[FldPadExactElt];
declare attributes FldPadExact
  : type                               // PRIME, INERT, EISEN or EMBED
  , id                                 // NEXTID()
  , defining_polynomial                // DefiningPolynomial(*)
  , defining_embedding                 // 
  , approximation_field                // FldPad approximating this
  // CACHE
  , embeddings                         // automatic embeddings of other rings/fields
  , subfield_data                      // [id] -> data about subfield with id
  , varname                            // generator name
  , prime                              // Prime(*)
  , base_field                         // BaseField(*)
  , prime_field                        // PrimeField(*)
  , zero                               // Zero(*)
  , one                                // One(*)
  , uniformizing_element               // UniformizingElement(*)
  , generator                          // Generator(*)
  , polynomial_ring                    // PolynomialRing(*)
  , polynomial_ring_m                  // [n] -> PolynomialRing(*,n)
  , degree                             // Degree(*)
  , ramification_degree                // RamificationDegree(*)
  , inertia_degree                     // InertiaDegree(*)
  , absolute_degree                    // AbsoluteDegree(*)
  , absolute_ramification_degree       // AbsoluteRamificationDegree(*)
  , absolute_inertia_degree            // AbsoluteInertiaDegree(*)
  , residue_class_field                // ResidueClassField(*)
  , integers                           // Integers(*)
  , transition_function                // TransitionFunction(*)
  , inertia_generator                  // InertiaGenerator(*)
  , primitive_element                  // PrimitiveElement(*)
  , temporary                          // Temporary(*)
  ;

declare type FldPadExactElt;
declare attributes FldPadExactElt
  : parent                          // parent field
  , id                              // NEXTID()
  , data                            // element-specific data, used/modified by update
  , approximation                   // the approximation
  , update                          // the update function
  , update_expecting_apr            // when assigned, Update(*, app) will check that the update is to at least this precision
  , baseline_valuation              // wrt which baseline precision is computed
  // CACHE
  , residue_class                   // ResidueClass(*)
  , valuation                       // Valuation(*)
  , negation                        // '-'(*)
  , coefficient                     // [i] -> Coefficient(*,i)
  , coefficients                    // Eltseq(*), Coefficients(*)
  , temporary                       // Temporary(*)
  , power                           // [n] -> '^'(*,n)
  ;

declare type RngUPol_FldPadExact[RngUPolElt_FldPadExact];
declare attributes RngUPol_FldPadExact
  : base_ring                       // BaseRing(*)
  , id                              // NEXTID()
  , approximation_ring              // RngUPol[FldPad] approximating this
  , varname                         // printing name of the variable
  // CACHE
  , generator                       // Generator(*)
  ;

declare type RngUPolElt_FldPadExact;
declare attributes RngUPolElt_FldPadExact
  : parent               // Parent(*)
  , id                   // NEXTID()
  , approximation        // approximation polynomial
  , update               // update function
  , update_expecting_apr // when assigned, Update(*, app) will check that the update is to at least this precision
  , data                 // element-specific data, used/modified by update function
  , baseline_valuation   // wrt which baseline precision is computed
  // CACHE
  , weak_coefficients    // WeakCoefficients(*)
  , coefficient          // [i] -> Coefficient(*,i)
  , degree               // Degree(*)
  , is_eisenstein        // IsEisenstein(*)
  , is_inertial          // IsInertial(*)
  , coefficients         // Coefficients(*)
  , base_ring            // BaseRing(*)
  , discriminant         // Discriminant(*)
  , valuation            // Valuation(*)
  , leading_coefficient  // LeadingCoefficient(*)
  , is_integral          // IsIntegral(*)
  , derivative           // [i] -> Derivative(*,i)
  , roots                // Roots(*)
  , npfactorization      // [r] -> NewtonPolygonFactorization(* : Residual:=r)
  , factorization        // data for Factorization(* : ...)
  , newton_polygon       // NewtonPolygon(*)
  , ramification_polygon // RamificationPolygon(*)
  , is_irreducible       // IsIrreducible(*)
  , residual_polynomial  // [face] -> ResidualPolynomial(*, face)
  , residual_polynomials // ResidualPolynomials(*)
  , splitting_field      // SplittingField(*)
  , galois_group         // GaloisGroup(*)
  , ramification_residual_polynomial // [face] -> RamificationResidualPolynomial(*, face)
  , greve_field          // GreveField(*)
  , factorization_doris  // data for Factorization_Doris(* : ...)
  , is_irreducible_doris // IsIrreducible_Doris(*)
  , negation             // '-'(*)
  , min_valuation        // MinValuation(*)
  , powers               // [n] -> '^'(*,n)
  ;

declare type RngPadExact[RngPadExactElt];
declare attributes RngPadExact
  : id
  , data
  , field_of_fractions
  , radius
  ;

declare type RngPadExactElt;
declare attributes RngPadExactElt
  : id
  , parent
  , field_element
  ;

declare type HassHerbTransFunc;
declare attributes HassHerbTransFunc
  : degree                 // REQ: the degree of the extension
  , vertices               // REQ: the coordinates of the breaks
  , ramification_polygon   // RamificationPolygon(*)
  ;

declare type ExtDataFldPadExact;
declare attributes ExtDataFldPadExact
  : top_field             // REQ: the top field
  , base_field            // REQ: the base field
  , type                  // REQ: INERT, EISEN, EMBED or COMPOUND
  , list                  // REQ (COMPOUND)
  , degree                // Degree(*)
  , inertia_degree        // InertiaDegree(*)
  , ramification_degree   // RamificationDegree(*)
  , transition_function   // TransitionFunction(*)
  , ramification_polygon  // RamificationPolygon(*)
  , primitive_element     // PrimitiveElement(*)
  , flatten               // Flatten(*)
  , is_in_standard_form   // IsInStandardForm(*)
  , standard_form         // StandardForm(*)
  , discriminant_valuation // DiscriminantValuation(*)
  , describe_extension    // DescribeExtension(*)
  ;

declare type TmpFldPadExact[TmpFldPadExactElt];
declare attributes TmpFldPadExact
  : field                   // the field being approximated
  ;

declare type TmpFldPadExactElt;
declare attributes TmpFldPadExactElt
  : parent
  , get_approximation
  ;

declare type HomFldPadExact;
declare attributes HomFldPadExact
  : xdomain                // REQ: the domain E1/F as an extension of the base field F
  , xcodomain              // REQ: the codomain E2/F as an extension of the base field F
  , generator_images       // REQ: list of images (in E2) of generators of each subfield in E1/F
  , basis_images           // images of the standard basis of E1/F (derived from generator_images)
  , inverse                // Inverse(*) (if invertible)
  ;

procedure add_embedding(F, emb)
  if not assigned F`embeddings then
    F`embeddings := [* emb *];
  else
    Append(~F`embeddings, emb);
  end if;
end procedure;

///# Exact p-adic fields
///toc
///## Creation of p-adic fields
///### Prime fields

intrinsic ExactpAdicField(p :: RngIntElt) -> FldPadExact
  {The exact p-adic field.}
  require (p gt 0) and IsPrime(p): "p must be prime";
  F := New(FldPadExact);
  F`id := NEXTID();
  F`type := PRIME;
  F`prime := p;
  F`approximation_field := pAdicField(p);
  return F;
end intrinsic;

///### Extensions

function get_approximation(f, apr)
  if apr le AbsolutePrecision(f) then
    return f`approximation;
  else
    ExactpAdics_Warn("get_approx", Sprintf("Field not known to required precision. Can apply workaround: %o, %o", apr, APR(f)));
    IncreaseAbsolutePrecision(f, apr);
    return f`approximation;
  end if;
end function;

/// An extension of `E`, where the right hand side is either:
/// - an integer, giving the unramified extension of this degree
/// - coercible to a defining polynomial (Eisenstein or inertial)
intrinsic ExtConstructor(E :: FldPadExact, t :: Tup) -> FldPadExact
  {The extension of E defined by t.}
  case #t:
  when 1:
    if Type(t[1]) eq RngIntElt then
      return UnramifiedExtension(E, t[1]);
    end if;
    ok, f := IsCoercible(PolynomialRing(E), t[1]);
    if IsInertial(f) then
      return UnramifiedExtension(f);
    elif IsEisenstein(f) then
      return TotallyRamifiedExtension(f);
    end if;
  end case;
  error "RHS must be an integer or coercible to an inertial or Eisenstein polynomial";
end intrinsic;


/// The extension defined by `f` over its base field or `F`.
intrinsic Extension(f :: RngUPolElt_FldPadExact) -> FldPadExact
  {The extension defined by the inertial or Eisenstein polynomial f.}
  IncreaseAbsolutePrecision(f, 2);
  if IsInertial(f) then
    return UnramifiedExtension(f);
  elif IsEisenstein(f) then
    return TotallyRamifiedExtension(f);
  else
    error "f must currently be inertial or Eisenstein";
  end if;
end intrinsic;

///ditto
intrinsic Extension(F :: FldPadExact, f) -> FldPadExact
  {The extension of F defined by the inertial or Eisenstein polynomial f.}
  ok, f := IsCoercible(PolynomialRing(F), f);
  require ok: "f must be coercible to a polynomial over F";
  return Extension(f);
end intrinsic;

/// The unramified extension defined by `f` over its base field or `F`.
intrinsic UnramifiedExtension(f :: RngUPolElt_FldPadExact) -> FldPadExact
  {The unramified extension defined by the inertial polynomial f.}
  IncreaseAbsolutePrecision(f, 1);
  require IsInertial(f) and Degree(f) gt 0: "f must be inertial";
  F0 := BaseRing(f);
  xF0 := F0`approximation_field;
  xF0`DefaultPrecision := 1;
  F := New(FldPadExact);
  F`id := NEXTID();
  F`type := INERT;
  F`defining_polynomial := f;
  F`approximation_field := ext<xF0 | map<Z -> PolynomialRing(xF0) | k :-> get_approximation(f, k)>>;
  return F;
end intrinsic;

///ditto
intrinsic UnramifiedExtension(F :: FldPadExact, f) -> FldPadExact
  {The unramified extension of F defined by the inertial polynomial f.}
  ok, f := IsCoercible(PolynomialRing(F), f);
  require ok: "f must be coercible to a polynomial over F";
  return UnramifiedExtension(f);
end intrinsic;

/// The unramified extension of `F` of degree `n`.
intrinsic UnramifiedExtension(F :: FldPadExact, n :: RngIntElt) -> FldPadExact
  {An unramified extension of F of degree n.}
  require n gt 0: "n must be positive";
  if n eq 1 then
    return F;
  end if;
  Fbar, modp, xmodp := ResidueClassField(F);
  Ubar := ext<Fbar | n>;
  fmodp := DefiningPolynomial(Ubar, Fbar);
  R := PolynomialRing(F);
  xR := PolynomialRing(F`approximation_field);
  f := WeakApproximation(R ! xR ! [cmodp @@ xmodp : cmodp in Coefficients(fmodp)]);
  return UnramifiedExtension(f);
end intrinsic;

/// The totally ramified extension defined by `f` over its base field or `F`.
intrinsic TotallyRamifiedExtension(f :: RngUPolElt_FldPadExact) -> FldPadExact
  {The totally ramified extension defined by the Eisenstein polynomial f.}
  IncreaseAbsolutePrecision(f, 2); // BUGFIX: magma complains otherwise!
  require IsEisenstein(f) and Degree(f) gt 0: "f must be Eisenstein";
  d := Degree(f);
  F0 := BaseRing(f);
  xF0 := F0`approximation_field;
  xF0`DefaultPrecision := 2;
  F := New(FldPadExact);
  F`id := NEXTID();
  F`type := EISEN;
  F`defining_polynomial := f;
  F`approximation_field := ext<xF0 | map<Z -> PolynomialRing(xF0) | k :-> get_approximation(f, k)>>;
  return F;
end intrinsic;

///ditto
intrinsic TotallyRamifiedExtension(F :: FldPadExact, f) -> FldPadExact
  {The totally ramified extension of F defined by the Eisenstein polynomial f.}
  ok, f := IsCoercible(PolynomialRing(F), f);
  require ok: "f must be coercible to a polynomial over F";
  return TotallyRamifiedExtension(f);
end intrinsic;

/// The totally ramified extension of `F` of degree `n` got by adjoining the `n`th root of `pi` (or the default uniformizer of `F`).
intrinsic TotallyRamifiedExtension(F :: FldPadExact, n :: RngIntElt, pi) -> FldPadExact
  {The totally ramified extension of F got by adjoining the nth root of pi, which must be a uniformizing element.}
  require n ge 1: "n must be at least 1";
  ok, pi := IsCoercible(F, pi);
  require ok: "pi must be coercible to F";
  require IsUniformizingElement(pi): "pi must be a uniformizing element";
  return TotallyRamifiedExtension(Polynomial([F | case<i | 0:-pi, n:1, default:0> : i in [0..n]]));
end intrinsic;

///ditto
intrinsic TotallyRamifiedExtension(F :: FldPadExact, n :: RngIntElt) -> FldPadExact
  {The totally ramified extension of F got by adjoining the nth root of the uniformizing element of F.}
  return TotallyRamifiedExtension(F, n, UniformizingElement(F));
end intrinsic;

///### Completions

function completion(K, P)
  xxC, KtoxxC_old := Completion(K, P);
  e := AbsoluteRamificationDegree(xxC);
  FUDGE := e gt 1 select 2*e else 0;
  if FUDGE gt 0 then
    KtoxxC := map<K -> xxC | x :-> (function (x)
      xxC2 := xxC;
      pr := xxC2`DefaultPrecision;
      xxC2`DefaultPrecision := pr + FUDGE;
      y := CAP_PR(KtoxxC_old(x), pr);
      xxC2`DefaultPrecision := pr;
      return y;
    end function)(x), y :-> y @@ KtoxxC_old>;
  else
    KtoxxC := KtoxxC_old;
  end if;
  C, xxCtoxC := ExactpAdicField(xxC);
  xC := C`approximation_field;
  KtoxC := KtoxxC * xxCtoxC;
  function _KtoC(x)
    assert Parent(x) eq K;
    if x eq 0 then
      return C ! 0;
    end if;
    xxC2 := xxC;
    xxC2`DefaultPrecision := 1;
    xC2 := Approximation(C, 1);
    init := CAP_PR(KtoxC(x), 1);
    mkupdate := func<z | function (apr)
      v := WeakValuation(z);
      pr := IntegerValue(apr - v);
      xxC2 := xxC;
      xxC2`DefaultPrecision := pr + FUDGE;
      xC2 := Approximation(C, pr+FUDGE);
      Update(z, CAP_APR(KtoxC(x), apr));
      return ExactpAdics_ConstGetter(true);
    end function>;
    return C ! <init, mkupdate>;
  end function;
  KtoC := map<K -> C | x :-> _KtoC(x)>;
  add_embedding(C, KtoC);
  return C, KtoC, KtoxC;
end function;

intrinsic ExactCompletion(K :: FldRat, P :: RngIntElt) -> FldPadExact, Map, Map
  {The completion C of K at P as an exact p-adic field. Also returns the embedding K to C, and the invertible map K to xC (the approximation field for C).}
  return completion(K, P);
end intrinsic;

intrinsic ExactCompletion(K :: FldRat, P :: RngInt) -> FldPadExact, Map, Map
  {"}
  return completion(K, P);
end intrinsic;

intrinsic ExactCompletion(K :: FldNum, P :: RngOrdIdl) -> FldPadExact, Map, Map
  {"}
  return completion(K, P);
end intrinsic;

intrinsic ExactCompletion(K :: FldNum, P :: PlcNumElt) -> FldPadExact, Map, Map
  {"}
  return completion(K, P);
end intrinsic;



///### From approximate fields

function eisensteinPolyDefinesUniqueExtension(f)
  d := Degree(f);
  assert IsEisenstein(f);
  D := Discriminant(f);
  if WZERO(D) then
    return false;
  end if;
  vD := VAL(D);
  j := vD - d + 1;
  FUDGE := 2*d*AbsoluteRamificationDegree(BaseRing(f));
  apr := Floor(1+2*j/d) + 1 + FUDGE;
  return forall{c : c in Coefficients(f) | AbsolutePrecision(c) ge apr};
end function;

// true if E/BaseField(E) determines a unique extension
function isDefinitelyUnique1(E)
  if Precision(E) eq OO then
    return true;
  end if;
  f := DefiningPolynomial(E);
  d := Degree(E);
  if IsUnramified(E) then
    assert IsInertial(f);
    return forall{c : c in Coefficients(f) | AbsolutePrecision(c) ge 1};
  elif IsTotallyRamified(E) then
    return eisensteinPolyDefinesUniqueExtension(f);
  else
    assert false;
  end if;
end function;

function isDefinitelyUnique(E, F)
  twr := TOWER(E, F);
  return forall{i : i in [2..#twr] | isDefinitelyUnique1(twr[i])};
end function;

intrinsic ExactpAdicField(xxL :: FldPad : NoCheckUnique:=false) -> FldPadExact, Map
  {Given a p-adic field xxL, returns L isomorphic to xxL and a map xxL -> xL.}
  if IsPrimeField(xxL) then
    L := ExactpAdicField(Prime(xxL));
    L`approximation_field := xxL;
    return L, map<xxL -> xxL | x :-> x, y :-> y>;
  else
    return ExactpAdicField(xxL, ExactpAdicField(PrimeField(xxL)) : NoCheckUnique:=NoCheckUnique);
  end if;
end intrinsic;

// given xxL/xxK and xxK~K, returns L/K with L~K
intrinsic ExactpAdicField(xxL :: FldPad, mK :: Map, K :: FldPadExact : NoCheckUnique:=false) -> FldPadExact, Map
  {Given an extension xxL/xxK and mK : xxK -> xK where xK is the approximation field of K, returns L/K isomorphic to xxL/xxK and a map xxL -> xL.}
  xxK := Domain(mK);
  // base case
  if xxL eq xxK then
    require Codomain(mK) eq K`approximation_field: "";
    return K, mK;
  end if;
  // check xxL is a good extension
  require not IsPrimeField(xxL): "xxL must be an extension of xxK";
  if not NoCheckUnique then
    require isDefinitelyUnique1(xxL): "xxL does not define a unique extension";
  end if;
  // recursively find the base field
  xxL0 := BaseField(xxL);
  L0, mL0 := ExactpAdicField(xxL0, mK, K : NoCheckUnique:=NoCheckUnique);
  xL0 := L0`approximation_field;
  // make the defining polynomial
  xxf := DefiningPolynomial(xxL);
  R := PolynomialRing(L0);
  xR := R`approximation_ring;
  xf := CAST(xR, [c @ mL0 : c in Coefficients(xxf)]);
  if Precision(xxL) eq OO then
    e := RamificationDegree(xxL);
    FUDGE := e gt 1 select 2*e else 0;
    mkupdate := func<z | function (aprs)
      apr := IntegerValue(&join aprs);
      return Approximation_Lazy(R, apr) mod function (xR)
        locxxL := xxL;
        locxxL`DefaultPrecision := apr*e + FUDGE;
        xxf := CHANGE_APR(xxf, [Min(apr*e, APR(c)) : c in Coefficients(xxf)]) where xxf := DefiningPolynomial(locxxL);
        xf := CAST(xR, [c @ mL0 : c in Coefficients(xxf)]);
        Update(z, xf);
        return true;
      end function;
    end function>;
    f := R ! <xf, mkupdate>;
  else
    f := WeakApproximation(CAST(R, xf));
  end if;
  // make the extension
  L := Extension(f);
  xL := L`approximation_field;
  // make the map
  mL := map<xxL -> xL |
    y :-> CAST(xL, [c@mL0 : c in Eltseq(y)]),
    x :-> CAST(xxL, [c@@mL0 : c in Eltseq(x)])>;
  // done
  return L, mL;
end intrinsic;

intrinsic ExactpAdicField(xxL :: FldPad, xxK :: FldPad, K :: FldPadExact : NoCheckUnique:=false) -> FldPadExact, Map
  {Given xxL/xxK where xxK is coercible to and from xK where xK is the approximation field of K, returns L/K isomorphic to xxL/xxK, and a map xxL -> xL.}
  xK := K`approximation_field;
  mK := map<xxK -> xK | x :-> CAST(xK, x), y :-> CAST(xxK, y)>;
  return ExactpAdicField(xxL, mK, K : NoCheckUnique:=NoCheckUnique);
end intrinsic;

intrinsic ExactpAdicField(xxL :: FldPad, K :: FldPadExact : NoCheckUnique:=false) -> FldPadExact, Map
  {Given xxL/xK where xK is the approximation field of K, returns L/K isomorphic to xxL/xK, and a map xL -> xxL.}
  xK := K`approximation_field;
  mK := map<xK -> xK | x :-> x, y :-> y>;
  return ExactpAdicField(xxL, mK, K : NoCheckUnique:=NoCheckUnique);
end intrinsic;

///## Creation of p-adic numbers

///### Distinguished elements

intrinsic Zero(F :: FldPadExact) -> FldPadExactElt
  {Zero.}
  if not assigned F`zero then
    F`zero := CAST(F, 0);
  end if;
  return F`zero;
end intrinsic;

intrinsic One(F :: FldPadExact) -> FldPadExactElt
  {One.}
  if not assigned F`one then
    F`one := CAST(F, 1);
  end if;
  return F`one;
end intrinsic;

intrinsic UniformizingElement(F :: FldPadExact) -> FldPadExactElt
  {The uniformizing element of F.}
  if not assigned F`uniformizing_element then
    case F`type:
    when PRIME:
      pi := CAST(F, Prime(F));
    when INERT:
      pi := CAST(F, UniformizingElement(BaseField(F)));
    when EISEN:
      pi := Generator(F);
    when EMBED:
      _,m := Image(F`defining_embedding);
      pi := m(UniformizingElement(Domain(m)));
    else
      error "not implemented";
    end case;
    F`uniformizing_element := pi;
  end if;
  return F`uniformizing_element;
end intrinsic;

intrinsic InertiaGenerator(F :: FldPadExact) -> FldPadExactElt
  {An element of F generating the maximal unramified subextension of F over its prime subfield, and its minimal polynomial.}
  if not assigned F`inertia_generator then
    RF, modp := ResidueClassField(F);
    F`inertia_generator := WeakApproximation(PrimitiveElement(RF) @@ modp);
  end if;
  return F`inertia_generator;
end intrinsic;

/// A primitive element of `E` over its prime subfield or `F`.
intrinsic PrimitiveElement(E :: FldPadExact) -> FldPadExactElt
  {A primitive element of E over Qp.}
  if not assigned E`primitive_element then
    E`primitive_element := PrimitiveElement(E, PrimeField(E));
  end if;
  return E`primitive_element;
end intrinsic;

///ditto
intrinsic PrimitiveElement(E :: FldPadExact, F :: FldPadExact) -> FldPadExactElt
  {A primitive element of E/F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return PrimitiveElement(x);
end intrinsic;

///hide
intrinsic PrimitiveElement(x :: ExtDataFldPadExact) -> FldPadExactElt
  {A primitive element for the extension.}
  if not assigned x`primitive_element then
    if Degree(x) eq 1 then
      e := CAST(x`top_field, 1);
    elif BaseField(x`top_field) eq x`base_field then
      e := Generator(x`top_field);
    elif RamificationDegree(x) eq 1 then
      e := InertiaGenerator(x`top_field);
    elif InertiaDegree(x) eq 1 then
      e := UniformizingElement(x`top_field);
    else
      e := InertiaGenerator(x`top_field) + UniformizingElement(x`top_field);
    end if;
    x`primitive_element := e;
  end if;
  return x`primitive_element;
end intrinsic;

///### From coefficients

/// Constructs an element of `E`, where the right hand side is either:
/// - a single element, coercible to `E`
/// - multiple elements, coercible to the base field of `E`, interpreted as coefficients
intrinsic EltConstructor(E :: FldPadExact, t :: .) -> FldPadExactElt
  {Makes an element of E.}
  if #t eq 1 then
    return CAST(E, t[1]);
  elif #t gt 1 then
    E0 := BaseField(E);
    return CAST(E, [E0 | x : x in t]);
  else
    error "RHS must be nonempty";
  end if;
end intrinsic;

///### Coercion

function is_coercible_from_embeddings(F, X)
  if assigned F`embeddings then
    for emb in F`embeddings do
      ok, X0 := IsCoercible(Domain(emb), X);
      if ok then
        return true, emb(X0);
      end if;
    end for;
  end if;
  return false, _;
end function;

function is_coercible_from_basefield(F, X)
  if not IsPrimeField(F) then
    F0 := BaseField(F);
    ok, X0 := IsCoercible(F0, X);
    if ok then
      return true, CAST(F, [X0]);
    end if;
  end if;
  return false, _;
end function;

/// True if `X` is coercible to an element of `F`, and the coerced element.
/// 
/// `X` must be either:
/// - an element of `F`
/// - an integer or rational
/// - coercible to the base field of `F`
/// - coercible to a field embedded in `F` (such as if `F` is a completion)
/// - a `FldPadElt` coercible to the approximation field of `F`
/// - a sequence of elements coercible to the base field of `F`
/// - a tuple `<init, mkupdate>` or `<init, mkupdate, data>` defining the element directly
intrinsic IsCoercible(F :: FldPadExact, X) -> BoolElt, .
  {True if X is coercible to an element of F, and the coerced element.}
  ok, x := is_coercible_from_embeddings(F, X);
  if ok then
    return true, x;
  end if;
  ok, x := is_coercible_from_basefield(F, X);
  if ok then
    return true, x;
  end if;
  return false, "not coercible";
end intrinsic;

///hide-all

function makeElt(F, init, mkupdate)
  x := New(FldPadExactElt);
  x`parent := F;
  FUDGE := GLOBAL_FUDGE(F);
  case Type(mkupdate):
  when UserProgram:
    x`update := FUDGE eq 0 select u else func<apr | u(apr + FUDGE)> where u:=mkupdate(x);
  when BoolElt:
    ;
  else
    return false, "bad mkupdate";
  end case;
  x`id := NEXTID();
  case Type(init):
  when FldPadElt:
    ok, init := IS_VALID_APPROX(F, init);
    if ok then
      x`approximation := init;
    else
      return false, "wrong field";
    end if;
  when RngIntElt:
    IncreaseAbsolutePrecision(x, init);
  else
    return false, "bad init";
  end case;
  SetBaselineValuation(x, WeakValuation(x));
  return true, x;
end function;

intrinsic IsCoercible(F :: FldPadExact, X :: Tup) -> BoolElt, .
  {"}
  case #X:
  when 2:
    return makeElt(F, X[1], X[2]);
  when 3:
    ok, x := makeElt(F, X[1], X[2]);
    if ok then
      SetData(x, X[3]);
      return true, x;
    else
      return false, x;
    end if;
  end case;
  return false, "not coercible";
end intrinsic;

function _fromRational(F, X)
  if X eq 0 then
    xF := Approximation(F);
    init := xF ! X;
    mkupdate := func<z | func<apr | true>>;
    return F ! <init, mkupdate>;
  else
    e := AbsoluteRamificationDegree(F);
    p := Prime(F);
    v := e * Valuation(X, p);
    FUDGE := e gt 1 select 2*e else 0;
    xF := Approximation(F, 1+FUDGE);
    init := CAP_PR(CAST(xF, X), 1);
    assert WVAL(init) eq v;
    mkupdate := func<z | function (apr)
      pr := Max(Z!apr`value - v, 1) + FUDGE;
      return Approximation_Lazy(F, pr) mod function (xF)
        loc_FUDGE := FUDGE;
        loc_init := init;
        loc_apr := apr;
        loc_X := X;
        loc_z := z;
        loc_pr := pr;
        Update(z, CAP_APR(CAST(xF, X), apr));
        return true;
      end function;
    end function>;
    return F ! <init, mkupdate>;
  end if;
end function;

function fromRational(F, X)
  if X eq 0 then
    if not assigned F`zero then
      F`zero := _fromRational(F, 0);
    end if;
    return F`zero;
  elif X eq 1 then
    if not assigned F`one then
      F`one := _fromRational(F, 1);
    end if;
    return F`one;
  elif X eq Prime(F) and AbsoluteRamificationDegree(F) eq 1 then
    if not assigned F`uniformizing_element then
      F`uniformizing_element := _fromRational(F, Prime(F));
    end if;
    return F`uniformizing_element;
  else
    return _fromRational(F, X);
  end if;
end function;

intrinsic IsCoercible(F :: FldPadExact, X :: RngIntElt) -> BoolElt, .
  {"}
  return true, fromRational(F, X);
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: FldRatElt) -> BoolElt, .
  {"}
  return true, fromRational(F, X);
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: FldPadExactElt) -> BoolElt, .
  {"}
  if F eq Parent(X) then
    return true, X;
  end if;
  ok, x := is_coercible_from_basefield(F, X);
  if ok then
    return true, x;
  end if;
  return false, "not coercible";
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: []) -> BoolElt, .
  {"}
  require not IsPrimeField(F): "F must be an extension";
  F0 := BaseField(F);
  ok, X := CanChangeUniverse(X, F0);
  if ok then
    case F`type:
    when INERT:
      xF := Approximation(F, 1);
      init := CAST(xF, [Approximation(x, CAPR(x)) : x in X]);
      mkupdate := func<z | function (apr)
        pr := apr - WeakValuation(z);
        return Approximation_Lazy(F, pr) mod function (xF)
          return &cat[Approximation_Lazy(x, apr) : x in X] mod function (xxs)
            Update(z, CAST(xF, xxs));
            return true;
          end function;
        end function;
      end function>;
    when EISEN:
      FUDGE := AbsoluteRamificationDegree(F);
      FUDGE0 := AbsoluteRamificationDegree(F0);
      xF := Approximation(F, 1+FUDGE);
      init := TRIM_APR(CAST(xF, [Approximation(x, CAPR(x : PrCap:=1+FUDGE0)) : x in X]), FUDGE);
      d := Degree(F);
      mkupdate := func<z | function (apr)
        pr := apr - WeakValuation(z);
        return Approximation_Lazy(F, pr+FUDGE) mod function (xF)
          return &cat[Approximation_Lazy(X[i], Ceiling((apr+FUDGE-i+1)/d)) : i in [1..#X]] mod function (xxs)
            loc_z := z;
            loc_apr := apr;
            loc_pr := pr;
            loc_FUDGE := FUDGE;
            loc_xF := xF;
            CHANGE_DPR(xF, pr+FUDGE);
            Update(z, CAP_APR(CAST(xF, xxs), apr));
            return true;
          end function;
        end function;
      end function>;
    when PRIME:
      assert false;
    else
      error "not implemented";
    end case;
    x := F ! <init, mkupdate>;
    // x`coefficients := X;
    return true, x;
  end if;
  return false, "cannot coerce coefficients to the base field";
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: RngPadExactElt) -> BoolElt, .
  {"}
  return IsCoercible(F, X`field_element);
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: FldPadElt) -> BoolElt, .
  {"}
  ok, app := IS_VALID_APPROX(F, X);
  if ok then
    return true, F ! <app, func<z | function (apr)
      error "cannot increase precision of approximate p-adics";
    end function>>;
  end if;
  return false, "wrong field";
end intrinsic;

///hide-none

///### Random

intrinsic RandomInteger(F :: FldPadExact) -> FldPadExactElt
  {A random integer of F.}
  return Random(F, 0);
end intrinsic;

intrinsic Random(F :: FldPadExact, v :: RngIntElt) -> FldPadExactElt
  {A random element of F of value at least v.}
  A := Approximation(F, 1);
  xA := ChangePrecision(A, 1);
  xOA := Integers(xA);
  init := ShiftValuation(CAST(A, CAST(xA, Random(xOA))), v);
  mkupdate := func<z | function (apr)
    v := WeakValuation(z);
    apr0 := AbsolutePrecision(z);
    return Approximation_Lazy(F, apr-v) mod function (A)
      xA := ChangePrecision(A, IntegerValue(apr - apr0));
      xOA := Integers(xA);
      d := ShiftValuation(CAST(A, CAST(xA, Random(xOA))), IntegerValue(apr0));
      // renewEltApproximation(z);
      xz := z`approximation;
      xz2 := d + CHANGE_APR(xz, apr);
      Update(z, xz2);
      return true;
    end function;
  end function>;
  return F ! <init, mkupdate>;
end intrinsic;

intrinsic RandomUnit(F :: FldPadExact) -> FldPadExactElt
  {A random unit of F.}
  return RandomUnit(F, 0);
end intrinsic;

intrinsic RandomUnit(F :: FldPadExact, v :: RngIntElt) -> FldPadExactElt
  {A random element of F of value v.}
  repeat
    x := Random(F, v);
  until ValuationEq(x, v);
  return x;
end intrinsic;



///## Basic operations on p-adic numbers

intrinsic Parent(x :: FldPadExactElt) -> FldPadExact
  {The field containing x.}
  return x`parent;
end intrinsic;

intrinsic Coefficient(x :: FldPadExactElt, i :: RngIntElt) -> FldPadExactElt
  {The generator^i coefficient of x in K(generator)/K.}
  K := Parent(x);
  require not IsPrimeField(K): "x does not lie in an extension";
  d := Degree(K);
  require i ge 0 and i lt d: "i must be between 0 and degree-1";
  if assigned x`coefficients then
    if assigned x`coefficient then
      delete x`coefficient;
    end if;
    return x`coefficients[i+1];
  end if;
  if not assigned x`coefficient then
    x`coefficient := [* false : j in [0..d-1] *];
  end if;
  if x`coefficient[i+1] cmpeq false then
    K0 := BaseField(K);
    case K`type:
    when EISEN:
      init := CAP_PR(ELTSEQ(Approximation(x))[i+1], 1);
      mkupdate := func<z | function (apr)
        return Approximation_Lazy(x : APr:=apr*d+i) mod function (xx)
          Update(z, ELTSEQ(xx)[i+1]);
          return true;
        end function;
      end function>;
      x`coefficient[i+1] := K0 ! <init, mkupdate>;
    when INERT:
      init := CAP_PR(ELTSEQ(Approximation(x))[i+1], 1);
      mkupdate := func<z | function (apr)
        return Approximation_Lazy(x : APr:=apr) mod function (xx)
          Update(z, ELTSEQ(xx)[i+1]);
          return true;
        end function;
      end function>;
      x`coefficient[i+1] := K0 ! <init, mkupdate>;
    when PRIME:
      assert false;
    else
      error "not implemented";
    end case;
  end if;
  return x`coefficient[i+1];
end intrinsic;

intrinsic Coefficients(x :: FldPadExactElt) -> []
  {The coefficients of x in the basis generator^i in K(generator)/K.}
  if not assigned x`coefficients then
    K := Parent(x);
    d := Degree(K);
    x`coefficients := [Coefficient(x, i) : i in [0..d-1]];
  end if;
  return x`coefficients;
end intrinsic;

intrinsic Eltseq(x :: FldPadExactElt) -> []
  {"}
  return Coefficients(x);
end intrinsic;

///## Arithmetic

/// Negate, add, subtract, sum, multiply, product.

intrinsic '-'(x :: FldPadExactElt) -> FldPadExactElt
  {Negation.}
  if not assigned x`negation then
    if IsDefinitelyZero(x) then
      x`negation := x;
    else
      F := Parent(x);
      init := -Approximation(x, CAPR(x));
      mkupdate := func<z | function (apr)
        return Approximation_Lazy(x, apr) mod function (xx)
          Update(z, -xx);
          return true;
        end function;
      end function>;
      x`negation := F ! <init, mkupdate>;
      x`negation`negation := x;
    end if;
  end if;
  return x`negation;
end intrinsic;

///hide
intrinsic '+'(x :: FldPadExactElt) -> FldPadExactElt
  {Unary addition.}
  return x;
end intrinsic;

///ditto
intrinsic '+'(x :: FldPadExactElt, y :: FldPadExactElt) -> FldPadExactElt
  {Addition.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must come from the same field";
  return &+[F | x, y];
end intrinsic;

///hide
intrinsic '+'(x :: FldPadExactElt, y) -> .
  {"}
  return do_binop('+', x, y);
end intrinsic;

///hide
intrinsic '+'(x, y :: FldPadExactElt) -> .
  {"}
  return do_binop('+', x, y);
end intrinsic;

///ditto
intrinsic '-'(x :: FldPadExactElt, y :: FldPadExactElt) -> FldPadExactElt
  {Subtraction.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must be from the same field";
  x := CAST(F, x);
  y := CAST(F, y);
  if IsDefinitelyZero(y) then
    return CAST(F, x);
  elif IsDefinitelyZero(x) then
    return CAST(F, -y);
  else
    init := Approximation(x, CAPR(x)) - Approximation(y, CAPR(x));
    mkupdate := func<z | function (apr)
      return [Approximation_Lazy(t, apr) : t in [x,y]]
      mod function (xx, xy)
        Update(z, xx - xy);
        return true;
      end function;
    end function>;
    return F ! <init, mkupdate>;
  end if;
end intrinsic;

///hide
intrinsic '-'(x :: FldPadExactElt, y) -> .
  {"}
  return do_binop('-', x, y);
end intrinsic;

///hide
intrinsic '-'(x, y :: FldPadExactElt) -> .
  {"}
  return do_binop('-', x, y);
end intrinsic;

///ditto
intrinsic '&+'(xs :: [FldPadExactElt]) -> FldPadExactElt
  {Addition reduction.}
  F := Universe(xs);
  xs := [F | x : x in xs | not IsDefinitelyZero(x)];
  if #xs eq 0 then
    return CAST(F, 0);
  elif #xs eq 1 then
    return xs[1];
  else
    init := &+[Approximation(x, CAPR(x)) : x in xs];
    mkupdate := func<z | function (apr)
      return &cat[Approximation_Lazy(x, apr) : x in xs] mod function (xxs)
        Update(z, &+xxs);
        return true;
      end function;
    end function>;
    ret := F ! <init, mkupdate>;
    return ret;
  end if;
end intrinsic;

///ditto
intrinsic '*'(x :: FldPadExactElt, y :: FldPadExactElt) -> FldPadExactElt
  {Multiplication.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must come from the same field";
  return &*[F | x, y];
end intrinsic;

///hide
intrinsic '*'(x, y :: FldPadExactElt) -> .
  {"}
  return do_binop('*', x, y);
end intrinsic;

///hide
intrinsic '*'(x :: FldPadExactElt, y) -> .
  {"}
  return do_binop('*', x, y);
end intrinsic;

///ditto
intrinsic '&*'(xs :: [FldPadExactElt]) -> FldPadExactElt
  {Multiplication reduction.}
  F := Universe(xs);
  if exists{x : x in xs | IsDefinitelyZero(x)} then
    return CAST(F, 0);
  end if;
  if #xs eq 0 then
    return CAST(F, 1);
  elif #xs eq 1 then
    return xs[1];
  else
    init := &*[Approximation(x, CAPR(x)) : x in xs];
    mkupdate := func<z | function (apr)
      FUDGE := e gt 1 select 2*e else 0 where e := AbsoluteRamificationDegree(F);
      pr := apr - &+[WVAL(x) : x in xs];
      return &cat[Approximation_Lazy(x, WVAL(x)+pr+FUDGE) : x in xs]
      mod function (xxs)
        loc_xs := xs;
        loc_FUDGE := FUDGE;
        loc_pr := pr;
        Update(z, CAP_APR(&*xxs, apr));
        return true;
      end function;
    end function>;
    return F ! <init, mkupdate>;
  end if;
end intrinsic;

/// Division.
///param Strategy Used to confirm that `y` is nonzero.
intrinsic '/'(x :: FldPadExactElt, y :: FldPadExactElt : Strategy:="default") -> FldPadExactElt
  {Division.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must come from the same field";
  x := CAST(F, x);
  y := CAST(F, y);
  if IsDefinitelyZero(y) then
    error "division by zero";
  elif IsWeaklyZero(y : Strategy:=Strategy) then
    error "division by weak zero";
  elif IsDefinitelyZero(x) then
    return x;
  else
    vy := Valuation(y : Strategy:=Strategy);
    init := Approximation(x, CAPR(x)) / Approximation(y, vy+1);
    mkupdate := func<z | function (apr)
      vx := WeakValuation(x);
      pr := apr - (vx - vy);
      return [Approximation_Lazy(x, vx+pr), Approximation_Lazy(y, vy+pr)]
      mod function (xx, xy)
        Update(z, xx / xy);
        return true;
      end function;
    end function>;
    return F ! <init, mkupdate>;
  end if;
end intrinsic;

///hide
intrinsic '/'(x :: FldPadExactElt, y) -> .
  {"}
  return do_binop('/', x, y);
end intrinsic;

///hide
intrinsic '/'(x, y :: FldPadExactElt) -> .
  {"}
  return do_binop('/', x, y);
end intrinsic;

/// Powering.
///param Strategy Used when `n` is negative to confirm that `x` is nonzero.
intrinsic '^'(x :: FldPadExactElt, n :: RngIntElt : Strategy:="default") -> FldPadExactElt
  {Powering.}
  // TODO: bound the n which get cached?
  F := Parent(x);
  if n eq 0 then
    return CAST(F, 1);
  elif n eq 1 then
    return x;
  end if;
  if not assigned x`power then
    x`power := AssociativeArray();
  end if;
  ok, xn := IsDefined(x`power, n);
  if not ok then
    if n gt 0 then
      if IsDefinitelyZero(x) then
        xn := x;
      else
        FUDGE := e gt 1 select 2*e else 0 where e := AbsoluteRamificationDegree(F);
        init := TRIM_APR(Approximation(x, CAPR(x : PrCap:=1+FUDGE))^n, FUDGE);
        mkupdate := func<z | function (apr)
          v := WeakValuation(x);
          pr := apr - n * v;
          return Approximation_Lazy(x, v+pr+FUDGE) mod function (xx)
            Update(z, CAP_APR(xx^n, apr));
            return true;
          end function;
        end function>;
        xn := F ! <init, mkupdate>;
      end if;
    else
      if IsDefinitelyZero(x) then
        error "division by zero";
      elif IsWeaklyZero(x : Strategy:=Strategy) then
        error "division by weak zero";
      else
        v := Valuation(x : Strategy:=Strategy);
        init := Approximation(x, v+1)^n;
        mkupdate := func<z | function (apr)
          pr := apr - n * v;
          return Approximation_Lazy(x, v+pr) mod function (xx)
            Update(z, xx^n);
            return true;
          end function;
        end function>;
        xn := F ! <init, mkupdate>;
      end if;
    end if;
    x`power[n] := xn;
  end if;
  return xn;
end intrinsic;

function shiftVal(x, n)
  y := ShiftValuation(x, n);
  // print "shift", x, y;
  assert AbsolutePrecision(y) eq AbsolutePrecision(x)+n;
  assert Valuation(y) eq Valuation(x)+n;
  assert Precision(y) eq Precision(x);
  // if not WZERO(x) then
  //   assert not WZERO(y);
  //   assert WZERO(ShiftValuation(x/y, n)-1);
  // end if;
  return y;
end function;

function shiftVal_poly(f, ns)
  cs := Coefficients(f);
  return Parent(f) ! [shiftVal(cs[i], ns[i]) : i in [1..#cs]];
end function;

/// Multiplies `x` by the `n`th power of the uniformizing element.
intrinsic ShiftValuation(x :: FldPadExactElt, n) -> FldPadExactElt
  {Returns x*pi^n.}
  ok, n := IsValidAbsolutePrecision(x, n);
  require ok: n;
  return ShiftValuation(x, IntegerValue(n));
end intrinsic;

///hide
intrinsic ShiftValuation(x :: FldPadExactElt, n :: RngIntElt) -> FldPadExactElt
  {"}
  if n eq 0 then
    return x;
  end if;
  K := Parent(x);
  init := ShiftValuation(Approximation(x, CAPR(x)), n);
  mkupdate := func<z | function(apr)
    return Approximation_Lazy(x, apr-n) mod function (xx)
      Update(z, ShiftValuation(xx, n));
      return true;
    end function;
  end function>;
  return K ! <init, mkupdate>;
end intrinsic;

intrinsic IsSquare(x :: FldPadExactElt : Strategy:="default") -> BoolElt, FldPadExactElt
  {True iff x is a square. (Strategy is used to determine if x is nonzero.)}
  return IsPower(x, 2);
end intrinsic;

intrinsic IsPower(x :: FldPadExactElt, n :: RngIntElt : Strategy:="default") -> BoolElt, FldPadExactElt
  {True iff x is an nth power. (Strategy is used to determine if x is nonzero.)}
  requirege n, 1;
  if n eq 1 then
    return true, x;
  elif IsDefinitelyZero(x) then
    return true, x;
  end if;
  require not IsWeaklyZero(x : Strategy:=Strategy): "Argument 1 must be nonzero";
  v := Valuation(x);
  ok, v0 := IsDivisibleBy(v, n);
  if not ok then
    return false, _;
  end if;
  x0 := ShiftValuation(x, -v);
  K := Parent(x);
  R := PolynomialRing(K);
  f := R ! [K| case<i | 0:-x0, n:1, default:0> : i in [0..n]];
  p := Prime(K);
  e := AbsoluteRamificationDegree(K);
  vn := Valuation(n, p) * e;
  rs := Roots(f : Strategy := [* vn+1, <"limit", 10*vn>, <"randomize">, <"double"> *]);
  if #rs gt 0 then
    return true, ShiftValuation(rs[1][1], v0);
  else
    return false, _;
  end if;
end intrinsic;

///## Valuation

intrinsic Valuation(x :: FldPadExactElt : Strategy:="default") -> RngIntElt
  {The valuation of x.}
  if not assigned x`valuation then
    if IsDefinitelyZero(x) then
      x`valuation := Val_FldPadElt_Make(OO);
    elif IsWeaklyZero(x : Strategy:=Strategy) then
      error "weakly zero";
    else
      x`valuation := WeakValuation(x);
    end if;
  end if;
  return x`valuation;
end intrinsic;

///### Comparison to constant

/// Compares the valuation of `x` with `v`.
intrinsic ValuationEq(x :: FldPadExactElt, v) -> BoolElt
  {True if the valuation of x equals v.}
  v := Val_FldPadElt_Make(v);
  if not WZERO(x) then
    return WVAL(x) eq v;
  end if;
  if IsFinite(v) and not IsIntegral(v) then
    return false;
  end if;
  IncreaseAbsolutePrecision(x, v+1);
  return WVAL(x) eq v;
end intrinsic;

///ditto
intrinsic ValuationNe(x :: FldPadExactElt, v) -> BoolElt
  {True if x does not have valuation v.}
  return not ValuationEq(x, v);
end intrinsic;

///ditto
intrinsic ValuationGe(x :: FldPadExactElt, v) -> BoolElt
  {True if the valuation of x is at least v.}
  IncreaseAbsolutePrecision(x, Ceiling(v));
  return WeakValuation(x) ge v;
end intrinsic;

///ditto
intrinsic ValuationGt(x :: FldPadExactElt, v) -> BoolElt
  {True if the valuation of x is greater than v.}
  v := Val_FldPadElt_Make(v);
  if v eq OO then
    return false;
  else
    return ValuationGe(x, v+1);
  end if;
end intrinsic;

///ditto
intrinsic ValuationLe(x :: FldPadExactElt, v) -> BoolElt
  {True if the valuation of x is at most v.}
  return not ValuationGt(x, v);
end intrinsic;

///ditto
intrinsic ValuationLt(x :: FldPadExactElt, v) -> BoolElt
  {True if the valuation of x is less than v.}
  return not ValuationGe(x, v);
end intrinsic;

/// True if `x` is a uniformizing element; that is, its valuation is 1.
intrinsic IsUniformizingElement(x :: FldPadExactElt) -> BoolElt
  {True iff x is a uniformizing element, i.e. has valuation 1.}
  return ValuationEq(x, 1);
end intrinsic;

/// True if `x` is a unit; that is, its valuation is 0.
intrinsic IsUnit(x :: FldPadExactElt) -> BoolElt
  {True if x has valuation 0.}
  return ValuationEq(x, 0);
end intrinsic;

/// True if `x` is an integer; that is, its valuation is at least 0.
intrinsic IsIntegral(x :: FldPadExactElt) -> BoolElt
  {True if x has valuation at least 0.}
  return ValuationGe(x, 0);
end intrinsic;

///### Comparison between elements

intrinsic ValuationCmpValuation_Lazy(x :: FldPadExactElt, y :: FldPadExactElt : Strategy:="default") -> ExactpAdics_Gettr
  {Respectively <0, 0 or >0 if the valuation of x is less than, equal to or greater than the valuation of y.}
  // NOTE: when we call ExactpAdics_StepPrecisionStrategy(~ok,~pr,~st), we COULD raise a precision error immediately if not ok; however by deferring doing this until the next time 
  error if AbsoluteRamificationDegree(Parent(x)) ne AbsoluteRamificationDegree(Parent(y)), "not implemented when arguments are in fields of different ramification degree";
  b := BaselineValuation(x) meet BaselineValuation(y);
  return Apply(function (x)
      ok, _, ret := Explode(x);
      error if not ok, "precision error";
      return ret;
    end function,
    ExactpAdics_ExecutePrecisionStrategy_Lazy(Strategy,
      procedure (pr, ~getter)
        getter := Flatten([Approximation_Lazy(x, b+pr), Approximation_Lazy(y, b+pr)]);
      end procedure,
      procedure (xxyy, ~value)
        xx, yy := Explode(xxyy);
        assert APR(xx) eq APR(yy);
        if not (WZERO(xx) and WZERO(yy)) then
          value := VAL(xx) - VAL(yy);
        end if;
      end procedure
    )
  );
end intrinsic;

intrinsic ValuationCmpValuation(x :: FldPadExactElt, y :: FldPadExactElt : Strategy:="default") -> RngIntElt
  {"}
  return Evaluate(ValuationCmpValuation_Lazy(x, y : Strategy:=Strategy));
end intrinsic;

intrinsic ValuationGtValuation_Lazy(x :: FldPadExactElt, y :: FldPadExactElt : Strategy:="default") -> ExactpAdics_Gettr
  {True iff x has greater valuation than y.}
  return Apply(func<x | x gt 0>, ValuationCmpValuation_Lazy(x, y : Strategy:=Strategy));
end intrinsic;

intrinsic ValuationGtValuation(x :: FldPadExactElt, y :: FldPadExactElt : Strategy:="default") -> BoolElt
  {"}
  return ValuationCmpValuation(x, y : Strategy:=Strategy) gt 0;
end intrinsic;

///### Smallest and closest

function smallestIndex(xs)
  // (determinable), (unique), (index)
  n := #xs;
  wzis := [i : i in [1..n] | WZERO(xs[i])];
  if #wzis eq 0 then
    vs := [Valuation(x) : x in xs];
    v, i := Max(vs);
    return true, forall{j : j in [1..#xs] | vs[j] lt v or j eq i}, i;
  elif #wzis eq 1 then
    i := wzis[1];
    v := Max([Valuation(xs[j]) : j in [1..n] | j ne i]);
    if ValuationGt(xs[i], v) then
      return true, true, i;
    else
      return smallestIndex(xs);
    end if;
  else
    return false, _, _;
  end if;
end function;

intrinsic IndexOfSmallest(xs :: [FldPadExactElt] : Strategy:="default", Unique:=false) -> RngIntElt
  {The index i maximizing Valuation(xs[i]). If Unique, raises an error if there is no unique smallest.}
  // trivial cases
  if #xs eq 0 then
    error "xs must not be empty";
  elif #xs eq 1 then
    return 1;
  end if;
  ok, unique, i := smallestIndex(xs);
  if not ok then
    ok, _, ret := ExactpAdics_ExecutePrecisionStrategy(function (pr)
      IncreaseAbsolutePrecisions([*<x,pr> : x in xs*]);
      ok, unique, i := smallestIndex(xs);
      if ok then
        return true, [*unique, i*];
      else
        return false, _;
      end if;
    end function, Strategy);
    unique, i := Explode(ret);
  end if;
  if ok then
    if unique or (not Unique) then
      return i;
    else
      error "not unique";
    end if;
  else
    error "several elements weakly zero";
  end if;
end intrinsic;

intrinsic IndexOfClosest(x :: FldPadExactElt, ys :: [FldPadExactElt] : Strategy:="default", Unique:=false) -> RngIntElt
  {The index i maximizing Valuation(x-ys[i]). If Unique, raises an error if there is no unique closest.}
  return IndexOfSmallest([x-y : y in ys] : Strategy:=Strategy, Unique:=Unique);
end intrinsic;

intrinsic Smallest(xs :: [FldPadExactElt] : Strategy:="default", Unique:=false) -> FldPadExactElt, RngIntElt
  {The smallest element of xs, and its index.}
  i := IndexOfSmallest(xs : Strategy:=Strategy, Unique:=Unique);
  return xs[i], i;
end intrinsic;

intrinsic Closest(x :: FldPadExactElt, ys :: [FldPadExactElt] : Strategy:="default", Unique:=false) -> FldPadExactElt, RngIntElt
  {The closest element y of ys to x and its index.}
  i := IndexOfClosest(x, ys : Strategy:=Strategy, Unique:=Unique);
  return ys[i], i;
end intrinsic;

///## Extensions

intrinsic BaseField(F :: FldPadExact) -> FldPadExact
  {The base field of F.}
  if not assigned F`base_field then
    case F`type:
    when INERT, EISEN:
      F0 := BaseRing(DefiningPolynomial(F));
    when EMBED:
      m := F`defining_embedding;
      F0 := Image(Restriction(m, BaseField(Domain(m))));
    when PRIME:
      error "F must be an extension";
    else
      error "not implemented";
    end case;
    F`base_field := F0;
  end if;
  return F`base_field;
end intrinsic;

intrinsic IsPrimeField(F :: FldPadExact) -> BoolElt
  {True if F is a prime p-adic field.}
  return (F`type eq PRIME) or (F`type eq EMBED and IsPrimeField(Domain(F`defining_embedding)));
end intrinsic;

intrinsic PrimeField(F :: FldPadExact) -> BoolElt
  {The prime field of F.}
  if not assigned F`prime_field then
    F`prime_field := IsPrimeField(F) select F else PrimeField(BaseField(F));
  end if;
  return F`prime_field;
end intrinsic;

intrinsic IsExtensionOf(E :: FldPadExact, F :: FldPadExact) -> BoolElt, ExtDataFldPadExact
  {True if E is an extension of F. If so, also returns an object representing the extension.}
  // check if already cached
  if not assigned E`subfield_data then
    E`subfield_data := AssociativeArray();
  end if;
  ok, x := IsDefined(E`subfield_data, F`id);
  if ok then
    return true, x;
  end if;
  // E = F
  if E eq F then
    x := New(ExtDataFldPadExact);
    x`top_field := E;
    x`base_field := F;
    x`type := COMPOUND;
    x`list := [];
    E`subfield_data[F`id] := x;
    return true, x;
  end if;
  // consider base field E0 of E
  if not IsPrimeField(E) then
    E0 := BaseField(E);
    // E0 = F
    if E0 eq F then
      x := New(ExtDataFldPadExact);
      x`top_field := E;
      x`base_field := F;
      x`type := deep_type(E) where deep_type := function (E)
        while E`type eq EMBED do
          E := Domain(E`defining_embedding);
        end while;
        return E`type;
      end function;
      E`subfield_data[F`id] := x;
      return true, x;
    end if;
    // E0 / F
    ok, x0 := IsExtensionOf(E0, F);
    if ok then
      ok, x1 := IsExtensionOf(E, E0);
      assert ok;
      x := New(ExtDataFldPadExact);
      x`top_field := E;
      x`base_field := F;
      x`type := COMPOUND;
      x`list := [x0, x1];
      E`subfield_data[F`id] := x;
      return true, x;
    end if;
  end if;
  // F -> E
  if F`type eq EMBED and Codomain(F`defining_embedding) eq E then
    x := New(ExtDataFldPadExact);
    x`top_field := E;
    x`base_field := F;
    x`type := EMBED;
    E`subfield_data[F`id] := x;
    return true, x;
  end if;
  // false
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: FldPadExact, F :: FldPadExact) -> BoolElt, .
  {True if there is a structure containing E and F, and the common structure.}
  if E eq F then
    return true, E;
  elif IsExtensionOf(E, F) then
    return true, E;
  elif IsExtensionOf(F, E) then
    return true, F;
  else
    return false, _;
  end if;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: FldPadExact, F :: RngInt) -> BoolElt, .
  {"}
  return true, E;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: RngInt, F :: FldPadExact) -> BoolElt, .
  {"}
  return true, F;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: FldPadExact, F :: FldRat) -> BoolElt, .
  {"}
  return true, E;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: FldRat, F :: FldPadExact) -> BoolElt, .
  {"}
  return true, F;
end intrinsic;

///### Basic information

intrinsic DefiningPolynomial(K :: FldPadExact) -> RngUPolElt_FldPadExact
  {The defining polynomial of K.}
  if assigned K`defining_polynomial then
    return K`defining_polynomial;
  else
    assert IsPrimeField(K);
    error "K is a prime field";
  end if;
end intrinsic;

intrinsic AssignNames(~F :: FldPadExact, names :: [MonStgElt])
  {Assigns a name to the generator of F.}
  require not IsPrimeField(F): "F must be an extension";
  require #names eq 1: "names must have one element";
  F`varname := names[1];
  AssignNames(~F`approximation_field, names);
end intrinsic;

intrinsic Name(F :: FldPadExact, i :: RngIntElt) -> FldPadExactElt
  {The ith generator of F.}
  require i eq 1: "i must be 1";
  return Generator(F);
end intrinsic;

intrinsic '.'(F :: FldPadExact, i :: RngIntElt) -> FldPadExactElt
  {"}
  require i eq 1: "i must be 1";
  return Generator(F);
end intrinsic;

intrinsic Generator(F :: FldPadExact) -> FldPadExactElt
  {The generating element of F.}
  if not assigned F`generator then
    require not IsPrimeField(F): "F must be an extension";
    F`generator := CAST(F, [0, 1]);
  end if;
  return F`generator;
end intrinsic;

intrinsic 'eq'(F :: FldPadExact, E :: FldPadExact) -> BoolElt
  {Equality.}
  return F`id eq E`id;
end intrinsic;

///### Invariants

intrinsic Prime(F :: FldPadExact) -> RngIntElt
  {The p in p-adic.}
  if not assigned F`prime then
    F`prime := Prime(BaseField(F));
  end if;
  return F`prime;
end intrinsic;

/// The degree of `E` over its base field or `F`.
intrinsic Degree(E :: FldPadExact) -> RngIntElt
  {The degree of E over its base field.}
  if not assigned E`degree then
    case E`type:
    when INERT, EISEN:
      d := Degree(DefiningPolynomial(E));
    when EMBED:
      m := E`defining_embedding;
      return Degree(Domain(m));
    when PRIME:
      error "E must be an extension";
    else
      error "not implemented";
    end case;
    E`degree := d;
  end if;
  return E`degree;
end intrinsic;

///ditto
intrinsic Degree(E :: FldPadExact, F :: FldPadExact) -> RngIntElt
  {The degree of E over F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return Degree(x);
end intrinsic;

///hide
intrinsic Degree(x :: ExtDataFldPadExact) -> RngIntElt
  {The degree of the extension.}
  if not assigned x`degree then
    case x`type:
    when COMPOUND:
      d := &*[Z| Degree(y) : y in x`list];
    when INERT, EISEN:
      d := Degree(x`top_field);
    when EMBED:
      ok, d := IsDivisibleBy(AbsoluteDegree(x`top_field), AbsoluteDegree(x`base_field));
      assert ok;
    else
      error "not implemented";
    end case;
    x`degree := d;
  end if;
  return x`degree;
end intrinsic;

intrinsic AbsoluteDegree(F :: FldPadExact) -> RngIntElt
  {The degree of F over its prime field.}
  if not assigned F`absolute_degree then
    case F`type:
    when PRIME:
      d := 1;
    when INERT, EISEN:
      d := Degree(F) * AbsoluteDegree(BaseField(F));
    when EMBED:
      m := F`defining_embedding;
      d := AbsoluteDegree(Domain(m));
    else
      error "not implemented";
    end case;
    F`absolute_degree := d;
  end if;
  return F`absolute_degree;
end intrinsic;

/// The inertia degree of `E` over its base field or `F`.
intrinsic InertiaDegree(E :: FldPadExact) -> RngIntElt
  {The inertia degree of E over its base field.}
  if not assigned E`inertia_degree then
    case E`type:
    when INERT:
      d := Degree(E);
    when EISEN:
      d := 1;
    when EMBED:
      m := E`defining_embedding;
      d := InertiaDegree(Domain(m));
    when PRIME:
      error "E must be an extension";
    else
      error "not implemented";
    end case;
    E`inertia_degree := d;
  end if;
  return E`inertia_degree;
end intrinsic;

///ditto
intrinsic InertiaDegree(E :: FldPadExact, F :: FldPadExact) -> RngIntElt
  {The inertia degree of E over F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return InertiaDegree(x);
end intrinsic;

///hide
intrinsic InertiaDegree(x :: ExtDataFldPadExact) -> RngIntElt
  {The inertia degree.}
  if not assigned x`inertia_degree then
    case x`type:
    when COMPOUND:
      d := &*[Z| InertiaDegree(y) : y in x`list];
    when INERT, EISEN:
      d := InertiaDegree(x`top_field);
    when EMBED:
      ok, d := IsDivisibleBy(AbsoluteInertiaDegree(x`top_field), AbsoluteInertiaDegree(x`base_field));
      assert ok;
    else
      error "not implemented";
    end case;
    x`inertia_degree := d;
  end if;
  return x`inertia_degree;
end intrinsic;

intrinsic AbsoluteInertiaDegree(F :: FldPadExact) -> RngIntElt
  {The inertia degree of F over its prime field.}
  if not assigned F`absolute_inertia_degree then
    case F`type:
    when PRIME:
      d := 1;
    when INERT, EISEN:
      d := InertiaDegree(F) * AbsoluteInertiaDegree(BaseField(F));
    when EMBED:
      m := F`defining_embedding;
      d := AbsoluteInertiaDegree(Domain(m));
    else
      error "not implemented";
    end case;
    F`absolute_inertia_degree := d;
  end if;
  return F`absolute_inertia_degree;
end intrinsic;

/// The ramification degree of `E` over its base field or `F`.
intrinsic RamificationDegree(E :: FldPadExact) -> RngIntElt
  {The ramificationd degree of E over its base field.}
  if not assigned E`ramification_degree then
    case E`type:
    when EISEN:
      d := Degree(E);
    when INERT:
      d := 1;
    when EMBED:
      m := E`defining_embedding;
      d := RamificationDegree(Domain(m));
    when PRIME:
      error "E must be an extension";
    else
      error "not implented";
    end case;
    E`ramification_degree := d;
  end if;
  return E`ramification_degree;
end intrinsic;

///ditto
intrinsic RamificationDegree(E :: FldPadExact, F :: FldPadExact) -> RngIntElt
  {The ramification degree of E over F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return RamificationDegree(x);
end intrinsic;

///hide
intrinsic RamificationDegree(x :: ExtDataFldPadExact) -> RngIntElt
  {The ramification degree of the extension.}
  if not assigned x`ramification_degree then
    case x`type:
    when COMPOUND:
      d := &*[Z| RamificationDegree(y) : y in x`list];
    when INERT, EISEN:
      d := RamificationDegree(x`top_field);
    when EMBED:
      ok, d := IsDivisibleBy(AbsoluteRamificationDegree(x`top_field), AbsoluteRamificationDegree(x`base_field));
      assert ok;
    else
      error "not implemented";
    end case;
    x`ramification_degree := d;
  end if;
  return x`ramification_degree;
end intrinsic;

intrinsic AbsoluteRamificationDegree(F :: FldPadExact) -> RngIntElt
  {The ramification degree of F over its prime field.}
  if not assigned F`absolute_ramification_degree then
    case F`type:
    when EISEN, INERT:
      d := RamificationDegree(F) * AbsoluteRamificationDegree(BaseField(F));
    when PRIME:
      d := 1;
    when EMBED:
      m := F`defining_embedding;
      d := AbsoluteRamificationDegree(Domain(m));
    else
      error "not implemented";
    end case;
    F`absolute_ramification_degree := d;
  end if;
  return F`absolute_ramification_degree;
end intrinsic;

/// The valuation of the discriminant of `E` over its base field or `F`.
intrinsic DiscriminantValuation(E :: FldPadExact) -> RngIntElt
  {The valuation of the discriminant of E over its base field.}
  if not assigned E`discriminant_valuation then
    rp := RamificationPolygon(E);
    i0, v0 := Explode(Vertices(rp)[1]);
    assert i0 eq 1;
    E`discriminant_valuation := v0;
  end if;
  return E`discriminant_valuation;
end intrinsic;

///ditto
intrinsic DiscriminantValuation(E :: FldPadExact, F :: FldPadExact) -> RngIntElt
  {The valuation of the discriminant of E/F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return DiscriminantValuation(x);
end intrinsic;

///hide
intrinsic DiscriminantValuation(x :: ExtDataFldPadExact) -> RngIntElt
  {The valuation of the discriminant.}
  if not assigned x`discriminant_valuation then
    rp := RamificationPolygon(x);
    i0, v0 := Explode(Vertices(rp)[1]);
    assert i0 eq 1;
    x`discriminant_valuation := v0;
  end if;
  return x`discriminant_valuation;
end intrinsic;

///### Ramification predicates

/// True if `E` is unramified over its base field or `F`; that is, if the ramification degree is 1.
intrinsic IsUnramified(E) -> BoolElt
  {True if E is unramified.}
  return RamificationDegree(E) eq 1;
end intrinsic;

///ditto
intrinsic IsUnramified(E, F) -> BoolElt
  {True if E/F is unramified.}
  return RamificationDegree(E, F) eq 1;
end intrinsic;

/// True if `E` is ramified over its base field or `F`; that is, if the ramification degree is not 1.
intrinsic IsRamified(E) -> BoolElt
  {True if E is ramified.}
  return RamificationDegree(E) ne 1;
end intrinsic;

///ditto
intrinsic IsRamified(E, F) -> BoolElt
  {True if E/F is ramified.}
  return RamificationDegree(E, F) ne 1;
end intrinsic;

/// True if `E` is totally ramified over its base field or `F`; that is, if the inertia degree is 1.
intrinsic IsTotallyRamified(E) -> BoolElt
  {True if E is totally ramified.}
  return InertiaDegree(E) eq 1;
end intrinsic;

///ditto
intrinsic IsTotallyRamified(E, F) -> BoolElt
  {True if E/F is totally ramified.}
  return InertiaDegree(E, F) eq 1;
end intrinsic;

/// True if `E` is wildly ramified over its base field or `F`; that is, if the ramification degree is divisible by the prime p.
intrinsic IsWildlyRamified(E) -> BoolElt
  {True if E is wildly ramified.}
  return IsDivisibleBy(RamificationDegree(E), Prime(E));
end intrinsic;

///ditto
intrinsic IsWildlyRamified(E, F) -> BoolElt
  {True if E/F is wildly ramified.}
  return IsDivisibleBy(RamificationDegree(E, F), Prime(F));
end intrinsic;

/// True if `E` is totally wildly ramified over its base field or `F`; that is, if it is totally ramified and the ramification degree is a power of the prime p.
intrinsic IsTotallyWildlyRamified(E) -> BoolElt
  {True if E is totally wildly ramified.}
  return IsTotallyRamified(E) and IsPowerOf(RamificationDegree(E), Prime(E));
end intrinsic;

///ditto
intrinsic IsTotallyWildlyRamified(E, F) -> BoolElt
  {True if E/F is totally wildly ramified.}
  return IsTotallyRamified(E,F) and IsPowerOf(RamificationDegree(E,F), Prime(F));
end intrinsic;



///### Printing

///hide
intrinsic DescribeExtension(X :: ExtDataFldPadExact : BaseName:="") -> MonStgElt
  {A string describing the extension E/F with F described as FName.}
  if not assigned X`describe_extension then
    case X`type:
    when COMPOUND:
      d := Join([DescribeExtension(Y) : Y in Reverse(X`list)], " over ");
    when INERT:
      d := Sprintf("Unramified extension of degree %o", Degree(X));
    when EISEN:
      d := Sprintf("Totally ramified extension of degree %o", Degree(X));
    when EMBED:
      d := Sprintf("Extension of embedding of degree %o", Degree(X));
    else
      error "not implemented";
    end case;
    X`describe_extension := d;
  end if;
  d := X`describe_extension;
  if #BaseName eq 0 then
    return d;
  elif #d eq 0 then
    return BaseName;
  else
    return Sprintf("%o over %o", d, BaseName);
  end if;
end intrinsic;

intrinsic DescribeExtension(E :: FldPadExact, F :: FldPadExact : BaseName:="") -> MonStgElt
  {A string describing the extension E/F with F described as FName.}
  ok, X := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return DescribeExtension(X : BaseName:=BaseName);
end intrinsic;

///hide
intrinsic Print(F :: FldPadExact, lvl :: MonStgElt)
  {Print.}
  case lvl:
  when "Magma":
    case F`type:
    when PRIME:
      printf "ExactpAdicField(%m)", Prime(F);
    when INERT:
      printf "UnramifiedExtension(%m)", DefiningPolynomial(F);
    when EISEN:
      printf "TotallyRamifiedExtension(%m)", DefiningPolynomial(F);
    when EMBED:
      error "Image(%m)", F`defining_embedding;
    else
      error "not implemented";
    end case;
  else
    printf "%o", DescribeExtension(F, PrimeField(F) : BaseName:=Sprintf("Exact %o-adic field", Prime(F)));
  end case;
end intrinsic;

///hide
intrinsic Print(x :: FldPadExactElt, lvl :: MonStgElt)
  {"}
  case lvl:
  when "Magma":
    printf "%o", Format(x : APr := APR(x));
  else
    printf "%o", Format(x : APr := CAPR(x));
  end case;
end intrinsic;

///### Standard form

///hide
intrinsic IsInStandardForm(x :: ExtDataFldPadExact) -> BoolElt
  {True if E/F is in standard form.}
  if not assigned x`is_in_standard_form then
    x2 := Flatten(x);
    case #x2`list:
    when 0:
      ok := true;
    when 1:
      ok := x2`list[1] in [INERT, EISEN];
    when 2:
      ok := x2`list[1]`type eq INERT and x2`list[2]`type eq EISEN;
    else
      ok := false;
    end case;
    x`is_in_standard_form := ok;
  end if;
  return x`is_in_standard_form;
end intrinsic;

intrinsic IsInStandardForm(E :: FldPadExact, F :: FldPadExact) -> BoolElt
  {True if E/F is in standard form: E is a totally ramified extension of an unramified extension of F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return IsInStandardForm(x);
end intrinsic;

// ///hide
// intrinsic StandardForm(x :: ExtDataFldPadExact) -> ExtDataFldPadExact
//   {Returns a standard form of x.}
//   if not assigned x`standard_form then
//     if IsInStandardForm(x) then
//       y := x;
//     elif IsUnramified(x) then
//       K := BaseField(x);
//       L := TopField(x);
//       d := Degree(x);
//       y := UnramifiedExtension(K, d) / K;
//     elif IsTotallyRamified(x) then
//       K := BaseField(x);
//       L := TopField(x);
//       m := MinimalPolynomial(UniformizingElement(L), x);
//       y := TotallyRamifiedExtension(K, m) / K;
//     else
//       K := BaseField(x);
//       L := TopField(x);
//       d := Degree(x);
//       e := RamificationDegree(x);
//       f := InertiaDegree(x);
//       m := MinimalPolynomial(UniformizingElement(L) + InertiaGenerator(L), x);
//       U := UnramifiedExtension(K, f);
//       Ubar, bar := ResidueClassField(U);
//       u := Roots(Polynomial([Ubar | ResidueClass(c) : c in Coefficients(m)]))[1][1] @@ bar @ WeakApproximation;
//       mu := Polynomial([&+[U| &*[U| Binomial(i,j), Coefficient(m, i), u^(i-j)] : i in [j..d]] : j in [0..d]]); // f(x+u)
//       facs := NewtonPolygonFactorization(mu);
//       mi := THE([fac : fac in facs | Degree(fac) eq e and IsEisenstein(fac)]);
//       y := TotallyRamifiedExtension(U, mi) / K;
//     end if;
//     assert IsInStandardForm(y);
//     x`standard_form := y;
//   end if;
//   return x`standard_form;
// end intrinsic;

// intrinsic StandardForm(E :: FldPadExact, F :: FldPadExact) -> FldPadExact
//   {Returns a standard form version of E/F (that is, a totally ramified extension of an unramified extension of F).}
//   ok, x := IsExtensionOf(E, F);
//   require ok: "E must be an extension of F";
//   return StandardForm(x)`top_field;
// end intrinsic;

///## Residue class field

procedure assignResidueClassFieldNames(~R, F)
  case F`type:
  when PRIME:
    assert IsPrimeField(R);
  when INERT:
    R0 := BaseField(R);
    F0 := BaseField(F);
    if Degree(R, R0) ne 1 and Degree(F) eq 1 then
      assignResidueClassFieldNames(~R, F0);
    else
      assert Degree(R, R0) eq Degree(F);
      if assigned F`varname then
        AssignNames(~R, [F`varname cat "bar"]);
      end if;
      assignResidueClassFieldNames(~R0, F0);
    end if;
  when EISEN:
    F0 := BaseField(F);
    assignResidueClassFieldNames(~R, F0);
  else
    error "not implemented";
  end case;
end procedure;

intrinsic ResidueClassField(F :: FldPadExact) -> FldFin, Map, Map
  {The residue class field R of F, the map F to R, and the map from the approximation of F to R.}
  if not assigned F`residue_class_field then
    A := Approximation(F, 1);
    OA := Integers(A);
    R, m := ResidueClassField(OA);
    assignResidueClassFieldNames(~R, F);
    function FtoR(x)
      if not assigned x`residue_class then
        error if ValuationLt(x, 0), "not integral";
        x`residue_class := CAST(OA, Approximation(x,1)) @ m;
      end if;
      return x`residue_class;
    end function;
    function RtoF(y)
      x := New(FldPadExactElt);
      x`approximation := CAP_APR(CAST(A, y @@ m), 1);
      x`id := NEXTID();
      x`parent := F;
      x`update := function (apr)
        error "cannot increase precision of preimages of residue classes (consider using WeakApproximation)";
      end function;
      return x;
    end function;
    F`residue_class_field := [*R, map<F -> R | x :-> FtoR(x), y :-> RtoF(y)>, m*];
  end if;
  return Explode(F`residue_class_field);
end intrinsic;

intrinsic ResidueClass(x :: FldPadExactElt) -> FldFinElt
  {The residue class of x.}
  if not assigned x`residue_class then
    F := Parent(x);
    _, m := ResidueClassField(F);
    _ := m(x);
  end if;
  return x`residue_class;
end intrinsic;

///## Ramification polynomials and polygons
///
/// In this package, if $f(x)$ is an Eisenstein polynomial with a root $\pi$, then we define the *ramification polynomial of $f$* to be $f(x+\pi)$ and the *ramification polygon of $f$* to be the Newton polygon of this. Observe that since $f(\pi)=0$ then the ramification polygon has end vertices at 1 and $\deg f$.
/// 
/// If $L/K$ is totally ramified, then the *ramification polygon of $L/K$* is the ramification polygon of any Eisenstein polynomial defining the extension. If $L/U$ is totally ramified and $U/K$ is unramified then the *ramification polygon of $L/K$* is that of $L/U$ with an additional horizontal face from $((L:U),0)$ to $((L:K),0)$.
/// 
/// The Newton polygon is an invariant of an extension and describes the ramification breaks of the *Galois set* $\Gamma(L/K)$ of embeddings $L \hookrightarrow \bar{K}$. This generalizes ramification theory of Galois extensions, where the Galois set is equal to the Galois group.

intrinsic RamificationResidualPolynomials(f :: RngUPolElt_FldPadExact) -> []
  {The residual polynomials of the ramification polygon of f.}
  if not assigned f`ramification_residual_polynomials then
    f`ramification_residual_polynomials := [RamificationResidualPolynomial(f, face) : face in RamificationPolygon(f)];
  end if;
  return f`ramification_residual_polynomials;
end intrinsic;

intrinsic RamificationResidualPolynomial(f :: RngUPolElt_FldPadExact, face :: NwtnPgonFace) -> RngUPolElt
  {The residual polynomial of the given face of the ramification polygon of f.}
  require IsEisenstein(f): "f must be Eisenstein";
  if not assigned f`ramification_residual_polynomial then
    f`ramification_residual_polynomial := AssociativeArray();
  end if;
  ok, r := IsDefined(f`ramification_residual_polynomial, face);
  if not ok then
    F := BaseRing(f);
    FF, FtoFF := ResidueClassField(F);
    eF := AbsoluteRamificationDegree(F);
    d := Degree(f);
    p := Prime(F);
    v0, v1 := Explode(EndVertices(face));
    x0 := Z ! v0[1];
    y0 := Z ! v0[2];
    x1 := Z ! v1[1];
    y1 := Z ! v1[2];
    assert x0 ge 1;
    assert x1 gt x0;
    assert x1 le d;
    slope := (y1 - y0) / (x1 - x0);
    h := Numerator(-slope);
    e := Denominator(-slope);
    assert IsPowerOf(x0, p);
    ok, w0 := IsDivisibleBy(x1, x0);
    assert ok;
    if not IsDivisibleBy(w0, p) then
      assert x1 eq d;
      tame := true;
    else
      assert IsPowerOf(x1, p);
      tame := false;
    end if;
    coeffs := [FF|];
    for j in [x0..x1 by e] do
      v := Z ! (y0 + (j-x0)*slope);
      i := j + (v mod d);
      if i le d then
        c := Binomial(i, j) * Coefficient(f, i);
        tgt := Z ! ((v - i + j) / d);
        coeff := ResidueClass(ShiftValuation(c, -tgt));
      else
        coeff := 0;
      end if;
      assert coeff ne 0 or (j gt x0 and j lt x1);
      Append(~coeffs, coeff);
    end for;
    r := Polynomial(coeffs);
    assert Degree(r) eq (x1-x0)/e;
    f`ramification_residual_polynomial[face] := r;
  end if;
  return r;
end intrinsic;

intrinsic RamificationPolynomial(L :: FldPadExact) -> RngUPolElt_FldPadExact
  {The ramification polynomial of L with respect to its defining polynomial.}
  if not assigned L`ramification_polynomial then
    require L`type eq EISEN: "L must be totally ramified over its base field";
    f := DefiningPolynomial(L);
    assert IsEisenstein(f);
    pi := UniformizingElement(L);
    d := Degree(f);
    cs := [L| c : c in Coefficients(f)];
    pipwrs := [pi^n : n in [0..d]];
    L`ramification_polynomial := Polynomial([L| j eq 0 select 0 else &+[&*[L| Binomial(i,j), cs[i+1], pipwrs[i-j+1]] : i in [j..d]] : j in [0..d]]);
  end if;
  return L`ramification_polynomial;
end intrinsic;

function factorialValuation(n, p)
  assert p gt 0;
  assert n ge 0;
  // v_p(n!)
  v := 0;
  q := p;
  while q le n do
    v +:= n div q;
    q *:= p;
  end while;
  return v;
end function;

function binomialValuation(n, k, p)
  return factorialValuation(n, p) - factorialValuation(k, p) - factorialValuation(n - k, p);
end function;

intrinsic RamificationPolygon(f :: RngUPolElt_FldPadExact) -> NwtnPgon
  {The ramification polygon of the extension defined by f.}
  if not assigned f`ramification_polygon then
    if IsEisenstein(f) then
      // the newton polygon of r(x) where
      // v(r_j) = min[j<=i<=d] d*v_K((i choose j)*f_i)+(i-j)
      d := Degree(f);
      K := BaseRing(f);
      e := AbsoluteRamificationDegree(K);
      p := Prime(K);
      // we deduce that v(r_j) <= d*v_K((d choose j))+(d-j)
      // and hence we need to known v_K(f_i) <? v_K((d choose j)) - v_K((i choose j)) + 1-i/d
      aprs := [0] cat [Max([Ceiling(e*(binomialValuation(d,j,p) - binomialValuation(i,j,p)) + 1 - i/d) : j in [1..i]]) : i in [1..d]];
      IncreaseAbsolutePrecision(f, aprs);
      // now compute
      vfs := [Valuation(c) : c in Coefficients(f`approximation)[2..d+1]];
      vrs := [Min([d*e*binomialValuation(i,j,p)+d*vfs[i]+(i-j) : i in [j..d] | vfs[i] lt OO]) : j in [1..d]];
      f`ramification_polygon := NewtonPolygon([<j, vrs[j]> : j in [1..d]] : Faces:="Lower");
    elif IsInertial(f) then
      d := Degree(f);
      f`ramification_polygon := NewtonPolygon([<1,0>, <d,0>] : Faces:="Lower");
    else
      error "only implemented for inertial or Eisenstein polynomials";
    end if;
  end if;
  return f`ramification_polygon;
end intrinsic;

/// The ramification polygon of `E` over its base field or `F`.
intrinsic RamificationPolygon(E :: FldPadExact) -> NwtnPgon
  {The ramification polygon of F over its base field.}
  return RamificationPolygon(DefiningPolynomial(E));
end intrinsic;

///ditto
intrinsic RamificationPolygon(E :: FldPadExact, F :: FldPadExact) -> NwtnPgon
  {The ramification polygon of E/F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return RamificationPolygon(x);
end intrinsic;

///hide
intrinsic RamificationPolygon(x :: ExtDataFldPadExact) -> NwtnPgon
  {The ramification polygon.}
  if not assigned x`ramification_polygon then
    d := Degree(x);
    rp0 := RamificationPolygon(TransitionFunction(x));
    rp := NewtonPolygon(Vertices(rp0) cat [<d,0>] : Faces:="Lower");
    x`ramification_polygon := rp;
  end if;
  return x`ramification_polygon;
end intrinsic;

///## Hasse-Herbrand transition function

///### Creation

function hhtf_from_ramification_polygon(rp, d)
  assert Vertices(rp)[1][1] eq 1;
  assert LAST(Vertices(rp))[1] eq d;
  U := [<Q!0, Q!0>];
  for face in Reverse(Faces(rp)) do
    v1 := -(y1-y0)/(x1-x0) where x0,y0:=Explode(xy0) where x1,y1:=Explode(xy1) where xy0,xy1:=Explode(EndVertices(face));
    v0, u0 := Explode(LAST(U));
    e := Z ! EndVertices(face)[2][1];
    assert IsDivisibleBy(d, e);
    assert v1 gt v0;
    u1 := u0 + (e/d)*(v1-v0);
    assert u1 gt u0;
    Append(~U, <v1, u1>);
  end for;
  h := New(HassHerbTransFunc);
  h`degree := d;
  h`vertices := U;
  return h;
end function;

function hhtf_trivial()
  h := New(HassHerbTransFunc);
  h`degree := 1;
  h`vertices := [<Q!0,Q!0>];
  return h;
end function;

function hhtf_merge_tower(hs)
  h := New(HassHerbTransFunc);
  h`degree := 1;
  h`vertices := [<Q!0, Q!0>];
  for h1 in hs do
    h0 := h;
    vs := SORT({vu[1] : vu in h1`vertices} join {vu[1] @@ h1 : vu in h0`vertices});
    h := New(HassHerbTransFunc);
    h`degree := h1`degree * h0`degree;
    h`vertices := [<v, v@h1@h0> : v in vs];
  end for;
  return h;
end function;

/// The Hasse-Herbrand transition function of `E` over its base field or `F`.
intrinsic TransitionFunction(E :: FldPadExact) -> HassHerbTransFunc
  {The Hasse-Herbrand transition function of E over its base field.}
  if not assigned E`transition_function then
    case E`type:
    when PRIME:
      error "E must be an extension";
    when INERT:
      h := hhtf_trivial();
    when EISEN:
      rp := RamificationPolygon(E);
      d := Degree(E);
      h := hhtf_from_ramification_polygon(rp, d);
    else
      error "not implemented";
    end case;
    E`transition_function := h;
  end if;
  return E`transition_function;
end intrinsic;

///ditto
intrinsic TransitionFunction(E :: FldPadExact, F :: FldPadExact) -> HassHerbTransFunc
  {The Hasse-Herbrand transition function of E/F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return TransitionFunction(x);
end intrinsic;

///ditto
intrinsic TransitionFunction(E :: FldPad) -> HassHerbTransFunc
  {The Hasse-Herbrand transition function of E over its base field.}
  if IsPrimeField(E) then
    error "E must be an extension";
  end if;
  F := BaseField(E);
  if RamificationDegree(E) eq 1 then
    return hhtf_trivial();
  elif RamificationDegree(E) eq Degree(E) then
    f := DefiningPolynomial(E);
    alpha := F.1;
    r := Evaluate(f, Polynomial([alpha,1]));
    assert Degree(r) eq Degree(f);
    assert IsWeaklyZero(Coefficient(r, 0));
    rp := NewtonPolygon([<i, Valuation(Coefficient(r,i))> : i in [1..Degree(r)]] : Faces:="Lower");
    assert forall{v : v in Vertices(rp) | not IsWeaklyZero(Coefficient(r, Z ! v[1]))};
    d := Degree(E);
    return hhtf_from_ramification_polygon(rp, d);
  else
    error "not implemented";
  end if;
end intrinsic;

///ditto
intrinsic TransitionFunction(E :: FldPad, F :: FldPad) -> HassHerbTransFunc
  {The Hasse-Herbrand transition function of E/F.}
  twr := TOWER(E, F);
  return hhtf_merge_tower([TransitionFunction(t) : t in twr[2..#twr]]);
end intrinsic;

///hide
intrinsic TransitionFunction(x :: ExtDataFldPadExact) -> HassHerbTransFunc
  {The Hasse-Herbrand transition function.}
  if not assigned x`transition_function then
    case x`type:
    when COMPOUND:
      h := hhtf_merge_tower([TransitionFunction(y) : y in x`list]);
    when INERT, EISEN:
      h := TransitionFunction(x`top_field);
    when EMBED:
      // TODO: implement "division" of transition functions
      error "not implemented";
    else
      error "not implemented";
    end case;
    x`transition_function := h;
  end if;
  return x`transition_function;
end intrinsic;

///### Operations

///hide
intrinsic Print(h :: HassHerbTransFunc, lvl :: MonStgElt)
  {Prints h.}
    printf "Hasse-Herbrand transition function of an extension of ramification degree %o", h`degree;
end intrinsic;

intrinsic Degree(h :: HassHerbTransFunc) -> RngIntElt
  {The degree of the extension this is the transition function of.}
  return h`degree;
end intrinsic;

intrinsic Vertices(h :: HassHerbTransFunc) -> []
  {The vertices of the function.}
  return h`vertices;
end intrinsic;

intrinsic LowerBreaks(h :: HassHerbTransFunc) -> []
  {The lower breaks of h.}
  return [x[1] : x in Vertices(h)];
end intrinsic;

intrinsic UpperBreaks(h :: HassHerbTransFunc) -> []
  {The upper breaks of h.}
  return [x[2] : x in Vertices(h)];
end intrinsic;

intrinsic 'eq'(h1 :: HassHerbTransFunc, h2 :: HassHerbTransFunc) -> BoolElt
  {True if h1 and h2 are equal as field invariants, i.e. they define the same function.}
  return Degree(h1) eq Degree(h2) and Vertices(h1) eq Vertices(h2);
end intrinsic;

intrinsic '@'(v, h :: HassHerbTransFunc) -> .
  {Evaluates h at v.}
  if v le 0 then
    return (Q!1) * v;
  end if;
  for i in [2..#h`vertices] do
    v1, u1 := Explode(h`vertices[i]);
    if v le v1 then
      v0, u0 := Explode(h`vertices[i-1]);
      return u0 + (v-v0)*(u1-u0)/(v1-v0);
    end if;
  end for;
  v1, u1 := Explode(LAST(h`vertices));
  assert v gt v1;
  return u1 + (v-v1) / h`degree;
end intrinsic;

intrinsic '@@'(u, h :: HassHerbTransFunc) -> .
  {The inverse of h at u.}
  if u le 0 then
    return (Q!1) * u;
  end if;
  for i in [2..#h`vertices] do
    v1, u1 := Explode(h`vertices[i]);
    if u le u1 then
      v0, u0 := Explode(h`vertices[i-1]);
      return v0 + (u-u0)*(v1-v0)/(u1-u0);
    end if;
  end for;
  v1, u1 := Explode(LAST(h`vertices));
  assert u gt u1;
  return v1 + (u-u1) * h`degree;
end intrinsic;

intrinsic RamificationPolygon(h :: HassHerbTransFunc) -> NwtnPgon
  {The ramification polygon of a totally ramified extension with the given transition function.}
  if not assigned h`ramification_polygon then
    e := h`degree;
    vs := [<e, 0>];
    vus := Vertices(h);
    for i in [2..#vus] do
      slope := -vus[i][1];
      if i eq #vus then
        x1 := 1;
      else
        v0, u0 := Explode(vus[i]);
        v1, u1 := Explode(vus[i+1]);
        x1 := Z ! (e * (u1 - u0) / (v1 - v0));
      end if;
      x0, y0 := Explode(LAST(vs));
      assert x1 lt x0;
      y1 := Z ! (y0 + slope*(x1-x0));
      Append(~vs, <x1, y1>);
    end for;
    h`ramification_polygon := NewtonPolygon(vs : Faces:="Lower");
  end if;
  return h`ramification_polygon;
end intrinsic;


///## Primitivity and minimal polynomials

// to determine if x in E/F  (degree d) is primitive:
// a) if d=1, then yes
// b) if not primitive, then x satisfies a polynomial of degree less than d; in fact, it satisfies a polynomial of degree dividing d, so it satisfies a polynomial of degree at most d0 where d0 is the largest proper divisor of d
// c) take an approximation xx of x to some precision
// d) compute xx^i for 0<=i<=d0
// e) compute the F-coefficients of xx^i
// f) see if they are linearly dependent; specifically can we solve sum[i=0,d-1](a_i x^i) = x^d
// g) if this is not solvable, then x is primitive
// h) otherwise, x might be primitive
// 
// To get the minimal polynomial, do steps c-f with d instead of d0; this will be solvable and the answer will be unique.

function deep_eltseq(x, X)
  // assert Parent(x) eq X`top_field;
  case X`type:
  when COMPOUND:
    xs := [x];
    for Y in Reverse(X`list) do
      xs := &cat[deep_eltseq(x, Y) : x in xs];
    end for;
    return xs;
  when EISEN, INERT:
    return ELTSEQ(x);
  when EMBED:
    error "not implemented";
  else
    error "not implemented";
  end case;
end function;

function vector(x, X)
  return Vector(deep_eltseq(x, X));  
end function;

///hide
intrinsic IsDefinitelyPrimitive(x, X :: ExtDataFldPadExact : Strategy:="default") -> BoolElt, RngUPol_FldPadExact
  {True if x is a primitive element of X. If so, also returns the minimal polynomial.}
  ok, x := IsCoercible(X`top_field, x);
  require ok: "x must be coercible to the top field of X";
  d := Degree(X);
  // trivial case
  if d eq 1 then
    return true, Polynomial([X`base_field | -x, 1]);
  end if;
  // check if x is the generator
  if BaseField(X`top_field) eq X`base_field and x`id eq Generator(X`top_field)`id then
    return true, DefiningPolynomial(X`top_field);
  end if;
  // general case
  require not IsWeaklyZero(x : Strategy:=Strategy): "x is weakly zero";
  vx := Valuation(x);
  e := RamificationDegree(X);
  s := vx div e;
  y := ShiftValuation(X`base_field ! 1, s);
  x2 := x / y;
  assert not WZERO(x2);
  assert ValuationEq(x2, vx mod e);
  isKnown := false;
  // TODO: check if x is a uniformizer
  if IsTotallyRamified(X) and IsUniformizingElement(x) then
    isKnown := true;
    Strategy := 1+RamificationDegree(X);
  end if;
  // TODO: check if x is an inertial generator
  if IsUnramified(X)
  and Degree(MinimalPolynomial(ResidueClass(x), ResidueClassField(X`base_field)))
    eq InertiaDegree(X)
  then
    isKnown := true;
    Strategy := 1;
  end if;
  ok, _, m := ExactpAdics_ExecutePrecisionStrategy(function (pr)
    xx := Approximation(x2 : APr:=pr);
    M := Matrix([vector(xx^i, X) : i in [0..d-1]]);
    dM := Determinant(M);
    if WZERO(dM) then
      return false, _;
    end if;
    t := Valuation(dM);
    V := vector(-(xx^d), X);
    C := Solution(M, V);
    s := Min([Valuation(c) : c in ELTSEQ(C*M-V)]);
    xm := Polynomial(ELTSEQ(C) cat [1]);
    xm := CHANGE_APR(xm, [s-t : i in [0..d-1]] cat [1]);
    mkupdate := func<z | function (aprs)
      apr := Max(aprs);
      return Approximation_Lazy(x2 : APr:=e*(apr+t)) mod function (xx)
        M := Matrix([vector(xx^i, X) : i in [0..d-1]]);
        dM := Determinant(M);
        assert not WZERO(dM);
        assert Valuation(dM) eq t;
        V := vector(-(xx^d), X);
        C := Solution(M, V);
        s := Min([Valuation(c) : c in ELTSEQ(C*M-V)]);
        assert s ge apr+t;
        xm := Polynomial(ELTSEQ(C) cat [1]);
        xm := CHANGE_APR(xm, [s-t : i in [0..d]]);
        Update(z, xm);
        return true;
      end function;
    end function>;
    return true, PolynomialRing(X`base_field) ! <xm, mkupdate>;
  end function, Strategy);
  if ok then
    return true, ShiftSlope(m, -s : Pivot:=d);
  else
    assert not isKnown;
    return false, _;
  end if;
end intrinsic;

/// True if `x` is a primitive element for `E` (or `Parent(x)`) over `F`.
intrinsic IsDefinitelyPrimitive(x, E :: FldPadExact, F :: FldPadExact : Strategy:="default") -> BoolElt, RngUPolElt_FldPadExact
  {True if x is primitive for E/F, i.e. E=F(x). If so, also returns the minimal polynomial of x over F.}
  ok, X := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return IsDefinitelyPrimitive(x, X);
  isKnown := false;
end intrinsic;

///ditto
intrinsic IsDefinitelyPrimitive(x :: FldPadExactElt, F :: FldPadExact : Strategy:="default") -> BoolElt, RngUPolElt_FldPadExact
  {True if x in E is primitive for E/F, i.e. E=F(x). If so, also returns the minimal polynomial of x over F.}
  return IsDefinitelyPrimitive(x, Parent(x), F : Strategy:=Strategy);
end intrinsic;

///hide
intrinsic MinimalPolynomial(x, X :: ExtDataFldPadExact : Strategy:="default") -> RngUPolElt_FldPadExact
  {The minimal polynomial of x in X. Requires that x be primitive for X.}
  ok, m := IsDefinitelyPrimitive(x, X : Strategy:=Strategy);
  require ok: "cannot prove that x is primitive ";
  return m;
end intrinsic;

intrinsic MinimalPolynomial(x :: FldPadExactElt, F :: FldPadExact : Strategy:="default") -> RngUPolElt_FldPadExact
  {The minimal polynomial of x over F. Requires that x is a primitive element for E/F where E is the field containing x.}
  ok, m := IsDefinitelyPrimitive(x, F : Strategy:=Strategy);
  require ok: "cannot prove that x is primitive over F";
  return m;
end intrinsic;




///## Quotient ring

procedure assignQuotientRingNames(~R, F)
  case F`type:
  // when PRIME:
    // assert IsPrimeField(R);
  when INERT, EISEN:
    R0 := BaseRing(R);
    F0 := BaseField(F);
    assert Degree(R, R0) eq Degree(F);
    if assigned F`varname then
      AssignNames(~R, [F`varname cat "bar"]);
    end if;
    assignQuotientRingNames(~R0, F0);
  when PRIME:
    ;
  else
    error "not implemented";
  end case;
end procedure;

intrinsic Quotient(F :: FldPadExact, n :: RngIntElt) -> RngPadRes, Map
  {The integers Q of F mod pi^n, and the map F to Q.}
  require n ge 0: "n must be non-negative";
  xF := Approximation(F, n);
  xOF := Integers(xF);
  xQF := quo<xOF | ShiftValuation(xOF ! 1, n)>;
  assignQuotientRingNames(~xQF, F);
  function FtoQ(x)
    return CAST(xQF, Approximation(x : APr:=n));
  end function;
  function QtoF(y)
    x := New(FldPadExactElt);
    x`parent := F;
    x`id := NEXTID();
    x`approximation := CAST(xF, CAST(xOF, y));
    x`update := function (apr)
      error "cannot increase precision of images of p-adic quotients";
    end function;
    return x;
  end function;
  return xQF,
    map<F -> xQF | x :-> FtoQ(x), y :-> QtoF(y)>;
end intrinsic;

/// Quotient of the ring of integers of `F` by the elements on the right hand side.
intrinsic QuoConstructor(F :: FldPadExact, t :: .) -> RngPadRes, Map
  {The quotient of F by t.}
  require #t ge 1: "RHS must be nonempty";
  // coerce generators into F
  xs := [F|];
  for x in t do
    ok, y := IsCoercible(F, x);
    if not ok then
      error "RHS must all be coercible to F";
    end if;
    Append(~xs, y);
  end for;
  // get the valuation of the smallest element
  error if forall{x : x in xs | WZERO(x)}, "generators are all weakly zero";
  v := Min([WeakValuation(x) : x in xs | not WZERO(x)]);
  require v ge 0: "RHS must be integral";
  IncreaseAbsolutePrecisions([*<x, v> : x in xs*]);
  v := Min([WeakValuation(x) : x in xs | not WZERO(x)]);
  require v ge 0: "RHS must be integral";
  return Quotient(F, v);
end intrinsic;

///## Homomorphisms (incomplete feature)

///hide
intrinsic Print(h :: HomFldPadExact, lvl :: MonStgElt)
  {Prints h.}
  printf "%o fixing %o from %o to %o", IsInvertible(h) select "Isomorphism" else "Homomorphism", BaseField(h), DescribeExtension(h`xdomain : BaseName:="the base field"), ok select DescribeExtension(X : BaseName:="itself") else DescribeExtension(h`xcodomain : BaseName:="the base field") where ok,X := IsExtensionOf(Codomain(h), Domain(h));
end intrinsic;

intrinsic BaseField(h :: HomFldPadExact) -> FldPadExact
  {The base field of h, which is fixed.}
  return BaseField(h`xdomain);
end intrinsic;

intrinsic Domain(h :: HomFldPadExact) -> FldPadExact
  {The domain of h.}
  return TopField(h`xdomain);
end intrinsic;

intrinsic Codomain(h :: HomFldPadExact) -> FldPadExact
  {The codomain of h.}
  return TopField(h`xcodomain);
end intrinsic;

intrinsic '@'(x, h :: HomFldPadExact) -> FldPadExactElt
  {Applies the map.}
  ok, x := IsCoercible(Domain(h), x);
  require ok: "Argument 1 must be coercible into domain of argument 2";
  terms := [<x, [Codomain(h)|]>];
  Xs := Reverse(Flatten(h`xdomain)`list);
  imgs := h`generator_images;
  // get cached basis images
  if not assigned h`basis_images then
    bs := [[Codomain(h)|]];
    for i in [1..#Xs] do
      assert i le #imgs;
      X := Xs[i];
      img := imgs[i];
      case Type(img):
      when FldPadExactElt:
        assert Parent(img) eq Codomain(h);
        case X`type:
        when INERT, EISEN:
          bs := [Append(b, img^i) : i in [0..Degree(X)-1], b in bs];
        else
          error "not implemented for this type of extension";
        end case;
      when UserProgram:
        assert i eq #imgs;
        break;
      else
        assert false;
      end case;
    end for;
    h`basis_images := [&*b : b in bs];
  end if;
  bs := h`basis_images;
  // get coefficients
  cs := [x];
  for i in [1..#Xs] do
    assert i le #imgs;
    X := Xs[i];
    img := imgs[i];
    case Type(img):
    when FldPadExactElt:
      case X`type:
      when INERT, EISEN:
        cs := &cat[Eltseq(c) : c in cs];
      else
        error "not implemented for this type of extension";
      end case;
    when UserProgram:
      assert i eq #imgs;
      cs := [img(c) : c in cs];
      break;
    end case;
  end for;
  // compute
  assert #cs eq #bs;
  return &+[bs[i] * cs[i] : i in [1..#cs]];
end intrinsic;

intrinsic IsInvertible(h :: HomFldPadExact) -> BoolElt, HomFldPadExact
  {True if h has an inverse, and the inverse.}
  if assigned h`inverse then
    return true, h`inverse;
  else
    return false, _;
  end if;
end intrinsic;

intrinsic Inverse(h :: HomFldPadExact) -> HomFldPadExact
  {The inverse of h.}
  ok, i := IsInvertible(h);
  require ok: "Argument 1 must be invertible";
  return i;
end intrinsic;

intrinsic '@@'(x, h :: HomFldPadExact) -> FldPadExactElt
  {Applies the inverse map.}
  ok, i := IsInvertible(h);
  require ok: "Argument 1 must be invertible";
  return x @ i;
end intrinsic;

intrinsic TrivialEmbedding(X :: ExtDataFldPadExact) -> HomFldPadExact
  {The trivial embedding of BaseField(X) into TopField(X).}
  h := New(HomFldPadExact);
  E := TopField(X);
  F := BaseField(X);
  h`xdomain := F / F;
  h`xcodomain := X;
  h`generator_images := [* func<x | E ! x> *];
  if E eq F then
    h`inverse := h;
  end if;
  return h;
end intrinsic;

intrinsic TrivialEmbedding(F :: FldPadExactElt, E :: FldPadExactElt) -> HomFldPadExact
  {The trivial embedding of F into E.}
  return TrivialEmbedding(E/F);
end intrinsic;

intrinsic '*'(h1 :: HomFldPadExact, h2 :: HomFldPadExact) -> HomFldPadExact
  {The composition x @ (h1 * h2) = x @ h1 @ h2.}
  D1 := Domain(h1);
  C1 := Codomain(h1);
  B1 := BaseField(h1);
  D1B1 := h1`xdomain;
  C1B1 := h1`xcodomain;
  D2 := Domain(h2);
  C2 := Codomain(h2);
  B2 := BaseField(h2);
  D2B2 := h2`xdomain;
  C2B2 := h2`xcodomain;
  ok, D2C1 := IsExtensionOf(D2, C1);
  require ok: "Domain of argument 2 must be an extension of codomain of argument 1";
  // compute the domain, codomain and base field
  D := D1;
  C := C2;
  ok, B1B2 := IsExtensionOf(B1, B2);
  if ok then
    B := B2;
    DB := D1B1/B1B2;
    CB := C2B2;
  else
    ok, B2B1 := IsExtensionOf(B2, B1);
    if ok then
      B := B1;
      DB := D1B1;
      CB := C2B2/B2B1;
    else
      B := PrimeField(B1);
      DB := D1B1/B;
      CB := C2B2/B;
    end if;
  end if;
  // compute generator images
  imgs := [**];
  imgs1 := h1`generator_images;
  Xs := Reverse(Flatten(DB)`list);
  for i in [1..#Xs] do
    X := Xs[i];
    if i le #imgs1 then
      img1 := imgs1[i];
      case Type(img1):
      when FldPadExactElt:
        assert Parent(img1) eq C1;
        Append(~imgs, img1 @ h2);
      when UserProgram:
        Append(~imgs, func<x | img1(x)@h2>);
        break;
      end case;
    else
      case X`type:
      when INERT, EISEN:
        Append(~imgs, Generator(TopField(X)) @ h2);
      else
        error "not implemented for this type of extension";
      end case;
    end if;
  end for;
  // compute the map
  h := New(HomFldPadExact);
  h`xdomain := DB;
  h`xcodomain := CB;
  h`generator_images := imgs;
  return h;
end intrinsic;

intrinsic Embeddings(X :: ExtDataFldPadExact, h :: HomFldPadExact) -> []
  {The embeddings of TopField(X) into Codomain(h) extending h:BaseField(X)->Codomain(h).}
  require BaseField(X) eq Domain(h): "Base field of argument 1 must equal domain of argument 2";
  case X`type:
  when COMPOUND:
    hs := [h];
    for X0 in X`list do
      hs := &cat[Universe([[h]]) | Embeddings(X0, h) : h in hs];
    end for;
    return hs;
  when EISEN, INERT:
    f := DefiningPolynomial(TopField(X));
    hf := Polynomial([c@h : c in Coefficients(f)]);
    hs := [];
    // TODO: what strategy to give to Roots?
    for r in Roots(hf) do
      h1 := New(HomFldPadExact);
      h1`xdomain := X / h`xdomain;
      h1`xcodomain := h`xcodomain;
      h1`generator_images := [* r[1] *] cat [* img : img in h`generator_images *];
      Append(~hs, h1);
    end for;
    return hs;
  else
    error "not implemented for this type of extension";
  end case;
end intrinsic;

intrinsic Embeddings(X1 :: ExtDataFldPadExact, X2 :: ExtDataFldPadExact, h0 :: HomFldPadExact) -> []
  {The embeddings of TopField(X1) into TopField(X2) extending h0:BaseField(X1)->BaseField(X2).}
  require BaseField(X1) eq Domain(h0): "Base field of argument 1 must equal domain of argument 3";
  require BaseField(X2) eq Codomain(h0): "Base field of argument 2 must equal codomain of argument 3";
  return Embeddings(X1, h0 * TrivialEmbedding(X2));
end intrinsic;

intrinsic Embeddings(X1 :: ExtDataFldPadExact, X2 :: ExtDataFldPadExact) -> []
  {The embeddings of TopField(X1) into TopField(X2) fixing BaseField(X1)=BaseField(X2).}
  require BaseField(X1) eq BaseField(X2): "Base field of argument 1 must equal base field of argument 2";
  return Embeddings(X1, TrivialEmbedding(X2));
end intrinsic;



///## Temporary field (incomplete feature)

intrinsic Temporary(F :: FldPadExact) -> TmpFldPadExact
  {The temporary elements of F.}
  if not assigned F`temporary then
    T := New(TmpFldPadExact);
    T`field := F;
    F`temporary := T;
  end if;
  return F`temporary;
end intrinsic;

intrinsic Temporary(x :: FldPadExactElt) -> TmpFldPadExactElt
  {A temporary representation of x.}
  if not assigned x`temporary then
    t := New(TmpFldPadExactElt);
    t`parent := Temporary(Parent(x));
    t`get_approximation := func<apr | Approximation_Lazy(x : APr:=apr)>;
    t`weak_valuation := WeakValuation(x);
    t`absolute_precision := AbsolutePrecision(x);
    if not WZERO(x) or IsDefinitelyZero(x) then
      t`valuation := WVAL(x);
    end if;
    x`temporary := t;
  end if;
  return x`temporary;
end intrinsic;

intrinsic Parent(t :: TmpFldPadExactElt) -> TmpFldPadExact
  {The parent of t.}
  return t`parent;
end intrinsic;

intrinsic Print(T :: TmpFldPadExact, lvl :: MonStgElt)
  {Print T.}
  case lvl:
  when "Magma":
    printf "Temporary(%m)", T`field;
  else
    printf "Temporary elements of %O", T`field, lvl;
  end case;
end intrinsic;

intrinsic Print(t :: TmpFldPadExactElt, lvl :: MonStgElt)
  {Print t.}
  printf "Temporary %O", Evaluate(t), lvl;
end intrinsic;

intrinsic Evaluate(t :: TmpFldPadExactElt) -> FldPadExactElt
  {Returns a permanent version of t.}
  T := Parent(t);
  K := T`field;
  wv := t`weak_valuation;
  get := t`get_approximation;
  init := Evaluate(t`get_approximation(t`absolute_precision));
  assert WZERO(init) or (Valuation(init) ge wv);
  mkupdate := func<z | function (apr)
    return get(apr) mod function (xz)
      assert WZERO(xz) or VAL(xz) ge wv;
      Update(z, xz);
      return true;
    end function;
  end function>;
  return K ! <init, mkupdate>;
end intrinsic;

intrinsic WeakValuation(t :: TmpFldPadExactElt) -> RngIntElt
  {A lower bound on the valuation of t.}
  return t`weak_valuation;
end intrinsic;

intrinsic AbsolutePrecision(t :: TmpFldPadExactElt) -> RngIntElt
  {The absolute precision to which a permanent version of t will be made.}
  return t`absolute_precision;
end intrinsic;

intrinsic '&+'(ts :: [TmpFldPadExactElt]) -> TmpFldPadExactElt
  {Addition.}
  T := Universe(ts);
  if #ts eq 0 then
    return T ! 0;
  elif #ts eq 1 then
    return ts[1];
  else
    t := New(TmpFldPadExactElt);
    t`parent := T;
    t`weak_valuation := Min([t`weak_valuation : t in ts]);
    t`absolute_precision := Min([t`absolute_precision : t in ts]);
    t`get_approximation := function (apr)
      return &cat[t`get_approximation(apr) : t in ts] mod function (xts)
        return &+xts;
      end function;
    end function;
    return t;
  end if;
end intrinsic;

intrinsic '+'(s :: TmpFldPadExactElt, t :: TmpFldPadExactElt) -> TmpFldPadExactElt
  {"}
  ok, T := ExistsCoveringStructure(Parent(s), Parent(t));
  require ok: "s and t must come from a common field";
  return &+[T|s,t];
end intrinsic;

intrinsic BaseField(T :: TmpFldPadExactElt) -> TmpFldPadExactElt
  {The base field of T.}
  return Temporary(BaseField(T`field));
end intrinsic;

intrinsic ExistsCoveringStructure(S :: TmpFldPadExact, T :: TmpFldPadExact) -> BoolElt, .
  {True if there is a structure containing both S and T.}
  if S eq T then
    return S;
  end if;
  ok, F := ExistsCoveringStructure(S`field, T`field);
  if ok then
    return true, Temporary(F);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic ExistsCoveringStructure(S :: TmpFldPadExact, T :: Str) -> BoolElt, .
  {"}
  ok, F := ExistsCoveringStructure(S`field, T);
  if ok then
    return true, Temporary(F);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic ExistsCoveringStructure(S :: Str, T :: TmpFldPadExact) -> BoolElt, .
  {"}
  return ExistsCoveringStructure(T, S);
end intrinsic;

intrinsic 'eq'(S :: TmpFldPadExact, T :: TmpFldPadExact) -> BoolElt
  {Equality.}
  return S`field eq T`field;
end intrinsic;

intrinsic IsCoercible(T :: TmpFldPadExact, X) -> BoolElt, .
  {True if X is coercible to T, and the coerced element.}
  return false, "not coercible";
end intrinsic;

function cast_up_extension(X, x)
  assert x in X`base_field`approximation_field;
  case X`type:
  when COMPOUND:
    for Y in X`list do
      x := cast_up_extension(Y, x);
    end for;
    return x;
  when EISEN, INERT:
    return CAST(X`top_field`approximation_field, [x]);
  when EMBED:
    error "not implemented";
  else
    error "not implemented";
  end case;
end function;

intrinsic IsCoercible(T :: TmpFldPadExact, X :: TmpFldPadExactElt) -> BoolElt, .
  {"}
  if Parent(X) eq T then
    return true, X;
  end if;
  ok, ex := IsExtensionOf(T`field, X`parent`field);
  if ok then
    e := RamificationDegree(ex);
    Y := New(TmpFldPadExactElt);
    Y`parent := T;
    Y`weak_valuation := e * X`weak_valuation;
    Y`absolute_precision := e * X`absolute_precision;
    if assigned X`valuation then
      Y`valuation := e * X`valuation;
    end if;
    Y`get_approximation := function (apr)
      return X`get_approximation(Ceiling(apr / e)) mod function (xx)
        return cast_up_extension(ex, xx);
      end function;
    end function;
    return true, Y;
  end if;
  return false, "not coercible";
end intrinsic;

function tmpFromRational(T, X)
  Y := New(TmpFldPadExactElt);
  Y`parent := T;
  if X eq 0 then
    Y`weak_valuation := OO;
    Y`absolute_precision := OO;
    Y`get_approximation := func<apr | T`field`approximation_field ! 0>;
    Y`valuation := OO;
  else
    e := AbsoluteRamificationDegree(T`field);
    p := Prime(T`field);
    v := Valuation(X, p) * e;
    Y`weak_valuation := v;
    Y`absolute_precision := v + 1;
    Y`valuation := v;
    Y`get_approximation := function (apr)
      pr := Max(apr - v, 1);
      return Approximation_Lazy(T`field, pr) mod function (xT)
        return CAST(xT, X);
      end function;
    end function;
  end if;
  return Y;
end function;

intrinsic IsCoercible(T :: TmpFldPadExact, X :: RngIntElt) -> BoolElt, .
  {"}
  return true, tmpFromRational(T, X);
end intrinsic;

intrinsic IsCoercible(T :: TmpFldPadExact, X :: FldRatElt) -> BoolElt, .
  {"}
  return true, tmpFromRational(T, X);
end intrinsic;

intrinsic Eltseq(x :: TmpFldPadExactElt) -> []
  {Eltseq.}
  return [Coefficient(x, i) : i in [0..Degree(x`parent`field)-1]];
end intrinsic;

intrinsic Coefficient(x :: TmpFldPadExactElt, i :: RngIntElt) -> TmpFldPadExactElt
  {Eltseq[i].}
  T := Parent(x);
  F := T`field;
  require i ge 0 and i lt Degree(F): "i out of range";
  y := New(TmpFldPadExactElt);
  y`parent := Temporary(BaseField(F));
  case F`type:
  when INERT:
    y`weak_valuation := x`weak_valuation;
    y`absolute_precision := x`absolute_precision;
    y`get_approximation := func<apr | x`get_approximation(apr) mod func<xx | ELTSEQ(xx)[i+1]>>;
  when EISEN:
    e := RamificationDegree(F);
    y`weak_valuation := Ceiling((x`weak_valuation - i + 1) / e);
    y`absolute_precision := Ceiling((x`absolute_precision - i + 1) / e);
    y`get_approximation := func<apr | x`get_approximation(apr*e+i-1) mod func<xx | ELTSEQ(xx)[i+1]>>;
  when EMBED:
    error "not implemented";
  else
    error "not implemented";
  end case;
  return y;
end intrinsic;


///## Integer ring (incomplete feature)


issqfree := IsSquarefree;

intrinsic Integers(F :: FldPadExact, v :: RngIntElt) -> RngPadExact
  {The ring of elements of F of valuation at least v.}
  if v eq 0 and assigned F`integers then
    return F`integers;
  end if;
  R := New(RngPadExact);
  R`id := NEXTID();
  R`radius := v;
  R`field_of_fractions := F;
  if v eq 0 then
    F`integers := R;
  end if;
  return R;
end intrinsic;

intrinsic Integers(F :: FldPadExact) -> RngPadExact
  {The ring of integers of F.}
  return Integers(F, 0);
end intrinsic;

intrinsic FieldOfFractions(F :: FldPadExact) -> FldPadExact
  {The field of fractions.}
  return F;
end intrinsic;

intrinsic FieldOfFractions(R :: RngPadExact) -> FldPadExact
  {"}
  return R`field_of_fractions;
end intrinsic;

///hide
intrinsic Print(R :: RngPadExact, lvl :: MonStgElt)
  {Prints R.}
  case lvl:
  when "Magma":
    printf "Integers(%m, %m)", R`field_of_fractions, R`radius;
  else
    if R`radius eq 0 then
      printf "Ring of integers of %O", R`field_of_fractions, lvl;
    else
      printf "Ring of elements of valuation at least %O of %O", R`radius, lvl, R`field_of_fractions, lvl;
    end if;
  end case;
end intrinsic;

intrinsic 'eq'(R :: RngPadExact, S :: RngPadExact) -> BoolElt
  {Equality.}
  return (R`field_of_fractions eq S`field_of_fractions) and (R`radius eq S`radius);
end intrinsic;

intrinsic IsCoercible(R :: RngPadExact, X) -> BoolElt, .
  {True if X is coercible into R and the coerced element.}
  ok, x := IsCoercible(FieldOfFractions(R), X);
  if ok then
    return IsCoercible(R, x);
  end if;
  return false, "not coercible";
end intrinsic;

intrinsic IsCoercible(R :: RngPadExact, X :: FldPadExactElt) -> BoolElt, .
  {"}
  ok, x := IsCoercible(FieldOfFractions(R), X);
  if ok then
    if ValuationGe(x, R`radius) then
      y := New(RngPadExactElt);
      y`parent := R;
      y`field_element := x;
      y`id := NEXTID();
      return true, y;
    else
      return false, "valuation too small";
    end if;
  end if;
  return false, "not coercible";
end intrinsic;

intrinsic IsCoercible(R :: RngPadExact, X :: RngPadExactElt) -> BoolElt, .
  {"}
  if Parent(X) eq R then
    return true, X;
  else
    return IsCoercible(R, X`field_element);
  end if;
end intrinsic;

intrinsic Parent(x :: RngPadExactElt) -> RngPadExact
  {Parent of x.}
  return x`parent;
end intrinsic;

intrinsic Print(x :: RngPadExactElt, lvl :: MonStgElt)
  {Print.}
  Print(x`field_element, lvl);
end intrinsic;

intrinsic Random(R :: RngPadExact) -> RngPadExactElt
  {A random element of R.}
  return CAST(R, Random(FieldOfFractions(R), R`radius));
end intrinsic;

intrinsic Format(x :: FldPadExactElt : APr := AbsolutePrecision(x) meet (WeakValuation(x) + 1)) -> MonStgElt
  {Returns a string representation of x.}
  ok, APr := IsValidAbsolutePrecision(x, APr);
  require ok: "APr: " cat APr;
  IncreaseAbsolutePrecision(x, APr);
  return Sprintf("%o", CHANGE_APR(x`approximation, APr));
end intrinsic;

intrinsic Format(f :: RngUPolElt_FldPadExact : APr := AbsolutePrecision(f) meet (WeakValuation(f) + 1)) -> MonStgElt
  {Returns a string representation of f.}
  ok, APr := IsValidAbsolutePrecision(f, APr);
  require ok: "APr: " cat APr;
  IncreaseAbsolutePrecision(f, APr);
  // renewEltApproximation_poly(f);
  return Sprintf("%o", CHANGE_APR(f`approximation, APr));
end intrinsic;

intrinsic Random(R :: RngUPol_FldPadExact, d :: RngIntElt : Eisenstein:=false, Inertial:=false, Monic:=false, Irreducible:=false) -> RngUPolElt_FldPadExact
  {A random element of R of the given degree.}
  K := BaseRing(R);
  Monic or:= Eisenstein or Inertial;
  error if Monic and d lt 0, "Monic polynomials have degree at least 0";
  repeat
    ok := true;
    if Eisenstein then
      require d ge 1: "Eisenstein polynomials have degree at least 1";
      f := CAST(R, [K|
        (i eq 0) select
          RandomUnit(K,1)
        else (i eq d) select
          Monic select
            1
          else
            RandomUnit(K)
        else
          Random(K,1)
        : i in [0..d]
      ]);
    elif Inertial then
      repeat
        f := CAST(R, [K|
          (i eq 0) select
            RandomUnit(K)
          else (i eq d) select
            Monic select
              1
            else
              RandomUnit(K)
          else
            RandomInteger(K)
          : i in [0..d]
        ]);
      until IsInertial(f);
    else
      f := CAST(R, [K| (i eq d and Monic) select 1 else RandomInteger(K) : i in [0..d]]);
      if Irreducible then
        ok and:= IsIrreducible(f);
      end if;
    end if;
  until ok;
  return f;
end intrinsic;


///## Approximation
/// Intrinsics to do with the current approximation of a p-adic number.

intrinsic SetBaselineValuation(x :: FldPadExactElt, n)
  {Sets the baseline valuation.}
  x`baseline_valuation := n;
end intrinsic;

intrinsic BaselineValuation(x :: FldPadExactElt) -> RngIntElt
  {The baseline valuation.}
  return x`baseline_valuation;
end intrinsic;

intrinsic BaselinePrecision(x :: FldPadExactElt) -> Val_FldPadElt
  {The baseline precision of x: AbsolutePrecision(x) - BaselineValuation(x).}
  return APR(x) - BVAL(x);
end intrinsic;

intrinsic IncreaseBaselinePrecision(x :: FldPadExactElt, n)
  {Increases the baseline precision.}
  INC_APR(x, BVAL(x) + n);
end intrinsic;

intrinsic WeakApproximation(x :: FldPadExactElt) -> FldPadExactElt
  {An element weakly equal to x.}
  F := x`parent;
  if WZERO(x) then
    return F ! 0;
  else
    mkupdate := func<z | function (apr)
      pr := PrecisionRequired(z, apr);
      return IncreaseAbsolutePrecision_Lazy(F, pr) mod function (ig)
        Update(z, CHANGE_APR(z`approximation, apr));
        return true;
      end function;
    end function>;
    return F ! <x`approximation, mkupdate>;
  end if;
end intrinsic;

intrinsic PrecisionRequired(x :: FldPadExactElt, apr) -> RngIntElt
  {(A bound on) the precision required in the parent field of x to approximate x to the given absolute precision.}
  return Max(1, Ceiling(Value(apr - WVAL(x))));
end intrinsic;

intrinsic PrecisionRequired(f :: RngUPolElt_FldPadExact, apr) -> RngIntElt
  {The precision required to approximate f with the given parameters.}
  return Max(1, Ceiling(Value(&join(apr - WVAL(f)))));
end intrinsic;

intrinsic Approximation_Lazy(x :: FldPadExactElt, apr : Quick:=false, FixPr:=true) -> ExactpAdics_Gettr
  {An approximation to x.}
  ok, apr := IsValidAbsolutePrecisionDiff(x, apr);
  require ok: "Argument 2: " cat apr;
  pr := PrecisionRequired(x, apr);
  iapF := IncreaseAbsolutePrecision_Lazy(Parent(x), pr);
  return iapF mod function (ig)
    iap := IncreaseAbsolutePrecision_Lazy(x, apr);
    return iap mod function (ig)
      y := (Quick or apr`value eq OO) select x`approximation else CAP_APR(x`approximation, apr);
      if FixPr then
        y := ChangePrecision(Parent(y), Max(1, pr)) ! y;
      end if;
      assert apr le APR(y);
      return y;
    end function;
  end function;
end intrinsic;

intrinsic Approximation(x :: FldPadExactElt, apr : Quick:=false, FixPr:=true) -> FldPadElt
  {An approximation to x.}
  return Evaluate(Approximation_Lazy(x, apr : Quick:=Quick, FixPr:=FixPr));
end intrinsic;

intrinsic IncreaseAbsolutePrecision_Lazy(F :: FldPadExact, pr :: RngIntElt) -> ExactpAdics_Gettr
  {Getter which, when evaluated, the approximation field of F has at least precision pr.}
  pr := Max(pr, 1);
  case F`type:
  when PRIME:
    return ExactpAdics_ConstGetter(true);
  when INERT:
    return IncreaseAbsolutePrecision_Lazy(F`defining_polynomial, pr);
  when EISEN:
    d := Degree(F);
    // BUG: +2 because Magma has precision errors in Eisenstein extensions
    return IncreaseAbsolutePrecision_Lazy(F`defining_polynomial, Ceiling(pr / d) + 2*AbsoluteRamificationDegree(BaseField(F)));
  else
    error "not implemented";
  end case;
end intrinsic;

intrinsic Approximation_Lazy(F :: FldPadExact, pr) -> ExactpAdics_Gettr
  {The approximating field of F with default precision pr.}
  case Type(pr):
  when RngIntElt:
    ;
  when FldRatElt:
    ok, pr := IsCoercible(Z, pr);
    require ok: "pr must be an integer";
  when Val_FldPadElt:
    ok, pr := IsCoercible(Z, pr`value);
    require ok: "pr must be an integer";
  else
    error "pr must be an integer";
  end case;
  require pr gt 0: "pr must be positive";
  return IncreaseAbsolutePrecision_Lazy(F, pr) mod function (ig)
    xF := F`approximation_field;
    CHANGE_DPR(xF, pr);
    return xF;
  end function;
end intrinsic;

intrinsic Approximation(F :: FldPadExact, pr :: RngIntElt) -> FldPad
  {"}
  return Evaluate(Approximation_Lazy(F, pr));
end intrinsic;

intrinsic Approximation(F :: FldPadExact) -> FldPad
  {The approximating field.}
  return F`approximation_field;
end intrinsic;

intrinsic IncreaseAbsolutePrecision(x :: FldPadExactElt, n)
  {Increases the absolute precision of x to n.}
  satisfy_dep(x, n);
end intrinsic;

intrinsic IncreaseAbsolutePrecision_Lazy(x :: FldPadExactElt, n) -> ExactpAdics_Gettr
  {"}
  ok, n := IsValidAbsolutePrecisionDiff(x, n);
  if not ok then
    error "invalid n";
  end if;
  return ExactpAdics_Getter(false,
    procedure (~st, ~deps)
      deps := [*[*x,n*]*];
    end procedure,
    procedure (~st, ~val)
      assert n le APR(x);
      val := true;
    end procedure);
end intrinsic;

intrinsic AbsolutePrecision(x :: FldPadExactElt) -> RngIntElt
  {The absolute precision of x.}
  return Val_FldPadElt_Make(APR(x`approximation));
end intrinsic;

intrinsic Precision(x :: FldPadExactElt) -> RngIntElt
  {The precision of x.}
  return APR(x) - WVAL(x);
  // return Val_FldPadElt_Make(PR(x`approximation));
end intrinsic;

intrinsic WeakValuation(x :: FldPadExactElt) -> RngIntElt
  {The weak valuation of x.}
  return Val_FldPadElt_Make(VAL(x`approximation));
end intrinsic;

intrinsic Update(x :: FldPadExactElt, app :: FldPadElt)
  {Updates x to app.}
  F := x`parent;
  ok, app := IS_VALID_APPROX(F, app);
  require ok: "app is in the wrong field";
  FUDGE := GLOBAL_FUDGE(F);
  if FUDGE ne 0 then
    app := CHANGE_APR(app, APR(app) - FUDGE);
  end if;
  if UPDATE_CONSISTENCY_CHECK then
    require WEQ(x`approximation, app): "inconsistent";
  end if;
  if AbsolutePrecision(app) gt AbsolutePrecision(x`approximation) then
    x`approximation := app;
  end if;
  if assigned x`update_expecting_apr then
    assert APR(x) ge x`update_expecting_apr;
  end if;
end intrinsic;

intrinsic UpdateZero(x :: FldPadExactElt, apr :: RngIntElt)
  {Updates x to O(pi^apr).}
  Update(x, Zero(x`parent`approximation_field, apr));
end intrinsic;

intrinsic IsDefinitelyZero(x :: FldPadExactElt) -> BoolElt
  {True if x is precisely zero.}
  return WZERO(x) and AbsolutePrecision(x) eq OO;
end intrinsic;

/// True if `x` is zero up to precision.
/// 
///param Strategy:=false When not `false`, this is a strategy used to increase the precision of `x` until it is non-zero.
intrinsic IsWeaklyZero(x :: FldPadExactElt : Strategy:=false) -> BoolElt
  {True if x is zero up to precision.}
  if Strategy cmpeq false then
    return WZERO(x`approximation);
  elif not WZERO(x) then
    return false;
  else
    return not ExactpAdics_ExecutePrecisionStrategy(function (pr)
      IncreaseBaselinePrecision(x, pr);
      return not WZERO(x`approximation), _;
    end function, Strategy);
  end if;
end intrinsic;

intrinsic AreAllWeaklyZero(xs :: [FldPadExactElt] : Strategy:=false) -> BoolElt, RngIntElt
  {True if each `x` in `xs` is weakly zero. If not, returns the index of a nonzero element.}
  ok := exists(i){i : i in [1..#xs] | not WZERO(xs[i])};
  if ok then
    return false, i;
  elif Strategy cmpeq false then
    return true, _;
  else
    ok, _, i := ExactpAdics_ExecutePrecisionStrategy(function (pr)
      IncreaseAbsolutePrecisions([<x, BaselineValuation(x) + pr> : x in xs]);
      ok := exists(i){i : i in [1..#xs] | not WZERO(xs[i])};
      if ok then
        return true, i;
      else
        return false, _;
      end if;
    end function, Strategy);
    if ok then
      return false, i;
    else
      return true, _;
    end if;
  end if;
end intrinsic;

intrinsic IsWeaklyEqual(x :: FldPadExactElt, y :: FldPadExactElt : Strategy:=false) -> BoolElt
  {True if x and y are weakly equal up to precision.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must come from the same field";
  x := CAST(F, x);
  y := CAST(F, y);
  if Strategy cmpeq false then
    // renewEltApproximation(x);
    // renewEltApproximation(y);
    return WEQ(x`approximation, y`approximation);
  elif WEQ(x, y) then
    return not ExactpAdics_ExecutePrecisionStrategy(function (pr)
      IncreaseAbsolutePrecisions([*[*x, pr*],[*y, pr*]*]);
      // renewEltApproximation(x);
      // renewEltApproximation(y);
      return not WEQ(x`approximation, y`approximation), _;
    end function, Strategy);
  else
    return false;
  end if;
end intrinsic;

///## Internals

///### FldPadExactElt

intrinsic SetData(x :: FldPadExactElt, data)
  {Sets the custom data field.}
  x`data := data;
end intrinsic;

intrinsic GetData(x :: FldPadExactElt) -> .
  {Retrieves the custom data field.}
  return x`data;
end intrinsic;

///### ExtDataFldPadExact

intrinsic '/'(E :: FldPadExact, F :: FldPadExact) -> ExtDataFldPadExact
  {The extension E/F.}
  ok, X := IsExtensionOf(E, F);
  require ok: "E is not an extension of F";
  return X;
end intrinsic;

intrinsic '/'(E :: FldPadExact, X :: ExtDataFldPadExact) -> ExtDataFldPadExact
  {Extension E/X.}
  ok, X0 := IsExtensionOf(E, TopField(X));
  require ok: "E is not an extension of X";
  return X0 / X;
end intrinsic;

intrinsic '/'(X :: ExtDataFldPadExact, F :: FldPadExact) -> ExtDataFldPadExact
  {Extension X/F.}
  ok, X0 := IsExtensionOf(BaseField(X), F);
  require ok: "X is not an extension of F";
  return X / X0;
end intrinsic;

intrinsic '/'(X1 :: ExtDataFldPadExact, X2 :: ExtDataFldPadExact) -> ExtDataFldPadExact
  {Extension X1/X2.}
  if BaseField(X1) eq TopField(X2) then
    X := New(ExtDataFldPadExact);
    X`base_field := BaseField(X2);
    X`top_field := TopField(X1);
    X`type := COMPOUND;
    X`list := [X2, X1];
    return X;
  end if;
  ok, X3 := IsExtensionOf(BaseField(X1), TopField(X2));
  require ok: "Base field of argument 1 must be an extension of top field of argument 2";
  X := New(ExtDataFldPadExact);
  X`base_field := BaseField(X2);
  X`top_field := TopField(X1);
  X`type := COMPOUND;
  X`list := [X2, X3, X1];
  return X;
end intrinsic;

intrinsic Flatten(x :: ExtDataFldPadExact) -> ExtDataFldPadExact
  {Returns a version of x with type COMPOUND and all elements of x`list have type not COMPOUND.}
  if not assigned x`flatten then
    y := New(ExtDataFldPadExact);
    y`type := COMPOUND;
    case x`type:
    when COMPOUND:
      y`list := (#x`list eq 0) select [] else &cat[Flatten(z)`list : z in x`list];
    when EISEN, INERT, EMBED:
      y`list := [x];
    else
      error "not implemented";
    end case;
    y`top_field := x`top_field;
    y`base_field := x`base_field;
    x`flatten := y;
    y`flatten := y;
  end if;
  return x`flatten;
end intrinsic;

///hide
intrinsic Print(x :: ExtDataFldPadExact, lvl :: MonStgElt)
  {Prints x.}
  printf "Extension Data";
end intrinsic;

intrinsic TopField(x :: ExtDataFldPadExact) -> FldPadExact
  {The top field of x.}
  return x`top_field;
end intrinsic;

intrinsic BaseField(x :: ExtDataFldPadExact) -> FldPadExact
  {The base field of x.}
  return x`base_field;
end intrinsic;

///# Univariate polynomials
///toc

///## Creation of rings

intrinsic PolynomialRing(F :: FldPadExact) -> RngUPol_FldPadExact
  {The univariate polynomial ring over F.}
  if not assigned F`polynomial_ring then
    R := New(RngUPol_FldPadExact);
    R`id := NEXTID();
    R`base_ring := F;
    R`approximation_ring := PolynomialRing(F`approximation_field);
    F`polynomial_ring := R;
  end if;
  return F`polynomial_ring;
end intrinsic;

///## Ring basics

intrinsic BaseRing(R :: RngUPol_FldPadExact) -> FldPadExact
  {The base ring of R.}
  return R`base_ring;
end intrinsic;

intrinsic AssignNames(~R :: RngUPol_FldPadExact, names :: [MonStgElt])
  {Assigns the name of the variable of R.}
  require #names eq 1: "Argument 2 must have length 1";
  R`varname := names[1];
  AssignNames(~R`approximation_ring, names);
end intrinsic;

intrinsic Names(R :: RngUPol_FldPadExact) -> []
  {The names of R.}
  if assigned R`varname then
    return [R`varname];
  else
    return ["S.1"];
  end if;
end intrinsic;

intrinsic Name(R :: RngUPol_FldPadExact, i :: RngIntElt) -> RngUPolElt_FldPadExact
  {Gets the ith generator of R.}
  require i eq 1: "i must be 1";
  return Generator(R);
end intrinsic;

intrinsic '.'(R :: RngUPol_FldPadExact, i :: RngIntElt) -> RngUPolElt_FldPadExact
  {"}
  require i eq 1: "i must be 1";
  return Generator(R);
end intrinsic;

intrinsic Generator(R :: RngUPol_FldPadExact) -> RngUPolElt_FldPadExact
  {The generator of R.}
  if not assigned R`generator then
    R`generator := CAST(R, [0,1]);
  end if;
  return R`generator;
end intrinsic;

intrinsic 'eq'(R :: RngUPol_FldPadExact, S :: RngUPol_FldPadExact) -> BoolElt
  {Equality.}
  return R`id eq S`id;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( R :: RngUPol_FldPadExact
  , S :: RngUPol_FldPadExact
  ) -> BoolElt, .
  {True if there is a polynomial ring containing both R and S.}
  if R eq S then
    return true, R;
  end if;
  ok, F := ExistsCoveringStructure(BaseRing(R), BaseRing(S));
  if ok then
    if BaseRing(R) eq F then
      return true, R;
    elif BaseRing(S) eq F then
      return true, S;
    else
      return true, PolynomialRing(F);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( R :: RngUPol_FldPadExact
  , S :: RngUPol
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), BaseRing(S));
  if ok then
    if E eq BaseRing(R) then
      return true, PolynomialRing(E);
    else
      return true, PolynomialRing(E);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( S :: RngUPol
  , R :: RngUPol_FldPadExact
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), BaseRing(S));
  if ok then
    if E eq BaseRing(R) then
      return true, PolynomialRing(E);
    else
      return true, PolynomialRing(E);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( R :: RngUPol_FldPadExact
  , S :: Str
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), S);
  if ok then
    if E eq BaseRing(R) then
      return true, R;
    else
      return true, PolynomialRing(E);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( S :: Str
  , R :: RngUPol_FldPadExact
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), S);
  if ok then
    if E eq BaseRing(R) then
      return true, R;
    else
      return true, PolynomialRing(E);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( R :: RngUPol
  , S :: FldPadExact
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), S);
  if ok then
    return true, PolynomialRing(E);
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( S :: FldPadExact
  , R :: RngUPol
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), S);
  if ok then
    return true, PolynomialRing(E);
  end if;
  return false, _;
end intrinsic;

///## Creation of polynomials

///### From coefficients

intrinsic Polynomial(coeffs :: [FldPadExactElt]) -> RngUPolElt_FldPadExact
  {The polynomial with the given coefficients.}
  K := Universe(coeffs);
  R := PolynomialRing(K);
  return CAST(R, coeffs);
end intrinsic;

intrinsic Polynomial(K :: FldPadExact, coeffs :: []) -> RngUPolElt_FldPadExact
  {The polynomial over K with the given coefficients.}
  ok, coeffs := CanChangeUniverse(coeffs, K);
  require ok: "coeffs must be coercible to K";
  return CAST(PolynomialRing(K), coeffs);
end intrinsic;

///### Coercion

/// True if `X` is coercible to an element of `R`. If so, also returns the coerced element. Otherwise, also returns a string explaining why not.
/// 
/// Succeeds if either:
/// - `X` is an element of `R`
/// - `X` is coercible to the base ring of `R`
/// - `X` is a `RngUPol` or `RngUPol_FldPadExact` whose coefficients are coercible to the base ring of `R`
/// - `X` is a `RngUPol[FldPad]` coercible to the approximation ring of `R`
/// - `X` is a sequence of coefficients coercible to the base ring of `R`
intrinsic IsCoercible(R :: RngUPol_FldPadExact, X) -> BoolElt, .
  {True if X is coercible to an element of R, and the coerced element.}
  ok, x := IsCoercible(BaseRing(R), X);
  if ok then
    return true, CAST(R, [x]);
  end if;
  return false, "not coercible";
end intrinsic;

///hide-all
intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: RngUPolElt_FldPadExact) -> BoolElt, .
  {"}
  if Parent(X) eq R then
    return true, X;
  else
    return IsCoercible(R, WeakCoefficients(X));
  end if;
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: RngUPolElt) -> BoolElt, .
  {"}
  return IsCoercible(R, Coefficients(X));
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: RngUPolElt[FldPad]) -> BoolElt, .
  {"}
  ok, app := IS_VALID_APPROX(R, X);
  if ok then
    x := New(RngUPolElt_FldPadExact);
    x`id := NEXTID();
    x`parent := R;
    x`approximation := app;
    x`update := function (apr)
      error "cannot increase precision of approximate p-adics";
    end function;
    return true, x;
  end if;
  return IsCoercible(R, Coefficients(X));
end intrinsic;

function makePoly(R, init, mkupdate)
  f := New(RngUPolElt_FldPadExact);
  f`parent := R;
  FUDGE := GLOBAL_FUDGE(BaseRing(R));
  f`update := FUDGE eq 0 select u else func<apr | u(apr + FUDGE)> where u := mkupdate(f);
  f`id := NEXTID();
  case Type(init):
  when RngUPolElt:
    ok, init := IS_VALID_APPROX(R, init);
    if ok then
      f`approximation := init;
    else
      return false, "wrong field";
    end if;
  else
    return false, "bad init";
  end case;
  SetBaselineValuation(f, WeakValuation(f));
  return true, f;
end function;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: Tup) -> BoolElt, .
  {"}
  if #X eq 2 then
    return makePoly(R, X[1], X[2]);
  elif #X eq 3 then
    ok, g := makePoly(R, X[1], X[2]);
    if ok then
      SetData(g, X[3]);
      return true, g;
    else
      return false, g;
    end if;
  else
    return false, "not coercible";
  end if;
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: []) -> BoolElt, .
  {"}
  F := BaseRing(R);
  if CanChangeUniverse(X, F) then
    coeffs := [F | CAST(F, x) : x in X];
  else
    return false, "coefficients not coercible to base field";
  end if;
  while #coeffs gt 0 and IsDefinitelyZero(coeffs[#coeffs]) do
    Prune(~coeffs);
  end while;
  xR := Approximation(R, 1);
  init := xR ! [Approximation(x, APR(x) meet (WVAL(x)+1)) : x in coeffs];
  mkupdate := func<f | function (apr)
    return &cat[Approximation_Lazy(coeffs[i+1], apr(i)) : i in [0..WeakDegree(f)]]
    mod function (xcoeffs)
      Update(f, xR ! xcoeffs);
      return true;
    end function;
  end function>;
  f := R ! <init, mkupdate>;
  // f`weak_coefficients := coeffs;
  return true, f;
end intrinsic;

///hide-none

intrinsic CanChangeRing(f :: RngUPolElt_FldPadExact, K :: FldPadExact) -> BoolElt, RngUPolElt_FldPadExact
  {True if f can be coerced to a polynomial over K. If so, also returns the coerced polynomial.}
  if BaseRing(f) eq K then
    return true, f;
  else
    return IsCoercible(PolynomialRing(K), f);
  end if;
end intrinsic;

intrinsic CanChangeRing(f :: RngUPolElt, K :: FldPadExact) -> BoolElt, RngUPolElt_FldPadExact
  {"}
  return IsCoercible(PolynomialRing(K), f);
end intrinsic;

intrinsic ChangeRing(f, K) -> .
  {Change the ring of f to K.}
  ok, g := CanChangeRing(f, K);
  if ok then
    return g;
  else
    error "not coercible:", g;
  end if;
end intrinsic;

///## Polynomial basics

intrinsic BaseRing(f :: RngUPolElt_FldPadExact) -> FldPadExact
  {The base ring of f.}
  if not assigned f`base_ring then
    f`base_ring := BaseRing(Parent(f));
  end if;
  return f`base_ring;
end intrinsic;

intrinsic Parent(f :: RngUPolElt_FldPadExact) -> RngUPol_FldPadExact
  {The polynomial ring containing f.}
  return f`parent;
end intrinsic;

///### Degree

intrinsic Degree(f :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt
  {The degree of f.}
  if not assigned f`degree then
    d := WeakDegree(f);
    if d ge 0 and IsWeaklyZero(Coefficient(f, d) : Strategy:=Strategy) then
      error "leading coefficient is weakly zero";
    end if;
    f`degree := d;
  end if;
  return f`degree;
end intrinsic;

intrinsic WeakDegree(f :: RngUPolElt_FldPadExact) -> RngIntElt
  {The weak degree of f, the degree of its approximation.}
  return Degree(f`approximation);
end intrinsic;

///### Coefficients

intrinsic Coefficients(f :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt
  {The coefficients of f.}
  if not assigned f`coefficients then
    d := Degree(f : Strategy:=Strategy);
    f`coefficients := [Coefficient(f, i) : i in [0..d]];
  end if;
  return f`coefficients;
end intrinsic;

intrinsic WeakCoefficients(f :: RngUPolElt_FldPadExact) -> []
  {The coefficients of f, possibly including some leading zeros.}
  if not assigned f`weak_coefficients then
    f`weak_coefficients := [Coefficient(f, i) : i in [0..WeakDegree(f)]];
  end if;
  return f`weak_coefficients[1..WeakDegree(f)+1];
end intrinsic;

intrinsic LeadingCoefficient(f :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt
  {The leading coefficient of f.}
  if not assigned f`leading_coefficient then
    d := Degree(f : Strategy:=Strategy);
    f`leading_coefficient := Coefficient(f, d);
  end if;
  return f`leading_coefficient;
end intrinsic;

intrinsic WeakLeadingCoefficient(f :: RngUPolElt_FldPadExact) -> BoolElt
  {The leading weak coefficient of f.}
  return Coefficient(f, WeakDegree(f));
end intrinsic;

function _coefficient(f, i)
  R := Parent(f);
  F := BaseRing(R);
  init := Coefficient(f`approximation, i);
  mkupdate := func<z | function (apr)
    fapr := AbsolutePrecision(f);
    return IncreaseAbsolutePrecision_Lazy(f, [<i,apr>])
    mod function (ig)
      Update(z, Coefficient(f`approximation, i));
      return true;
    end function;
  end function>;
  return F ! <init, mkupdate>;
end function;

intrinsic Coefficient(f :: RngUPolElt_FldPadExact, i :: RngIntElt) -> []
  {The ith coefficient of f.}
  require i ge 0: "i must be non-negative";
  if assigned f`weak_coefficients then
    return (i+1 gt #f`weak_coefficients) select CAST(BaseRing(Parent(f), 0)) else f`weak_coefficients[i+1];
  end if;
  if i gt WeakDegree(f) then
    return CAST(BaseRing(Parent(f)), 0);
  end if;
  if not assigned f`coefficient then
    f`coefficient := [];
  end if;
  if IsDefined(f`coefficient, i+1) then
    c := f`coefficient[i+1];
  else
    c := _coefficient(f, i);
    f`coefficient[i+1] := c;
  end if;
  return c;
end intrinsic;

///### Valuation

intrinsic IsIntegral(f :: RngUPolElt_FldPadExact) -> RngUPolElt
  {True if each coefficient of `f` is integral.}
  if not assigned f`is_integral then
    // can we answer without increasing precision?
    if exists{c : c in Coefficients(f`approximation) | (not WZERO(c)) and Valuation(c) lt 0} then
      f`is_integral := false;
    else
      // now increase precision and check again
      IncreaseAbsolutePrecision(f, 0);
      f`is_integral := forall{c : c in Coefficients(f`approximation) | Valuation(c) ge 0};
    end if;
  end if;
  return f`is_integral;  
end intrinsic;

intrinsic MinValuation(f :: RngUPolElt_FldPadExact : Strategy:="default") -> RngIntElt
  {The smallest valuation of the coefficients of f.}
  if not assigned f`min_valuation then
    require not IsWeaklyZero(f : Strategy:=Strategy): "f is weakly zero";
    v := Min([Valuation(c) : i in [0..WeakDegree(f)] | not WZERO(c) where c:=Coefficient(f`approximation,i)]);
    IncreaseAbsolutePrecision(f, v+1);
    f`min_valuation := WeakMinValuation(f);
  end if;
  return f`min_valuation;
end intrinsic;

procedure assignValuationBelow_poly(f,n)
  if assigned f`valuation then
    ;
  elif IsDefinitelyZero(f) then
    f`valuation := Infinity();
  else
    IncreaseAbsolutePrecision(f, n);
    apr := AbsolutePrecision(f);
    assert apr ge n;
    v := Min([Valuation(c) : c in Coefficients(f`approximation)]);
    if v lt apr then
      f`valuation := v;
    end if;
  end if;
end procedure;

intrinsic ValuationEq(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is n.}
  assignValuationBelow_poly(f, n+1);
  return assigned f`valuation and f`valuation eq n;
end intrinsic;

intrinsic ValuationNe(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is not n.}
  return not ValuationEq(f, n);
end intrinsic;

intrinsic ValuationLe(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is at most n.}
  assignValuationBelow_poly(f, n+1);
  return assigned f`valuation and f`valuation le n;
end intrinsic;

intrinsic ValuationLt(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is less than n.}
  assignValuationBelow_poly(f, n);
  return assigned f`valuation and f`valuation lt n;
end intrinsic;

intrinsic ValuationGe(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is at least n.}
  return not ValuationLt(f, n);
end intrinsic;

intrinsic ValuationGt(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is greater than n.}
  return not ValuationLe(f, n);
end intrinsic;

///### Arithmetic

///hide
intrinsic '+'(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {Unary plus.}
  return f;
end intrinsic;

/// Negate, add, subtract, sum, multiply, product, power.
intrinsic '-'(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {Negation.}
  if not assigned f`negation then
    if IsDefinitelyZero(f) then
      f`negation := f;
    else
      R := Parent(f);
      init := -Approximation(f, CAPR(f));
      mkupdate := func<z | function (apr)
        return Approximation_Lazy(f, apr) mod function (xf)
          Update(z, -xf);
          return true;
        end function;
      end function>;
      f`negation := R ! <init, mkupdate>;
      f`negation`negation := f;
    end if;
  end if;
  return f`negation;
end intrinsic;

///ditto
intrinsic '+'(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {Addition.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must come from the same ring";
  return &+[R | f, g];
end intrinsic;

///hide
intrinsic '+'(f :: RngUPolElt_FldPadExact, g) -> .
  {"}
  return do_binop('+', f, g);
end intrinsic;

///hide
intrinsic '+'(f, g :: RngUPolElt_FldPadExact) -> .
  {"}
  return do_binop('+', f, g);
end intrinsic;

///ditto
intrinsic '-'(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {Subtraction.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be from the same ring";
  f := CAST(R, f);
  g := CAST(R, g);
  if IsDefinitelyZero(g) then
    return CAST(R, f);
  elif IsDefinitelyZero(f) then
    return CAST(R, -g);
  else
    init := Approximation(f, CAPR(f)) - Approximation(g, CAPR(g));
    mkupdate := func<z | function (apr)
      return [Approximation_Lazy(t, apr) : t in [f,g]]
      mod function (xf, xg)
        Update(z, xf-xg);
        return true;
      end function;
    end function>;
    return R ! <init, mkupdate>;
  end if;
end intrinsic;

///hide
intrinsic '-'(x :: RngUPolElt_FldPadExact, y) -> .
  {"}
  return do_binop('-', x, y);
end intrinsic;

///hide
intrinsic '-'(x, y :: RngUPolElt_FldPadExact) -> .
  {"}
  return do_binop('-', x, y);
end intrinsic;

///ditto
intrinsic '&+'(fs :: [RngUPolElt_FldPadExact]) -> RngUPolElt_FldPadExact
  {Summation.}
  R := Universe(fs);
  fs := [R | f : f in fs | not IsDefinitelyZero(f)];
  if #fs eq 0 then
    return CAST(R, 0);
  elif #fs eq 1 then
    return fs[1];
  else
    init := &+[Approximation(f, CAPR(f)) : f in fs];
    mkupdate := func<z | function (apr)
      return &cat[Approximation_Lazy(f, apr) : f in fs] mod function (xfs)
        Update(z, &+xfs);
        return true;
      end function;
    end function>;
    return R ! <init, mkupdate>;
  end if;
end intrinsic;

///ditto
intrinsic '*'(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {Multiplication.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must come from the same ring";
  f := R ! f;
  g := R ! g;
  K := BaseRing(R);
  df := WeakDegree(f);
  dg := WeakDegree(g);
  return R ! [K| &+[K| Coefficient(f,i)*Coefficient(g,k-i) : i in [Max(0,k-dg)..Min(k,df)]] : k in [0..df+dg]];
end intrinsic;

///hide
intrinsic '*'(x, y :: RngUPolElt_FldPadExact) -> .
  {"}
  return do_binop('*', x, y);
end intrinsic;

///hide
intrinsic '*'(x :: RngUPolElt_FldPadExact, y) -> .
  {"}
  return do_binop('*', x, y);
end intrinsic;

///ditto
intrinsic '&*'(fs :: [RngUPolElt_FldPadExact]) -> RngUPolElt_FldPadExact
  {Product.}
  R := Universe(fs);
  if exists{f : f in fs | IsDefinitelyZero(f)} then
    return CAST(R, 0);
  end if;
  if #fs eq 0 then
    return CAST(R, 1);
  elif #fs eq 1 then
    return fs[1];
  else

    // OLD VERSION: works, but uses a bad lower bound on the valuation for simplicity
    // init := &*[Approximation(f, CAPR(f)) : f in fs];
    // mkupdate := func<z | function (aprs)
    //   d := WeakDegree(z);
    //   apr := &join aprs;
    //   pr := apr - &+[WeakMinValuation(f) : f in fs];
    //   return &cat[Approximation_Lazy(f, WeakMinValuation(f)+pr) : f in fs]
    //   mod function (xfs)
    //     Update(z, &*xfs);
    //     return true;
    //   end function;
    // end function>;
    // return R ! <init, mkupdate>;
  end if;
end intrinsic;

///ditto
intrinsic '^'(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> RngUPolElt_FldPadExact
  {Powering.}
  require n ge 0: "Argument 2 must be at least 0";
  case n:
  when 0:
    return One(Parent(f));
  when 1:
    return f;
  else
    if not assigned f`powers then
      f`powers := [];
    end if;
    if not IsDefined(f`powers, n) then
      m := n div 2;
      f`powers[n] := f^m * f^(n-m);
    end if;
    return f`powers[n];
  end case;
end intrinsic;

/// Exact division.
///param Strategy Used to check that `g` is nonzero.
intrinsic 'div'(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact : Strategy:="default") -> RngUPolElt_FldPadExact
  {Division without remainder.}
  // put over a common field
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be defined over a common field";
  f := CAST(R, f);
  g := CAST(R, g);
  K := BaseRing(R);
  // check leading coefficients
  dg := Degree(g : Strategy := Strategy);
  wdf := WeakDegree(f);
  // trivial cases
  if dg gt wdf then
    return CAST(R, 0);
  elif dg eq wdf then
    return CAST(R, Coefficient(f, wdf) / Coefficient(g, dg));
  elif dg eq 0 then
    return f / Coefficient(g, 0);
  elif dg lt 0 then
    error "divide by zero";
  end if;
  // general case
  vg := MinValuation(g);
  vlcg := Valuation(LeadingCoefficient(g));
  init := Approximation(f, CAPR(f)) div Approximation(g, CAPR(g));
  mkupdate := func<z | function (aprs)
    apr := &join aprs;
    vf := WeakMinValuation(f);
    v := vf - vg;
    pr := (apr - v) join (vlcg+1-vg) join 0;
    return ExactpAdics_GeneralGetter(pr,
      procedure (~pr, ~getter)
        getter := &cat[
          Approximation_Lazy(f, vf+pr),
          Approximation_Lazy(g, vg+pr)
        ];
      end procedure,
      procedure (xfg, ~pr, ~val)
        xf, xg := Explode(xfg);
        assert Degree(xg) eq dg;
        xz := xf div xg;
        d := &join(aprs - ExactpAdics_APr(xz));
        if d le 0 then
          Update(z, xz);
          val := true;
        else
          pr +:= d;
        end if;
      end procedure
    );
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;

///hide
intrinsic 'div'(f :: RngUPolElt_FldPadExact, g : Strategy:="default") -> .
  {"}
  return do_binop(func<f, g | 'div'(f, g : Strategy:=Strategy)>, f, g);
end intrinsic;

///hide
intrinsic 'div'(f, g :: RngUPolElt_FldPadExact : Strategy:="default") -> .
  {"}
  return do_binop(func<f, g | 'div'(f, g : Strategy:=Strategy)>, f, g);
end intrinsic;

/// Scalar division.
///param Strategy Used to check that `x` is nonzero.
intrinsic '/'(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt : Strategy:="default") -> RngUPolElt_FldPadExact
  {Division by a scalar.}
  ok, F := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "x and the coefficients of f must come from the same field";
  R := PolynomialRing(F);
  f := CAST(R, f);
  x := CAST(F, x);
  // check x is non-zero
  if IsDefinitelyZero(x) then
    error "division by zero";
  elif IsWeaklyZero(x : Strategy:=Strategy) then
    error "division by weak zero";
  end if;
  // trivial cases
  if IsDefinitelyZero(f) then
    return f;
  end if;
  // general case
  vx := Valuation(x);
  init := Approximation(f, CAPR(f)) / Approximation(x, CAPR(x));
  mkupdate := func<z | function (aprs)
    pr := &join(aprs - WeakValuation(f) + vx);
    if pr gt 0 then
      return [
        Approximation_Lazy(f, aprs+vx),
        Approximation_Lazy(x, pr+vx)
      ] mod function (xf, xx)
        Update(z, xf / xx);
        return true;
      end function;
    else
      UpdateZero(z, aprs);
      return true;
    end if;
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;

///hide
intrinsic '/'(f :: RngUPolElt, x :: FldPadExactElt : Strategy:="default") -> RngUPolElt_FldPadExact
  {"}
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  f := ChangeRing(f, K);
  x := K ! x;
  return '/'(f, x : Strategy:=Strategy);
end intrinsic;

///hide
intrinsic '/'(f :: RngUPolElt_FldPadExact, x : Strategy:="default") -> RngUPol_FldPadExact
  {"}
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  f := ChangeRing(f, K);
  x := K ! x;
  return '/'(f, x : Strategy:=Strategy);
end intrinsic;

///hide
intrinsic '*'(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt) -> RngUPolElt_FldPadExact
  {Multiplication by a scalar.}
  ok, F := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "x and the coefficients of f must come from the same field";
  R := PolynomialRing(F);
  f := CAST(R, f);
  x := CAST(F, x);
  // trivial cases
  if IsDefinitelyZero(f) or IsDefinitelyZero(x) then
    return Zero(R);
  end if;
  // general case
  xf := Approximation(f, CAPR(f));
  xx := Approximation(x, CAPR(x));
  init := xf * xx;
  mkupdate := func<z | function (aprs)
    vx := WeakValuation(x);
    vf := WeakValuation(f);
    pr := &join(aprs - vf - vx);
    return [
      Approximation_Lazy(f, aprs-vx),
      Approximation_Lazy(x, vx+pr)
    ] mod function (xf, xx)
      Update(z, xf * xx);
      return true;
    end function;
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;

///hide
intrinsic '*'(x :: FldPadExactElt, f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {"}
  return f * x;
end intrinsic;

/// Shifts the valuation of the `i`th coefficient of `f` by `ns(i)`.
intrinsic ShiftValuation(f :: RngUPolElt_FldPadExact, ns) -> RngUPolElt_FldPadExact
  {f with coefficients shifted by corresponding elements of ns.}
  ok, ns := IsValidAbsolutePrecision(f, ns);
  require ok: "Argument 2 must be coercible to a valuation of f";
  if IsDefinitelyZero(f) then
    return f;
  end if;
  d := WeakDegree(f);
  nseq := [IntegerValue(ns(i)) : i in [0..d]];
  init := shiftVal_poly(Approximation(f, CAPR(f)), nseq);
  mkupdate := func<z | function (aprs)
    return Approximation_Lazy(f, aprs - ns)
    mod function (xf)
      Update(z, shiftVal_poly(xf, nseq));
      return true;
    end function;
  end function>;
  return Parent(f) ! <init, mkupdate>;
end intrinsic;

/// Shifts the valuation of the `i`th coefficient of `f` by `i*n`.
///param Pivot Shifts the valuation a further `-n*Pivot` so that the `Pivot`th coefficient is unchanged.
///param Offset Shifts the valuation a further `Offset`.
intrinsic ShiftSlope(f :: RngUPolElt_FldPadExact, n : Pivot:=0, Offset:=0) -> RngUPolElt_FldPadExact
  {Returns f(x*pi^n)/pi^(n*Pivot) (which increases the slopes of the Newton polygon of f by n, and leaves the Pivot'th coefficient the same).}
  n := Val_FldPadElt_Make(n);
  Offset := Val_FldPadElt_Make(Offset);
  require Type(Pivot) eq RngIntElt: "Pivot must be an integer";
  if ((n eq 0) and (Offset eq 0)) or IsDefinitelyZero(f) then
    return f;
  end if;
  return ShiftValuation(f, [<i, n*(i - Pivot)+Offset> : i in [0..WeakDegree(f)]]);
end intrinsic;

/// `f(x+X)` as a polnomial in `X`
intrinsic ShiftArgument(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt) -> RngUPol_FldPadExact
  {The polynomial f(x+X).}
  // common field
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "Arguments must be defined over a common field";
  f := ChangeRing(f, K);
  x := K ! x;
  R := Parent(f);
  // trivial cases
  if IsDefinitelyZero(x) then
    return f;
  elif IsDefinitelyZero(f) then
    return f;
  elif WeakDegree(f) le 0 then
    return f;
  end if;
  // main case
  xf := Approximation(f, CAPR(f));
  xx := Approximation(x, CAPR(x));
  init := Evaluate(xf, Parent(xf).1 + xx);
  e := AbsoluteRamificationDegree(K);
  FUDGE := e eq 1 select 0 else 2*e;
  df := WeakDegree(f);
  p := Prime(K);
  binvals := [[Valuation(Binomial(i,j),p)*e : i in [j..df]] : j in [0..df]];
  mkupdate := func<z | function (apr)
    // f(x+X) = sum_j X^j (sum_i f_i (i choose j) x^(i-j))
    // so f(x+X)_j = sum_i f_i (i choose j) x^(i-j)
    // so if we want f(x+X)_j to absolute precision apr(j)
    // then we want f_i (i choose j) x^(i-j) to absolute precision apr(j)
    // i.e. relative precision pr_ij apr(j) - val(f_i) - val(i choose j) - (i-j) val(x)
    // so we want f_i to absolute precision val(f_i) + pr_ij
    // and x to absolute precision val(x) + pr_ij
    vf := WVAL(f);
    vx := WVAL(x);
    pr := [[apr(j) - (vf(i) + binvals[j+1][i-j+1] + vx*(i-j)) : i in [j..df]] : j in [0..df]];
    aprx := vx + &join &cat pr;
    aprf := [<i, vf(i) + &join[pr[j+1][i-j+1] join 0 : j in [0..i]]> : i in [0..df]];
    return [Approximation_Lazy(f, aprf), Approximation_Lazy(x, aprx)] mod function (xf, xx)
      Update(z, Evaluate(xf, Parent(xf).1 + xx));
      // Update(z, Parent(xf)![&+[Coefficient(xf,i) * Binomial(i,j) * xx^(i-j) : i in [j..df]] : j in [0..df]]);
      return true;
    end function;
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;

intrinsic Slice(f :: RngUPolElt_FldPadExact, idxs :: [RngIntElt]) -> RngUPolElt_FldPadExact
  {The polynomial with the given coefficients of f.}
  require forall{i : i in idxs | i ge 0}: "idxs must be non-negative";
  R := Parent(f);
  if #idxs eq 0 then
    return CAST(R, []);
  end if;
  xf := Approximation(f, CAPR(f));
  init := Parent(xf) ! [IsDefined(idxs,i) select Coefficient(xf, idxs[i]) else 0 : i in [1..#idxs]];
  // make an array a := [<j, [i : idxs[i] eq j]>]
  a := AssociativeArray();
  for i in [1..#idxs] do
    if IsDefined(idxs, i) then
      j := idxs[i];
      if IsDefined(a, j) then
        Append(~a[j], i);
      else
        a[j] := [i];
      end if;
    end if;
  end for;
  a := [<j, a[j]> : j in Keys(a)];
  print a;
  mkupdate := func<z | function (aprs)
    return Approximation_Lazy(f, [<x[1], &join[aprs(i-1) : i in x[2]]> : x in a]) mod function (xf)
      Update(z, Parent(xf) ! [IsDefined(idxs,i) select Coefficient(xf, idxs[i]) else 0 : i in [1..#idxs]]);
      return true;
    end function;
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;

intrinsic Reverse(f :: RngUPolElt_FldPadExact : Strategy:="default") -> RngUPolElt_FldPadExact
  {The polynomial with the reversed coefficients of f: f(1/x)*x^deg(f).}
  d := Degree(f : Strategy:=Strategy);
  return Slice(f, [d..0 by -1]);
end intrinsic;

intrinsic WeakReverse(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {The polynomial with the reversed weak coefficient of f: f(1/x)*x^weakdeg(f).}
  d := WeakDegree(f);
  return Slice(f, [d..0 by -1]);
end intrinsic;

intrinsic Decimate(f :: RngUPolElt_FldPadExact, n :: RngIntElt : Phase:=0) -> RngUPolElt_FldPadExact
  {The polynomial of the ith coefficients of f where i=Phase mod n.}
  require n gt 0: "n must be positive";
  d := WeakDegree(f);
  return Slice(f, [Phase mod n .. d by n]);
end intrinsic;

///### Derivative

intrinsic Derivative(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {The first derivative of f.}
  return Derivative(f, 1);
end intrinsic;

intrinsic Derivative(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> RngUPolElt_FldPadExact
  {The nth derivative of f.}
  require n ge 0: "n must be non-negative";
  if n eq 0 then
    return f;
  end if;
  R := Parent(f);
  d := WeakDegree(f);
  if n gt d then
    return CAST(R, 0);
  end if;
  if not assigned f`derivative then
    f`derivative := [];
  end if;
  if not IsDefined(f`derivative, n) then
    K := BaseRing(R);
    e := AbsoluteRamificationDegree(K);
    p := Prime(K);
    bs := [NumberOfPermutations(i,n) : i in [n..d]];
    vbs := [e*Valuation(b,p) : b in bs];
    init := Derivative(Approximation(f, CAPR(f)), n);
    mkupdate := func<z | function (aprs)
      faprs := AbsolutePrecision(f);
      return Approximation_Lazy(f, [i lt n select <i, faprs(i)> else <i, aprs(i-n)-vbs[i-n+1]> : i in [n..WeakDegree(f)]]) mod function (xf)
        Update(z, Derivative(xf, n));
        return true;
      end function;
    end function>;
    f`derivative[n] := R ! <init, mkupdate>;
  end if;
  return f`derivative[n];
end intrinsic;

///### Evaluate

declare verbose ExactpAdics_Evaluate, 2;

intrinsic Evaluate(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt) -> FldPadExactElt
  {Evaluates `f` at `x`.}
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "x and the coefficients of f must lie in the same field";
  f := ChangeRing(f, K);
  x := CAST(K, x);
  R := Parent(f);
  // trivial cases
  if IsDefinitelyZero(f) then
    return CAST(K, 0);
  elif IsDefinitelyZero(x) or WeakDegree(f) eq 0 then
    return Coefficient(f, 0);
  end if;
  // main case
  xf := Approximation(f, CAPR(f));
  xx := Approximation(x, CAPR(x));
  init := Evaluate(xf, xx);
  mkupdate := func<z | function (apr)
    vx := WeakValuation(x);
    d := WeakDegree(f);
    vfs := WeakValuation(f);
    pr := apr - &meet ShiftSlope(vfs, vx);
    return [
      Approximation_Lazy(f, [<i,apr-i*vx> : i in [0..d]]),
      Approximation_Lazy(x, vx+pr)
    ] mod function (xf, xx)
      Update(z, Evaluate(xf, xx));
      return true;
    end function;
  end function>;
  ret := K ! <init, mkupdate>;
  return ret;
end intrinsic;

intrinsic Evaluate(f :: RngUPolElt_FldPadExact, x) -> FldPadExactElt
  {"}
  ok, x := IsCoercible(BaseRing(f), x);
  require ok: "x must be coercible to the coefficient ring of f";
  return Evaluate(f, x);
end intrinsic;

intrinsic Evaluate(f :: RngUPolElt, x :: FldPadExactElt) -> FldPadExactElt
  {"}
  ok, f := CanChangeRing(f, Parent(x));
  require ok: "f must be coercible to the field containing x";
  return Evaluate(f, x);
end intrinsic;

intrinsic Evaluate(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {Evaluates `f` at `g`.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "Argument 1 and argument 2 must be coercible to a common ring";
  f := R ! f;
  g := R ! g;
  // trivial cases
  if IsDefinitelyZero(f) or WeakDegree(f) eq 0 then
    return f;
  elif IsDefinitelyZero(g) then
    return Slice(f, [0]);
  elif WeakDegree(g) eq 0 then
    return Evaluate(f, Coefficient(g,0));
  end if;
  // main case (f and g are both non-constant)
  return &+[Coefficient(f,i) * g^i : i in [0..WeakDegree(f)]];
end intrinsic;

///### Special forms

intrinsic IsInertial(f :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt
  {True if f is inertial (i.e. it is irreducible as a polynomial over the residue class field).}
  if not assigned f`is_inertial then
    R := Parent(f);
    F := BaseRing(R);
    C, m, xm := ResidueClassField(F);
    d := Degree(f : Strategy:=Strategy);
    IncreaseAbsolutePrecision(f, 1);
    xcoeffs := Coefficients(f`approximation);
    // check integral and "monic"
    if exists{i : i in [0..d] | Valuation(xcoeffs[i+1]) lt 0} then
      f`is_inertial := false;
    elif Valuation(xcoeffs[d+1]) ne 0 then
      f`is_inertial := false;
    else
      // coerce to residue class field and check irreducible
      fC := Polynomial([C | xm(x) : x in Coefficients(f`approximation)]);
      assert Degree(fC) eq d;
      f`is_inertial := IsIrreducible(fC);
    end if;
  end if;
  return f`is_inertial;
end intrinsic;

intrinsic IsEisenstein(f :: RngUPolElt_FldPadExact) -> BoolElt
  {True if f is Eisenstein.}
  if not assigned f`is_eisenstein then
    d := Degree(f);
    if d lt 1 then
      f`is_eisenstein := false;
    else
      IncreaseAbsolutePrecision(f, [<i, (i eq 0) select 2 else 1> : i in [0..d]]);
      xf := f`approximation;
      f`is_eisenstein := Valuation(Coefficient(xf, 0)) eq 1
        and Valuation(Coefficient(xf, d)) eq 0
        and forall{i : i in [1..d-1] | Valuation(Coefficient(xf, i)) gt 0};
    end if;
  end if;
  return f`is_eisenstein;
end intrinsic;

///## Discriminant and Resultant

intrinsic Discriminant(f :: RngUPolElt_FldPadExact : Strategy:="default") -> FldPadExactElt
  {The discriminant of f.}
  if not assigned f`discriminant then
    d := Degree(f : Strategy:=Strategy);
    R := Parent(f);
    K := BaseRing(R);
    init := Discriminant(Approximation(f, CAPR(f)));
    mkupdate := func<z | function (apr)
      v := WeakMinValuation(f);
      pr := apr - (2*d-2)*v;
      return Approximation_Lazy(f, v+pr) mod function (xf)
        assert Degree(xf) eq d;
        Update(z, Discriminant(xf));
        return true;
      end function;
    end function>;
    f`discriminant := K ! <init, mkupdate>;
  end if;
  return f`discriminant;
end intrinsic;

intrinsic Resultant(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact : Strategy:="default", fStrategy:=Strategy, gStrategy:=Strategy) -> FldPadExactElt
  {The resultant of f and g.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be defined over a common field";
  return Resultant([R| f, g] : Strategies:=[*fStrategy, gStrategy*]);
end intrinsic;

intrinsic WeakResultant(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> FldPadExactElt
  {The weak resultant of f and g.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be defined over a common field";
  return WeakResultant([R|f,g]);
end intrinsic;

// given a sequence of p-adic polynomials, returns their resultant WITHOUT increasing the precision of the field they are in
function resultant(fs)
  R := Universe(fs);
  K := BaseRing(R);
  vs := [Min([Valuation(c) : c in Coefficients(f)] cat [Infinity()]) : f in fs];
  ds := [Degree(f) : f in fs];
  d := &+ds;
  v := &+[vs[i]*(d - ds[i]) : i in [1..#fs]];
  zfs := [ShiftValuation(fs[i], -vs[i]) : i in [1..#fs]];
  apr := Min([AbsolutePrecision(c) : c in Coefficients(f), f in fs]);
  OK := Integers(K);
  QK := quo<OK | ShiftValuation(OK ! 1, apr)>;
  QR := PolynomialRing(QK);
  qzfs := [QR ! zf : zf in zfs];
  qzres := &*[Resultant(qzfs[i], qzfs[j]) : j in [i+1..#fs], i in [1..#fs]];
  zres := K ! OK ! qzres;
  res := ShiftValuation(zres, v);
  return res;
end function;

intrinsic Resultant(fs :: [RngUPolElt_FldPadExact] : Strategy:="default", Strategies:=[*Strategy : f in fs*]) -> FldPadExactElt
  {The generalized resultant of fs.}
  require IS_INSTANCE(Strategies,{List, SeqEnum})
  and (#Strategies eq #fs):
    "Strategies must be a list or sequence with the same length as fs";
  // ensure the degrees of fs are known before computing a weak resultant
  _ := [Degree(fs[i] : Strategy:=Strategies[i]) : i in [1..#fs]];
  return WeakResultant(fs);
end intrinsic;

intrinsic WeakResultant(fs :: [RngUPolElt_FldPadExact]) -> FldPadExactElt
  {The weak resultant of fs, i.e. the resultant assuming the weak degree of each f in fs is correct.}
  R := Universe(fs);
  K := BaseRing(R);
  ds := [WeakDegree(f) : f in fs];
  vs := [WeakValuation(f) : f in fs];
  d := &+ds;
  dds := [d-d0 : d0 in ds];
  init := resultant([Approximation(f : Pr:=1, Weak) : f in fs]);
  mkupdate := func<z | function (apr)
    vs := [WeakValuation(f) : f in fs];
    v := &+[vs[i]*dds[i] : i in [1..#fs]];
    pr := apr - v;
    return &cat[Approximation_Lazy(fs[i] : APr:=vs[i]+pr) : i in [1..#fs]]
    mod function (xfs)
      Update(z, resultant(xfs));
      return true;
    end function;
  end function>;
  return K ! <init, mkupdate>;
end intrinsic;

///## Newton polygon

// points <x,y> on the edge of the newton polygon with integer coefficients
function nwtnpgon_integer_points(np)
  vs := [car<Z,Z>| v : v in Vertices(np)];
  if #vs eq 0 then
    return vs;
  end if;
  return &cat[i eq 1 select [vs[i]] else ([<j, y0+h*((j-x0) div e)> : j in [x0+e..x1 by e]] where h:=Numerator(s) where e:=Denominator(s) where s:=(y1-y0)/(x1-x0) where x0:=vs[i-1][1] where y0:=vs[i-1][2] where x1:=vs[i][1] where y1:=vs[i][2]) : i in [1..#vs]];
end function;

/// The Newton polygon of `f`.
/// 
///param AllowWeaklyZeroConstantCoefficient:=false When true, do not raise an error if the constant coefficient is weakly zero; instead require that the linear coefficient is nonzero and return a Newton polygon starting at 1.
intrinsic NewtonPolygon(f :: RngUPolElt_FldPadExact : Strategy:="default", AllowWeaklyZeroConstantCoefficient:=false) -> NwtnPgon
  {The Newton polygon of f.}
  if not assigned f`newton_polygon then
    d := Degree(f : Strategy:=Strategy);
    // trivial case
    if d lt 0 then
      f`newton_polygon := NewtonPolygon([] : Faces:="Lower");
    else
      // check the top and bottom coefficients are nonzero simultaneously
      assert not WZERO(Coefficient(f`approximation, d));
      if AllowWeaklyZeroConstantCoefficient then
        error if AreAllWeaklyZero([Coefficient(f, i) : i in [0..1]] : Strategy:=Strategy), "constant and linear coefficients are weakly zero";
      else
        error if IsWeaklyZero(Coefficient(f, 0) : Strategy:=Strategy), "constant coefficient is weakly zero";
      end if;
      // get an initial Newton polygon based on what we already know
      np := func<|NewtonPolygon([
        <i, Valuation(c)>
        : i in [0..d]
        | not WZERO(c)
        where c := Coefficient(f`approximation, i)
      ] : Faces:="Lower")>;
      np0 := np();
      // increase precision of f just enough to determine if there are any more unknowns
      vs := ChangeUniverse(Vertices(np0), car<Z,Z>);
      if #vs ge 2 then
        IncreaseAbsolutePrecision(f, &cat[
          [ 
            <x, Ceiling(v0+(x-i0)*s)>
            : x in [x0..x1]
          ] 
          where x0:=j eq 2 select 0 else i0+1
          where x1:=i1
          where s:=(v1-v0)/(i1-i0)
          where i0,v0:=Explode(vs[j-1])
          where i1,v1:=Explode(vs[j])
          : j in [2..#vs]
        ]);
      else
        assert AllowWeaklyZeroConstantCoefficient;
        assert #vs eq 1;
        assert d eq 1;
        assert vs[1][1] eq 1;
      end if;
      // get the actual Newton polygon
      np1 := np();
      if Vertices(np1)[1][1] eq 0 then
        f`newton_polygon := np1;
      else
        assert AllowWeaklyZeroConstantCoefficient;
        return np1;
      end if;
    end if;
  end if;
  return f`newton_polygon;
end intrinsic;

intrinsic WeakPartialNewtonPolygon(f :: RngUPolElt_FldPadExact) -> NwtnPgon
  {A fragment of the Newton polygon of f, based on its non weakly zero coefficients.}
  df := WeakDegree(f);
  // trivial cases
  if df lt 0 then
    return NewtonPolygon([] : Faces:="Lower");
  elif df eq 0 then
    c := Coefficient(f`approximation, 0);
    if WZERO(c) then
      return NewtonPolygon([] : Faces:="Lower");
    else
      return NewtonPolygon([<0, VAL(c)>] : Faces:="Lower");
    end if;
  end if;
  // iterate until done
  while true do
    xf := f`approximation;
    // find the weak newton polygon of f
    wnp := NewtonPolygon([<i, v> : i in [0..df] | v lt OO where v:=VAL(Coefficient(xf,i))] : Faces:="Lower");
    // the non weakly zero coefficient valuations
    vals := [<i, VAL(c)> : i in [0..df] | not WZERO(c) where c:=Coefficient(xf, i)];
    // those lying on the edge of the Newton polygon
    good_vals := SORT(SequenceToSet(vals) meet SequenceToSet(nwtnpgon_integer_points(wnp)));
    // not many
    if #good_vals eq 0 then
      // if there are none, there's nothing we can do
      return NewtonPolygon([] : Faces:="Lower");
    elif #good_vals eq 1 then
      // if there is one and it's a vertex, then return that
      v := good_vals[1];
      if v in Vertices(wnp) then
        return NewtonPolygon([v] : Faces:="Lower");
      else
        return NewtonPolygon([] : Faces:="Lower");
      end if;
    end if;
    // the newton polygon around the good vertices
    np := NewtonPolygon(good_vals : Faces:="Lower");
    // compute the value of the Newton polygon at each integer 0..df
    // we want to be strictly more precise than this
    vs := ChangeUniverse(Vertices(np), car<Z,Z>);
    aprs := &cat[[y0+(j-x0)*s : j in [j0..j1]] where j0:=(i eq 2 select 0 else x0) where j1:=(i eq #vs select df else x1-1) where s:=(y1-y0)/(x1-x0) where x0,y0:=Explode(vs[i-1]) where x1,y1:=Explode(vs[i]) : i in [2..#vs]];
    assert #aprs eq df+1;
    // if we are already this precise, then we are done
    if forall{i : i in [0..df] | APR(Coefficient(xf, i)) gt aprs[i+1]} then
      return np;
    else
      IncreaseAbsolutePrecision(f, [<i, Floor(aprs[i+1]+1)> : i in [0..df]]);
    end if;
  end while;
end intrinsic;

///## Hensel lifting

declare verbose ExactpAdics_IsHenselLiftable_Root, 1;
declare verbose ExactpAdics_IsHenselLiftable_Factor, 1;

/// True if `x` is Hensel-liftable to a root of `f`. If so, also returns the root.
/// 
/// This uses a generalized statement of Hensel's lemma which does not require the inputs to be integral, namely:
/// 
/// **Hensel's lemma.** *If $f(x) \in K[x]$ and $x \in K$ such that $x$ is closer to one root of $f$ than any other, then iterating $x \mapsto x - f(x)/f'(x)$ converges to that root.*
intrinsic IsHenselLiftable(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt : Strategy:="default") -> BoolElt, FldPadExactElt
  {True if x is sufficiently close to a root of f to be Hensel-liftable. If so, also returns the root.}
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "Coefficients of argument 1 and argument 2 must be coercible to a common field";
  f := ChangeRing(f, K);
  x := K ! x;
  R := Parent(f);
  // trivial case, no roots possible
  if WeakDegree(f) le 0 then
    return false, _;
  end if;
  // check the hensel condition
  // we take an approximation of f and x, compute g(X):=f(x+X), and see if its Newton polygon has a vertex at 1
  // we do this by computing the Newton polygon of the weak valuations of g, and seeing if this has a vertex at 1 and the coefficient is not weakly zero
  ok, _, res := ExactpAdics_ExecutePrecisionStrategy(function (pr)
    // approximations for f and x may be in different fields; we also approximate R so that we can cast everything to a common field afterward
    xR, xf, xx := Explode(Evaluate(Flatten([Approximation_Lazy(R, pr), Approximation_Lazy(f, BaselineValuation(f) + pr), Approximation_Lazy(x, BaselineValuation(x) + pr)])));
    xK := BaseRing(xR);
    xf := xR ! xf;
    xx := xK ! xx;
    xg := Evaluate(xf, xR.1 + xx);
    np := NewtonPolygon([<i, v> : i in [0..Degree(xg)] | v lt OO where v:=VAL(Coefficient(xg, i))] : Faces:="Lower");
    vs := ChangeUniverse(Vertices(np), car<Z,Z>);
    // these asserts may not hold; it is possible that g has some exactly zero coefficients
    // TODO: deal with this case
    assert vs[1][1] eq 0;
    assert vs[2][1] ge 1;
    // if there is a vertex at 1...
    if vs[2][1] eq 1 then
      // ... and it is a real vertex ...
      if not WZERO(Coefficient(xg, 1)) then
        // then we have a root
        return true, [*true,vs[1][2],vs[2][2]*];
      else
        // else, we don't know
        return false, _;
      end if;
    end if;
    // if there is a face from 0 to n, n>1, then it is not hensel liftable
    assert vs[2][1] gt 1;
    x0,y0:=Explode(vs[1]);
    x1,y1:=Explode(vs[2]);
    s := (y1-y0)/(x1-x0);
    if not WZERO(Coefficient(xg, 0)) and exists{i : i in [2..x1] | (not WZERO(c)) and VAL(c) eq y0+s*(i-x0) where c:=Coefficient(xg, i)} then
      return true, [*false*];
    end if;
    // otherwise we don't know
    return false, false;
  end function, Strategy);
  // did we get an answer?
  if not ok then
    error "precision error";
  end if;
  // did we pass?
  if not res[1] then
    return false, _;
  end if;
  // hooray! now find a lift
  val0 := res[2];
  val1 := res[3];
  g := ShiftArgument(f, x);
  s := val0 - val1;
  h := ShiftSlope(g, s : Offset:=-val0);
  xh := Approximation(h, 1);
  assert VAL(Coefficient(xh, 0)) ge 0;
  assert VAL(Coefficient(xh, 1)) eq 0 and not WZERO(Coefficient(xh, 1));
  assert forall{i : i in [2..WeakDegree(h)] | VAL(Coefficient(xh, i)) gt 0};
  // now hensel lift a root of h
  rh := K!<init, mkupdate>
    where init := Coefficient(xh, 0) / Coefficient(xh, 1)
    where mkupdate := func<z | function (apr)
      n := IntegerValue(apr);
      assert n gt 0;
      return [Approximation_Lazy(K, n), Approximation_Lazy(h, apr)] mod function (xK, xh)
        Q := quo<Integers(xK) | ShiftValuation(xK!1, n)>;
        qh := ChangeRing(xh, Q);
        qr := Q ! z`approximation;
        dqh := Derivative(qh);
        while true do
          qhr := Evaluate(qh, qr);
          dqhr := Evaluate(dqh, qr);
          s := VAL(qhr);
          assert VAL(dqhr) eq 0;
          if s eq n then
            break;
          else
            qr2 := qr - qhr div dqhr;
            assert VAL(Evaluate(qh,qr2)) ge Min(n,2*s);
            qr := qr2;
          end if;
        end while;
        Update(z, xK ! qr);
        return true;
      end function;
    end function>;
  // translate back to a root of f and we're done
  return true, ShiftValuation(rh, s) + x;
end intrinsic;

///ditto
intrinsic IsHenselLiftable(f :: RngUPolElt_FldPadExact, x :: . : Strategy:="default") -> BoolElt, FldPadExactElt
  {"}
  ok, x := IsCoercible(BaseRing(f), x);
  require ok: "x must be coercible into the base ring of f";
  // IncreaseAbsolutePrecision(x, AbsolutePrecision(f));
  return IsHenselLiftable(f, x : Strategy:=Strategy);
end intrinsic;

///ditto
intrinsic IsHenselLiftable(f :: RngUPolElt, x :: FldPadExactElt : Strategy:="default") -> BoolElt, FldPadExactElt
  {"}
  ok, f := CanChangeRing(f, Parent(x));
  require ok: "coefficients of f must be coercible to the field containing x";
  // IncreaseAbsolutePrecision(f, AbsolutePrecision(x));
  return IsHenselLiftable(f, x : Strategy:=Strategy);
end intrinsic;

/// The root of `f` uniquely closest to `x` (see `IsHenselLiftable`).
intrinsic HenselLift(f :: RngUPolElt_FldPadExact, x : Strategy:="default") -> FldPadExactElt
  {Returns the root of f Hensel lifted from x.}
  ok, y := IsHenselLiftable(f, x : Strategy:=Strategy);
  if ok then
    return y;
  else
    error "not Hensel liftable";
  end if;
end intrinsic;

///ditto
intrinsic HenselLift(f :: RngUPolElt, x : Strategy:="default") -> FldPadExactElt
  {"}
  ok, y := IsHenselLiftable(f, x : Strategy:=Strategy);
  if ok then
    return y;
  else
    error "not Hensel liftable";
  end if;
end intrinsic;

/// True if `g` is Hensel-liftable to a factor of `f`. If so, also returns the factor (with the same leading coefficient as `g`) and its cofactor.
/// 
/// This uses a generalized statement of Hensel's lemma which does not require the inputs to be integral.
///hide
intrinsic IsHenselLiftable(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt, RngUPolElt_FldPadExact, RngUPolElt_FldPadExact
  {True if g is Hensel-liftable to a factor of f, and the factor and cofactor.}
  // cast to a common field
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "Arguments must be coercible to a common ring";
  f := R ! f;
  g := R ! g;
  // check degrees
  df := WeakDegree(f);
  dg := Degree(g : Strategy:=Strategy);
  if dg lt 0 then
    // g=0 is a factor of nothing
    return false, _;
  elif dg eq 0 then
    // g=const is a factor of anything
    return true, g;
  elif dg eq df then
    df := Degree(f : Strategy:=Strategy);
    return true, f * (Coefficient(g, dg) / Coefficient(f, df));
  elif dg gt df then
    return false, _;
  end if;
  // form the multivariate problem
  h := 'div'(f, g : Strategy:=Strategy);
  dh := df - dg;
  K := BaseRing(R);
  S := PolynomialRing(K, df);
  lcg := Coefficient(g, dg);
  lch := Coefficient(h, dh);
  T := car<K, PowerSequence(Z)>;
  eqns := [S| <[ce[1] : ce in ces], [ce[2] : ce in ces]> where ces:=[T| <(i eq dg select lcg else 1)*(j eq dh select lch else 1), [ii eq i select 1 else 0 : ii in [0..dg-1]] cat [jj eq j select 1 else 0 : jj in [0..dh-1]]> where j:=k-i : i in [Max(0,k-dh)..Min(dg,k)]] cat [T| <-Coefficient(f,k), [0 : kk in [0..df-1]]>] : k in [0..df-1]];
  soln := [K| Coefficient(g, i) : i in [0..dg-1]] cat [K| Coefficient(h, j) : j in [0..dh-1]];
  ok, coeffs := IsHenselLiftable(eqns, soln : Strategy:=Strategy);
  if ok then
    return true, R![i eq dg select lcg else coeffs[i+1] : i in [0..dg]], R![j eq dh select lch else coeffs[dg+j+1] : j in [0..dh]];
  else
    return false, _;
  end if;
end intrinsic;

///## Approximation

intrinsic SetBaselineValuation(f :: RngUPolElt_FldPadExact, n)
  {Sets the baseline valuation of f to n.}
  ok, n := IsValidAbsolutePrecision(f, n);
  require ok: "invalid n";
  f`baseline_valuation := n;
end intrinsic;

intrinsic BaselineValuation(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {The baseline valuation of f.}
  return f`baseline_valuation;
end intrinsic;

intrinsic BaselinePrecision(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {The baseline precision of f: AbsolutePrecision(f) - BaselineValuation(f).}
  return APR(f) - BVAL(f);
end intrinsic;

intrinsic IncreaseBaselinePrecision(f :: RngUPolElt_FldPadExact, n)
  {Increases the baseline precision of f to n.}
  INC_APR(f, BVAL(f) + n);
end intrinsic;

intrinsic WeakApproximation(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {An element weakly equal to x.}
  R := f`parent;
  if WZERO(f) then
    return R ! 0;
  else
    g := New(RngUPolElt_FldPadExact);
    g`id := NEXTID();
    g`parent := R;
    g`approximation := f`approximation;
    g`update := function (apr)
      pr := PrecisionRequired(g, apr);
      // dg := WeakDegree(g);
      // xg := g`approximation;
      // pr := Max([(WZERO(c) or v eq OO select 0 else aprs[i+1]-v)
      //   where v := Valuation(c)
      //   where c := Coefficient(xg, i)
      //   : i in [0..dg]
      // ]);
      return IncreaseAbsolutePrecision_Lazy(R, pr) mod function (ig)
        Update(g, CHANGE_APR(g`approximation, apr join APR(g)));
        return true;
      end function;
    end function;
    return g;
  end if;
end intrinsic;

intrinsic WeakValuation(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {The valuations of the coefficients of the approximation of f.}
  return Val_RngUPolElt_FldPad_Make(OO, [0..WeakDegree(f)], [VAL(c) : c in Coefficients(f`approximation)]);
end intrinsic;

intrinsic WeakMinValuation(f :: RngUPolElt_FldPadExact) -> Val_FldPadElt
  {The minimum valuation of the coefficients of the approximation of f.}
  return &meet WeakValuation(f);
end intrinsic;

intrinsic AbsolutePrecision(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {The absolute precisions of the coefficients of the approximation of f.}
  return Val_RngUPolElt_FldPad_Make(OO, [0..WeakDegree(f)], [APR(c) : c in Coefficients(f`approximation)]);
end intrinsic;

intrinsic Precision(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {The precisions of the coefficients of the approximation of f.}
  return APR(f) - PR(f);
end intrinsic;

intrinsic Approximation_Lazy(f :: RngUPolElt_FldPadExact, apr : Quick:=false, FixPr:=true) -> ExactpAdics_Gettr
  {An approximation to f.}
  ok, apr := IsValidAbsolutePrecisionDiff(f, apr);
  require ok: "Argument 2: " cat apr;
  pr := PrecisionRequired(f, apr);
  // vs := [Valuation(c) : c in Coefficients(f`approximation)];
  // Pr := Max([vs[i] eq OO select 0 else APr[i] - vs[i]  : i in [1..#vs]]);
  iapR := IncreaseAbsolutePrecision_Lazy(Parent(f), pr);
  return iapR mod function (ig)
    iap := IncreaseAbsolutePrecision_Lazy(f, apr);
    return iap mod function (ig)
      if Quick then
        xf := f`approximation;
      else
        coeffs := Coefficients(f`approximation);
        U := Universe(coeffs);
        xf := Polynomial([U | CAP_APR(coeffs[i], apr(i-1)) : i in [1..#coeffs]]);
      end if;
      if FixPr then
        xf := ChangeRing(xf, ChangePrecision(BaseRing(xf), Max(1, pr)));
      end if;
      assert forall{i : i in [0..WeakDegree(f)] |
        AbsolutePrecision(Coefficient(xf, i)) ge apr(i)};
      return xf;
    end function;
  end function;
end intrinsic;

intrinsic Approximation(f :: RngUPolElt_FldPadExact, apr : Quick:=false, FixPr:=true) -> ExactpAdics_Gettr
  {"}
  return Evaluate(Approximation_Lazy(f, apr : Quick:=Quick, FixPr:=FixPr));
end intrinsic;

intrinsic IncreaseAbsolutePrecision_Lazy(R :: RngUPol_FldPadExact, pr :: RngIntElt) -> ExactpAdics_Gettr
  {Increases the precision of the approximation to R to at least pr.}
  pr := Max(pr, 1);
  return IncreaseAbsolutePrecision_Lazy(BaseRing(R), pr);
end intrinsic;

intrinsic Approximation_Lazy(R :: RngUPol_FldPadExact, pr :: RngIntElt) -> ExactpAdics_Gettr
  {An approximation to R whose base field has default precision pr.}
  require pr gt 0: "pr must be positive";
  return IncreaseAbsolutePrecision_Lazy(R, pr) mod function (ig)
    xR := R`approximation_ring;
    xK := BaseRing(xR);
    xK`DefaultPrecision := pr;
    return xR;
  end function;
end intrinsic;

intrinsic Approximation(R :: RngUPol_FldPadExact, pr :: RngIntElt) -> RngUPol
  {"}
  return Evaluate(Approximation_Lazy(R, pr));
end intrinsic;

intrinsic Approximation(R :: RngUPol_FldPadExact) -> RngUPol
  {The approximation to R.}
  return R`approximation_ring;
end intrinsic;

intrinsic IsDefinitelyZero(f :: RngUPolElt_FldPadExact) -> BoolElt
  {True if f is precisely zero.}
  return WZERO(f) and AbsolutePrecision(f) eq OO;
end intrinsic;

intrinsic IncreaseAbsolutePrecision(f :: RngUPolElt_FldPadExact, n)
  {Increases the absolute precision of f to n.}
  satisfy_dep(f, n);
end intrinsic;

intrinsic IncreaseAbsolutePrecision_Lazy(f :: RngUPolElt_FldPadExact, n) -> ExactpAdics_Gettr
  {A getter which when evaluated increases the absolute precision of f.}
  ok, n := IsValidAbsolutePrecisionDiff(f, n);
  if not ok then
    error "invalid n";
  end if;
  return ExactpAdics_Getter(false, procedure (~st, ~deps) deps := [*[*f,n*]*]; end procedure, procedure (~st, ~val) assert n le AbsolutePrecision(f); val := true; end procedure);
end intrinsic;

///hide
intrinsic IncreaseAbsolutePrecisions(xs)
  {Increases the absolute precision of xs[i][1] to xs[i][2].}
  satisfy_deps_list(xs, Infinity());
end intrinsic;

function merge_polys(f, g)
  // assuming f and g have the same parent and are weakly equal, returns the polynomial got by taking the most precise coefficients from each
  assert Parent(f) eq Parent(g);
  r := CAST(Parent(f), [
    AbsolutePrecision(cf) ge AbsolutePrecision(cg)
    select cf
    else cg
    where cf := Coefficient(f,i)
    where cg := Coefficient(g,i)
    : i in [0..Min(Degree(f), Degree(g))]
  ]);
  return r;
end function;

// intrinsic Update(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact)
//   {Updates f to the weak value of g.}
//   R := Parent(f);
//   require R eq Parent(g): "f and g must belong to the same field";
//   renewEltApproximation_poly(f);
//   renewEltApproximation_poly(g);
//   require WEQ(f`approximation, g`approximation)
//   and Degree(g`approximation) le Degree(f`approximation):
//     "inconsistent";
//   f`approximation := merge_polys(f`approximation, g`approximation);
// end intrinsic;

intrinsic Update(f :: RngUPolElt_FldPadExact, app :: RngUPolElt[FldPad])
  {Updates f to app.}
  R := Parent(f);
  xR := R`approximation_ring;
  ok, app := IS_VALID_APPROX(R, app);
  require ok: "app is in the wrong ring";
  FUDGE := GLOBAL_FUDGE(BaseRing(R));
  if FUDGE ne 0 then
    app := CHANGE_APR(app, [APR(c)-FUDGE : c in Coefficients(app)]);
  end if;
  if UPDATE_CONSISTENCY_CHECK then
    require WEQ(f`approximation, app): "inconsistent";
  end if;
  f`approximation := merge_polys(f`approximation, app);
  if assigned f`update_expecting_apr then
    assert APR(f) ge f`update_expecting_apr;
  end if;
end intrinsic;

intrinsic UpdateZero(f :: RngUPolElt_FldPadExact, aprs :: [RngIntElt])
  {Updates f to sum_i(O(pi^aprs[i+1])*x^i).}
  R := f`parent;
  xR := R`approximation_ring;
  K := BaseRing(R);
  xK := K`approximation_field;
  Update(f, CAST(xR, [Zero(xK, a) : a in aprs]));
end intrinsic;

///hide
intrinsic Print(R :: RngUPol_FldPadExact, lvl :: MonStgElt)
  {Print.}
  case lvl:
  when "Magma":
    printf "PolynomialRing(%m)", BaseRing(R);
  else
    printf "Polynomial ring";
    if assigned R`varname then
      printf " in %o", R`varname;
    end if;
    printf " over %O", BaseRing(R), lvl;
  end case;
end intrinsic;

///hide
intrinsic Print(f :: RngUPolElt_FldPadExact, lvl :: MonStgElt)
  {Prints f.}
  // renewEltApproximation_poly(f);
  case lvl:
  when "Magma":
    printf "%o", f`approximation;
  else
    printf "%o", Format(f : APr:=AbsolutePrecision(f) meet (1+WeakValuation(f)));
  end case;
end intrinsic;

intrinsic IsWeaklyZero(f :: RngUPolElt_FldPadExact : Strategy:=false) -> BoolElt
  {True if f is weakly zero.}
  if Strategy cmpeq false then
    return WZERO(f`approximation);
  elif not WZERO(f) then
    return false;
  else
    return not ExactpAdics_ExecutePrecisionStrategy(function (apr)
      IncreaseBaselinePrecision(f, apr);
      return not WZERO(f), _;
    end function, Strategy);
  end if;
end intrinsic;

intrinsic IsWeaklyEqual(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> BoolElt
  {True if f and g are weakly equal.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be defined over the same field";
  f := CAST(R, f);
  g := CAST(R, g);
  // renewEltApproximation_poly(f);
  // renewEltApproximation_poly(g);
  return WEQ(f`approximation, g`approximation);
end intrinsic;

///## Internals

intrinsic SetData(f :: RngUPolElt_FldPadExact, data)
  {Sets the custom data field.}
  f`data := data;
end intrinsic;

intrinsic GetData(f :: RngUPolElt_FldPadExact) -> .
  {Gets the custom data field.}
  return f`data;
end intrinsic;

