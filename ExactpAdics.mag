/*
A exact p-adic field is represented by either a prime number (for prime fields) or a polynomial (for extensions). At all times it has a precision (a positive integer) which can only increase and a FldPad which is an approximation to the field to this precision. When an approximation to a field element is made, it is always made in the current approximation field (which may be made more precise first, if necessary). If the approximation field is made more precise, then approximated field elements are out of date, but can easily be case into the current field at any time.

A field element is represented by a (precision,approximation) pair, with the precision identifying the precision of the approximation field, and an element of that approximation field. The precision can be compared against the precision of the approximation field at any time, and when there is a discrepancy, the approximation can be cast into the current approximation field. An element also carries with it an update procedure, which takes an absolute precision and updates the (precision,approximation) pair to an approximation with at least that absolute precision.
*/

// TODO: change the Magma sublime package to put scopes around definitions of functions, intrinsics, types and verbose flags, including prototypes (e.g. "function foo(x, y)", "intrinsic Foo(a :: RngIntElt)", "declare type FldPadExact", "declare verbose ExactpAdics") and make sublime include these in the symbol definitions list (magma-symbols.tmPreferences: http://docs.sublimetext.info/en/latest/reference/symbols.html)

// TODO: the word "FUDGE" appears here and there in the code, it signals that we are working around precision errors in FldPadElt computations (which seem to occur when casting between the top and bottom field of a totally ramified extension); when these are resolved, remove them. NOTE: Previously, "CAST" and "ELTSEQ" were redefinitions of "!" and "Eltseq" to work around these problems, but I couldn't find a single neat workaround; the current approach is to work around it in each place where it is a problem by taking the inputs to higher precision (the "FUDGE") and then lowering the precision of the output.

// TODO: implement more Tmp stuff

// TODO: rootsOfValuation, which returns the roots of a given valuation (without Newton polygon factoring)
// TODO: modify Roots(f) to use rootsOfValuation, Newton polygons, etc.

// TODO: use Tmp stuff to do all coercion?

// TODO: magma has IsIdentical; with this, remove all the id stuff which has two purposes: (a) equality checking and (b) dependency ordering. We can do (a) using IsIdentical. We can do (b) without a global counter: when satisfying dependencies, record against each object the objects depending on it. Hmmm except we need a unique id to keep track of when the same object comes up multiple times during dependency checking... can we get at the pointer value?

// TODO: '*', LeftDivide, IsLeftDivisible, RightDivide='/', IsRightDivisible, LeftDerivative and RightDerivative for transition functions

// TODO: a more general piecewise linear map type, represented as a function taking an x coordinate and returning [L, R] where L describes what's to the left (either the next vertex or a gradient which continues for infinity) and R similarly describes what's to the right, at least one of L or R must be a vertex. Given <left gradient, vertices, right gradient> we can deduce such a function, perhaps using binary search to find vertices. Have LeftDerivative, RightDerivative, Inverse, and composition all defined. Implement transition functions on top of these?

// TODO: it's convenient to the user to have default strategies like Strategy:="default" everywhere, but it's a little dangerous to the programmer who forgets to pass strategies from caller to callee, which instead uses the default strategy. Think about this. Time to think about strategy stacks?

// TODO: give each element a "baseline" valuation, which is a lower bound on its valuation and is never changed; by default, use the weak valuation of the initial value; then have BaselinePrecision, IncreaseBaselinePrecision, etc which work relative to this baseline; this is a way of removing valuation=0 as a special value

// TODO: represent an absolute precision of a FldPadExactElt as a new object consisting of the element and the precision; have creation functions for these; pass them around instead of just passing around integers; e.g. intrinsic AbsolutePrecisionInfo(x : Pr:=10, Absolute, Baseline, NewtonPolygon, Weak, ...); Value(a :: APr_FldPadExactElt); do the same for polynomials; ShiftValuation(a :: APr_FldPadExactElt, n :: RngIntElt); ShiftSlope(a :: APr_RngIntElt_FldPadExact, n :: RngIntElt); Exponents(a :: APr_FldPadExact); Max(a :: APr_FldPadExact); Image(a :: APr_FldPadExactElt);

// TODO: implement "Promote(x,y)" which tries to return x and y with the same parent (and IsPromotable(x,y)); the default behaviour should be to 

// freeze;

///# Misc

import "Getter.mag": satisfy_deps_list, satisfy_dep;
import "Promotion.mag": do_binop;

Z := IntegerRing();
Q := RationalField();
OO := Infinity();

UPDATE_CONSISTENCY_CHECK := true; // when true, Update() checks for consistency (STRONGLY RECOMMENDED)

PRIME := 1; // prime p-adic fields Q_p
INERT := 2; // unramified extensions defined by inertial polynomials
EISEN := 3; // totally ramified extensions defined by Eisenstein polynomials
EMBED := 4; // subfields defined by embedding maps
COMPOUND := 5;

CAST := '!';
CAP_PR := _ExactpAdics_CapPrecision;
CAP_APR := _ExactpAdics_CapAbsolutePrecision;
CHANGE_APR := _ExactpAdics_ChangeAbsolutePrecision;
CHANGE_PR := _ExactpAdics_ChangePrecision;
ELTSEQ := Eltseq;
PR := Precision;
APR := AbsolutePrecision;
WVAL := WeakValuation;
VAL := Valuation;
DEG := Degree;
WDEG := WeakDegree;
INC_APR := IncreaseAbsolutePrecision;
INC_APR_Z := IncreaseAbsolutePrecision_Lazy;
APPROX := Approximation;
APPROX_Z := Approximation_Lazy;
WEQ := _ExactpAdics_IsWeaklyEqual;
WZERO := _ExactpAdics_IsWeaklyZero;
IS_VALID_APPROX := _ExactpAdics_IsValidApproximation;
SHIFT_VAL := ShiftValuation;
SHIFT_SLOPE := ShiftSlope;
RES := Resultant;
WRES := WeakResultant;
CHANGE_DPR := _ExactpAdics_ChangeDefaultPrecision;
TRIM_APR := func<x, n | CHANGE_APR(x, APR(x)-n)>;
NEXTID := ExactpAdics_NextId;
IS_PREC_ERR := _ExactpAdics_IsPrecisionError;
PREC_ERR := func<msg | Error("Insufficient precision: " cat msg)>;
IS_INSTANCE := func<x, C | ISA(ExtendedType(x), C)>;
TOWER := _ExactpAdics_Tower;
LAST := func<x | x[#x]>;
function THE(x)
  assert #x eq 1;
  return Rep(x);
end function;
LIST := _ExactpAdics_List;
ZERO := _ExactpAdics_Zero;
SORT := _ExactpAdics_Sort;
function CAPR(x : PrCap:=1)
  return AbsolutePrecision(x) meet (WeakValuation(x) + PrCap);
end function;
BVAL := BaselineValuation;
BPR := BaselinePrecision;
MONOMIAL := _ExactpAdics_Monomial;

// the level of recursion to check in _ExactpAdics_Cast and _ExactpAdics_Eltseq when working in totally ramified extensions; 0 means no checking; recommend 1 or 2 in development
// TOT_RAM_CAST_CHECK := 0;

procedure record_time(~times, ~last_time, label)
  t := Cputime();
  if not assigned times then
    times := AssociativeArray();
  else
    ok, T := IsDefined(times, label);
    dt := t - last_time;
    if ok then
      times[label] := T + dt;
    else
      times[label] := dt;
    end if;
  end if;
  last_time := t;
end procedure;

// UTILITY FUNCTIONS

intrinsic _ExactpAdics_Monomial(R :: RngMPol, e :: [RngIntElt]) -> RngMPolElt
  {The monomial x^e in R.}
  // MAGMA BUG: R.i is cached, so its coefficient may be to a lower precision than the precision of the base ring!
  // this forces the coefficient to be to the full current precision of the base ring
  return Polynomial([BaseRing(R) ! 1], [Monomial(R, e)]);
end intrinsic;

intrinsic _ExactpAdics_Sort(xs) -> .
  {Sort.}
  return Sort(xs);
end intrinsic;

intrinsic _ExactpAdics_Sort(xs :: {}) -> .
  {"}
  return Sort(SetToSequence(xs));
end intrinsic;

intrinsic _ExactpAdics_List(xs) -> List
  {Converts xs to a list.}
  return [*x : x in xs*];
end intrinsic;

intrinsic _ExactpAdics_List(xs :: List) -> List
  {"}
  return xs;
end intrinsic;

intrinsic _ExactpAdics_List(xs :: []) -> List
  {"}
  return SequenceToList(xs);
end intrinsic;

intrinsic _ExactpAdics_List(xs :: Tup) -> List
  {"}
  return TupleToList(xs);
end intrinsic;

intrinsic _ExactpAdics_ChangeDefaultPrecision(F :: FldPad, n :: RngIntElt)
  {Changes the default precision of F to n, and changes the default precisions of its subfields too.}
  while true do
    F`DefaultPrecision := n;
    if IsPrimeField(F) then
      return;
    else
      n := Ceiling(n / RamificationDegree(F));
      F := BaseField(F);
    end if;
  end while;
end intrinsic;

intrinsic _ExactpAdics_ChangeDefaultPrecision(F :: FldPad, n :: Val_FldPadElt)
  {"}
  CHANGE_DPR(F, IntegerValue(n));
end intrinsic;

intrinsic _ExactpAdics_IsValidApproximation(F :: FldPadExact, app :: FldPadElt) -> BoolElt, FldPadElt
  {True if app is a valid approximation to an element of F, and the coerced version.}
  xF := F`approximation_field;
  xF2 := Parent(app);
  pr := Precision(xF2);
  if pr eq OO and xF2 eq xF then
    return true, app;
  elif ChangePrecision(xF, pr) eq xF2 then
    return true, CAST(xF, app);
  end if;
  return false, _;
end intrinsic;

intrinsic _ExactpAdics_IsValidApproximation(R :: RngUPol_FldPadExact, app :: RngUPolElt[FldPad]) -> BoolElt, RngUPolElt
  {True if app is a valid approximation to an element of R, and the coerced version.}
  xR := R`approximation_ring;
  xR2 := Parent(app);
  xF := BaseRing(xR);
  xF2 := BaseRing(xR2);
  pr := Precision(xF2);
  if pr eq OO and xF2 eq xF then
    return true, CAST(xR, app);
  elif ChangePrecision(xF, pr) eq xF2 then
    return true, CAST(xR, app);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyZero(x) -> BoolElt
  {IsWeaklyZero(x).}
  return IsWeaklyZero(x);
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyZero(f :: RngUPolElt[FldPad]) -> BoolElt
  {"}
  return forall{c : c in Coefficients(f) | WZERO(c)};
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyEqual(x, y) -> BoolElt
  {IsWeaklyEqual(x, y).}
  return IsWeaklyEqual(x, y);
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyEqual(x :: FldPadElt, y :: FldPadElt) -> BoolElt
  {"}
  // when the absolute precisions are way different, it can cause an infinite-precision FldPad
  assert Parent(x) eq Parent(y);
  apr := Min(APR(x), APR(y));
  return IsWeaklyEqual(CHANGE_APR(x, apr), CHANGE_APR(y, apr));
end intrinsic;

intrinsic _ExactpAdics_IsWeaklyEqual(x :: RngUPolElt[FldPad], y :: RngUPolElt[FldPad]) -> BoolElt
  {"}
  assert Parent(x) eq Parent(y);
  dx := Degree(x);
  dy := Degree(y);
  d := Min(dx, dy);
  C := Coefficient;
  return forall{i : i in [0..d] | WEQ(C(x,i), C(y,i))} and forall{i : i in [d+1..dx] | WZERO(C(x,i))} and forall{i : i in [d+1..dy] | WZERO(C(y,i))};
end intrinsic;

intrinsic _ExactpAdics_ChangePrecision(x :: FldPadElt, n :: RngIntElt) -> FldPadElt
  {Change the precision of x.}
  require n ge 0: "Argument 2 must be at least 0";
  require not WZERO(x): "Argument 1 must be nonzero";
  if n eq 0 then
    return ZERO(Parent(x), VAL(x));
  else
    return ChangePrecision(x, n);
  end if;
end intrinsic;

intrinsic _ExactpAdics_ChangePrecision(x :: FldPadElt, n :: Infty) -> FldPadElt
  {"}
  assert PR(x) eq n;
  return x;
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(x :: FldPadElt, n :: RngIntElt) -> FldPadElt
  {Change the absolute precision of x.}
  if WZERO(x) then
    return ZERO(Parent(x), n);
  else
    v := VAL(x);
    if n le v then
      return ZERO(Parent(x), n);
    else
      return CHANGE_PR(x, n-v);
    end if;
  end if;
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(x :: FldPadElt, n :: Infty) -> FldPadElt
  {"}
  assert APR(x) eq n;
  return x;
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(x :: FldPadElt, n :: Val_FldPadElt) -> FldPadElt
  {"}
  return CHANGE_APR(x, n`value);
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(f :: RngUPolElt[FldPad], n :: RngIntElt) -> RngUPolElt
  {"}
  return Parent(f) ! [CHANGE_APR(c, n) : c in Coefficients(f)];
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(f :: RngUPolElt[FldPad], n :: Infty) -> RngUPolElt
  {"}
  return Parent(f) ! [CHANGE_APR(c, n) : c in Coefficients(f)];
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(f :: RngUPolElt[FldPad], n :: []) -> RngUPolElt
  {"}
  assert #n ge Degree(f)+1;
  return Parent(f) ! [CHANGE_APR(Coefficient(f,i), n[i+1]) : i in [0..Degree(f)]];
end intrinsic;

intrinsic _ExactpAdics_ChangeAbsolutePrecision(f :: RngUPolElt[FldPad], n :: Val_RngUPolElt_FldPad) -> RngUPolElt
  {"}
  return Parent(f) ! [CHANGE_APR(Coefficient(f,i), n(i)) : i in [0..Degree(f)]];
end intrinsic;

intrinsic _ExactpAdics_Zero(K :: FldPad, n :: RngIntElt) -> FldPadElt
  {Zero to absolute precision n.}
  x := CHANGE_PR(SHIFT_VAL(K!1, n-1), 1);
  z := x - x;
  assert APR(z) eq n;
  assert WZERO(z);
  return z;
end intrinsic;

intrinsic _ExactpAdics_Zero(K :: FldPad, n :: Infty) -> FldPadElt
  {"}
  assert n eq OO;
  return K ! 0;
end intrinsic;

intrinsic _ExactpAdics_CapPrecision(x :: FldPadElt, pr) -> FldPadElt
  {Caps the precision of x.}
  y := (PR(x) le pr) select x else CHANGE_PR(x, pr);
  assert PR(y) le pr;
  return y;
end intrinsic;

intrinsic _ExactpAdics_CapPrecision(f :: RngUPolElt[FldPad], pr) -> RngUPolElt
  {"}
  return Parent(f) ! [CAP_PR(c,pr) : c in Coefficients(f)];
end intrinsic;

VAL_FLDPADELT_MIN := Val_FldPadElt_Make(-99999);

intrinsic _ExactpAdics_CapAbsolutePrecision(x :: FldPadElt, apr) -> FldPadElt
  {Caps the absolute precision of x.}
  // <HACK>
  // you can't make a FldPadElt with valuation -OO
  apr join:= VAL_FLDPADELT_MIN;
  // </HACK>
  y := (APR(x) le apr) select x else CHANGE_APR(x, apr);
  assert APR(y) le apr;
  return y;
end intrinsic;

intrinsic _ExactpAdics_IsPrecisionError(e :: Err) -> BoolElt
  {True if e looks like a precision error.}
  x := e`Object;
  if (Type(x) eq MonStgElt) and (("Insufficient precision" in x) or ("Field 'res_fact' is not assigned" in x) or ("valuation overflow in mult" in x) or ("List of factors must have length >= 2" in x) or ("Could not find the correct factor" in x) or ("Field 'f' is not assigned" in x)) then
    return true;
  end if;
  if (assigned e`Position) and (("assert &and[Degree(fact[j][1]) eq Degree(Phi) div cert[i]" in e`Position) or ("assert 2*Valuation(Discriminant(Pi_new`chi)) lt Precision" in e`Position)) then
    return true;
  end if;
  return false;
end intrinsic;

intrinsic _ExactpAdics_Tower(L :: FldPad, K :: FldPad) -> SeqEnum
  {The tower of extensions from K up to L.}
  tower := [L];
  while tower[1] ne K do
    Insert(~tower, 1, BaseField(tower[1]));
  end while;
  return tower;
end intrinsic;


// TYPE DECLARATIONS
///# Types

declare type FldPadExact[FldPadExactElt];
declare attributes FldPadExact
  : type                               // PRIME, INERT, EISEN or EMBED
  , id                                 // NEXTID()
  , defining_polynomial                // DefiningPolynomial(*)
  , defining_embedding                 // 
  , approximation_field                // FldPad approximating this
  // CACHE
  , embeddings                         // automatic embeddings of other rings/fields
  , subfield_data                      // [id] -> data about subfield with id
  , varname                            // generator name
  , prime                              // Prime(*)
  , base_field                         // BaseField(*)
  , prime_field                        // PrimeField(*)
  , zero                               // Zero(*)
  , one                                // One(*)
  , uniformizing_element               // UniformizingElement(*)
  , generator                          // Generator(*)
  , polynomial_ring                    // PolynomialRing(*)
  , polynomial_ring_m                  // [n] -> PolynomialRing(*,n)
  , degree                             // Degree(*)
  , ramification_degree                // RamificationDegree(*)
  , inertia_degree                     // InertiaDegree(*)
  , absolute_degree                    // AbsoluteDegree(*)
  , absolute_ramification_degree       // AbsoluteRamificationDegree(*)
  , absolute_inertia_degree            // AbsoluteInertiaDegree(*)
  , residue_class_field                // ResidueClassField(*)
  , integers                           // Integers(*)
  , transition_function                // TransitionFunction(*)
  , inertia_generator                  // InertiaGenerator(*)
  , primitive_element                  // PrimitiveElement(*)
  , temporary                          // Temporary(*)
  ;

declare type FldPadExactElt;
declare attributes FldPadExactElt
  : parent                          // parent field
  , id                              // NEXTID()
  , data                            // element-specific data, used/modified by update
  , approximation                   // the approximation
  , update                          // the update function
  , baseline_valuation              // wrt which baseline precision is computed
  // CACHE
  , residue_class                   // ResidueClass(*)
  , valuation                       // Valuation(*)
  , negation                        // '-'(*)
  , coefficient                     // [i] -> Coefficient(*,i)
  , coefficients                    // Eltseq(*), Coefficients(*)
  , temporary                       // Temporary(*)
  , power                           // [n] -> '^'(*,n)
  ;

declare type RngUPol_FldPadExact[RngUPolElt_FldPadExact];
declare attributes RngUPol_FldPadExact
  : base_ring                       // BaseRing(*)
  , id                              // NEXTID()
  , approximation_ring              // RngUPol[FldPad] approximating this
  , varname                         // printing name of the variable
  // CACHE
  , generator                       // Generator(*)
  ;

declare type RngUPolElt_FldPadExact;
declare attributes RngUPolElt_FldPadExact
  : parent               // Parent(*)
  , id                   // NEXTID()
  , approximation        // approximation polynomial
  , update               // update function
  , data                 // element-specific data, used/modified by update function
  , baseline_valuation   // wrt which baseline precision is computed
  // CACHE
  , weak_coefficients    // WeakCoefficients(*)
  , coefficient          // [i] -> Coefficient(*,i)
  , degree               // Degree(*)
  , is_eisenstein        // IsEisenstein(*)
  , is_inertial          // IsInertial(*)
  , coefficients         // Coefficients(*)
  , base_ring            // BaseRing(*)
  , discriminant         // Discriminant(*)
  , valuation            // Valuation(*)
  , leading_coefficient  // LeadingCoefficient(*)
  , is_integral          // IsIntegral(*)
  , derivative           // [i] -> Derivative(*,i)
  , roots                // Roots(*)
  , npfactorization      // [r] -> NewtonPolygonFactorization(* : Residual:=r)
  , factorization        // data for Factorization(* : ...)
  , newton_polygon       // NewtonPolygon(*)
  , ramification_polygon // RamificationPolygon(*)
  , is_irreducible       // IsIrreducible(*)
  , residual_polynomial  // [face] -> ResidualPolynomial(*, face)
  , residual_polynomials // ResidualPolynomials(*)
  , splitting_field      // SplittingField(*)
  , galois_group         // GaloisGroup(*)
  , ramification_residual_polynomial // [face] -> RamificationResidualPolynomial(*, face)
  , greve_field          // GreveField(*)
  , factorization_doris  // data for Factorization_Doris(* : ...)
  , is_irreducible_doris // IsIrreducible_Doris(*)
  , negation             // '-'(*)
  , min_valuation        // MinValuation(*)
  , powers               // [n] -> '^'(*,n)
  ;

declare type RngPadExact[RngPadExactElt];
declare attributes RngPadExact
  : id
  , data
  , field_of_fractions
  , radius
  ;

declare type RngPadExactElt;
declare attributes RngPadExactElt
  : id
  , parent
  , field_element
  ;

declare type HassHerbTransFunc;
declare attributes HassHerbTransFunc
  : degree                 // REQ: the degree of the extension
  , vertices               // REQ: the coordinates of the breaks
  , ramification_polygon   // RamificationPolygon(*)
  ;

declare type ExtDataFldPadExact;
declare attributes ExtDataFldPadExact
  : top_field             // REQ: the top field
  , base_field            // REQ: the base field
  , type                  // REQ: INERT, EISEN, EMBED or COMPOUND
  , list                  // REQ (COMPOUND)
  , degree                // Degree(*)
  , inertia_degree        // InertiaDegree(*)
  , ramification_degree   // RamificationDegree(*)
  , transition_function   // TransitionFunction(*)
  , ramification_polygon  // RamificationPolygon(*)
  , primitive_element     // PrimitiveElement(*)
  , flatten               // Flatten(*)
  , is_in_standard_form   // IsInStandardForm(*)
  , standard_form         // StandardForm(*)
  , discriminant_valuation // DiscriminantValuation(*)
  , describe_extension    // DescribeExtension(*)
  ;

declare type TmpFldPadExact[TmpFldPadExactElt];
declare attributes TmpFldPadExact
  : field                   // the field being approximated
  ;

declare type TmpFldPadExactElt;
declare attributes TmpFldPadExactElt
  : parent
  , get_approximation
  ;

declare type HomFldPadExact;
declare attributes HomFldPadExact
  : xdomain                // REQ: the domain E1/F as an extension of the base field F
  , xcodomain              // REQ: the codomain E2/F as an extension of the base field F
  , generator_images       // REQ: list of images (in E2) of generators of each subfield in E1/F
  , basis_images           // images of the standard basis of E1/F (derived from generator_images)
  , inverse                // Inverse(*) (if invertible)
  ;

///# Exact p-adic fields

procedure add_embedding(F, emb)
  if not assigned F`embeddings then
    F`embeddings := [* emb *];
  else
    Append(~F`embeddings, emb);
  end if;
end procedure;

///## Creation of fields

///### Prime fields

intrinsic ExactpAdicField(p :: RngIntElt) -> FldPadExact
  {The exact p-adic field.}
  require (p gt 0) and IsPrime(p): "p must be prime";
  F := New(FldPadExact);
  F`id := NEXTID();
  F`type := PRIME;
  F`prime := p;
  F`approximation_field := pAdicField(p);
  return F;
end intrinsic;

///## Basic operations on fields

///### Basic invariants

intrinsic Prime(F :: FldPadExact) -> RngIntElt
  {The p in p-adic.}
  if not assigned F`prime then
    F`prime := Prime(BaseField(F));
  end if;
  return F`prime;
end intrinsic;

intrinsic IsPrimeField(F :: FldPadExact) -> BoolElt
  {True if F is a prime p-adic field.}
  return (F`type eq PRIME) or (F`type eq EMBED and IsPrimeField(Domain(F`defining_embedding)));
end intrinsic;

intrinsic PrimeField(F :: FldPadExact) -> BoolElt
  {The prime field of F.}
  if not assigned F`prime_field then
    F`prime_field := IsPrimeField(F) select F else PrimeField(BaseField(F));
  end if;
  return F`prime_field;
end intrinsic;

intrinsic Print(F :: FldPadExact, lvl :: MonStgElt)
  {Print.}
  case lvl:
  when "Magma":
    case F`type:
    when PRIME:
      printf "ExactpAdicField(%m)", Prime(F);
    when INERT:
      printf "UnramifiedExtension(%m)", DefiningPolynomial(F);
    when EISEN:
      printf "TotallyRamifiedExtension(%m)", DefiningPolynomial(F);
    when EMBED:
      error "Image(%m)", F`defining_embedding;
    else
      error "not implemented";
    end case;
  else
    printf "%o", DescribeExtension(F, PrimeField(F) : BaseName:=Sprintf("Exact %o-adic field", Prime(F)));
  end case;
end intrinsic;

intrinsic Print(x :: FldPadExactElt, lvl :: MonStgElt)
  {"}
  case lvl:
  when "Magma":
    printf "%o", Format(x : APr := APR(x));
  else
    printf "%o", Format(x : APr := CAPR(x));
  end case;
end intrinsic;

intrinsic Parent(x :: FldPadExactElt) -> FldPadExact
  {The field containing x.}
  return x`parent;
end intrinsic;

// function parse_apr(x : APr:=false, Pr:=false, Weak:=false, PrForce:=false)
//   v := WeakValuation(x);
//   apr := AbsolutePrecision(x);
//   pr := Precision(x);
//   case Type(APr):
//   when RngIntElt, Infty, ExtReElt:
//     ;
//   when BoolElt:
//     case Type(Pr):
//     when RngIntElt, Infty, ExtReElt:
//       if PrForce then
//         APr := v + Pr;
//       elif WZERO(x) then
//         APr := v;
//       else
//         APr := v + Pr;
//       end if;
//     when BoolElt:
//       APr := apr;
//     else
//       error "bad Pr";
//     end case;
//   else
//     error "bad APr";
//   end case;
//   if Weak then
//     APr := Min(apr, APr);
//   end if;
//   return APr;
// end function;

// function parse_apr_poly(f : APr:=false, Pr:=false, PrForce:=false, MinPr:=false, Weak:=false)
//   d := WeakDegree(f);
//   // APr, Pr and PrForce
//   case Type(APr):
//   when RngIntElt, Infty, ExtReElt:
//     APr := [APr : i in [0..d]];
//   when SeqEnum:
//     APr := APr[1..d+1];
//   when BoolElt:
//     case Type(Pr):
//     when RngIntElt, Infty, ExtReElt:
//       APr := [(PrForce or not WZERO(c)) select Valuation(c)+Pr else Valuation(c) : c in Coefficients(f`approximation)];
//     when SeqEnum:
//       APr := [((PrForce or not WZERO(c)) select Valuation(c)+Pr[i+1] else Valuation(c)) where c := Coefficient(f`approximation, i) : i in [0..d]];
//     when BoolElt:
//       APr := [AbsolutePrecision(c) : c in Coefficients(f`approximation)];
//     else
//       error "bad Pr";
//     end case;
//   else
//     error "bad APr";
//   end case;
//   // MinPr
//   case Type(MinPr):
//   when BoolElt:
//     ;
//   when RngIntElt, Infty, ExtReElt:
//     APr := [Max(APr[i], Valuation(Coefficient(f`approximation, i-1))+MinPr) : i in [1..#APr]];
//   when SeqEnum:
//     APr := [Max(APr[i], Valuation(Coefficient(f`approximation, i-1))+MinPr[i]) : i in [1..#APr]];
//   end case;
//   // Weak
//   if Weak then
//     APr := [Min(APr[i+1], AbsolutePrecision(Coefficient(f`approximation, i))) : i in [0..d]];
//   end if;
//   return APr;
// end function;

intrinsic PrecisionRequired(x :: FldPadExactElt, apr) -> RngIntElt
  {(A bound on) the precision required in the parent field of x to approximate x to the given absolute precision.}
  return Max(1, Ceiling(Value(apr - WVAL(x))));
end intrinsic;

intrinsic PrecisionRequired(f :: RngUPolElt_FldPadExact, apr) -> RngIntElt
  {The precision required to approximate f with the given parameters.}
  return Max(1, Ceiling(Value(&join(apr - WVAL(f)))));
end intrinsic;

intrinsic Approximation_Lazy(x :: FldPadExactElt, apr : Quick:=false, FixPr:=true) -> ExactpAdics_Gettr
  {An approximation to x.}
  ok, apr := IsValidAbsolutePrecisionDiff(x, apr);
  require ok: "Argument 2: " cat apr;
  pr := PrecisionRequired(x, apr);
  iapF := IncreaseAbsolutePrecision_Lazy(Parent(x), pr);
  return iapF mod function (ig)
    iap := IncreaseAbsolutePrecision_Lazy(x, apr);
    return iap mod function (ig)
      y := (Quick or apr`value eq OO) select x`approximation else CAP_APR(x`approximation, apr);
      if FixPr then
        y := ChangePrecision(Parent(y), Max(1, pr)) ! y;
      end if;
      assert apr le APR(y);
      return y;
    end function;
  end function;
end intrinsic;

intrinsic Approximation(x :: FldPadExactElt, apr : Quick:=false, FixPr:=true) -> FldPadElt
  {An approximation to x.}
  return Evaluate(Approximation_Lazy(x, apr : Quick:=Quick, FixPr:=FixPr));
end intrinsic;

intrinsic IncreaseAbsolutePrecision_Lazy(F :: FldPadExact, pr :: RngIntElt) -> ExactpAdics_Gettr
  {Getter which, when evaluated, the approximation field of F has at least precision pr.}
  pr := Max(pr, 1);
  case F`type:
  when PRIME:
    return ExactpAdics_ConstGetter(true);
  when INERT:
    return IncreaseAbsolutePrecision_Lazy(F`defining_polynomial, pr);
  when EISEN:
    d := Degree(F);
    // BUG: +2 because Magma has precision errors in Eisenstein extensions
    return IncreaseAbsolutePrecision_Lazy(F`defining_polynomial, Ceiling(pr / d) + 2*AbsoluteRamificationDegree(BaseField(F)));
  else
    error "not implemented";
  end case;
end intrinsic;

intrinsic Approximation_Lazy(F :: FldPadExact, pr) -> ExactpAdics_Gettr
  {The approximating field of F with default precision pr.}
  case Type(pr):
  when RngIntElt:
    ;
  when FldRatElt:
    ok, pr := IsCoercible(Z, pr);
    require ok: "pr must be an integer";
  when Val_FldPadElt:
    ok, pr := IsCoercible(Z, pr`value);
    require ok: "pr must be an integer";
  else
    error "pr must be an integer";
  end case;
  require pr gt 0: "pr must be positive";
  return IncreaseAbsolutePrecision_Lazy(F, pr) mod function (ig)
    xF := F`approximation_field;
    CHANGE_DPR(xF, pr);
    return xF;
  end function;
end intrinsic;

intrinsic Approximation(F :: FldPadExact, pr :: RngIntElt) -> FldPad
  {"}
  return Evaluate(Approximation_Lazy(F, pr));
end intrinsic;

intrinsic Approximation(F :: FldPadExact) -> FldPad
  {The approximating field.}
  return F`approximation_field;
end intrinsic;

intrinsic IncreaseAbsolutePrecision(x :: FldPadExactElt, n)
  {Increases the absolute precision of x to n.}
  satisfy_dep(x, n);
end intrinsic;

intrinsic IncreaseAbsolutePrecision_Lazy(x :: FldPadExactElt, n) -> ExactpAdics_Gettr
  {"}
  ok, n := IsValidAbsolutePrecisionDiff(x, n);
  if not ok then
    error "invalid n";
  end if;
  return ExactpAdics_Getter(false,
    procedure (~st, ~deps)
      deps := [*[*x,n*]*];
    end procedure,
    procedure (~st, ~val)
      assert n le APR(x);
      val := true;
    end procedure);
end intrinsic;

intrinsic AbsolutePrecision(x :: FldPadExactElt) -> RngIntElt
  {The absolute precision of x.}
  return Val_FldPadElt_Make(APR(x`approximation));
end intrinsic;

intrinsic Precision(x :: FldPadExactElt) -> RngIntElt
  {The precision of x.}
  return APR(x) - WVAL(x);
  // return Val_FldPadElt_Make(PR(x`approximation));
end intrinsic;

intrinsic WeakValuation(x :: FldPadExactElt) -> RngIntElt
  {The weak valuation of x.}
  return Val_FldPadElt_Make(VAL(x`approximation));
end intrinsic;

function is_coercible_from_embeddings(F, X)
  if assigned F`embeddings then
    for emb in F`embeddings do
      ok, X0 := IsCoercible(Domain(emb), X);
      if ok then
        return true, emb(X0);
      end if;
    end for;
  end if;
  return false, _;
end function;

function is_coercible_from_basefield(F, X)
  if not IsPrimeField(F) then
    F0 := BaseField(F);
    ok, X0 := IsCoercible(F0, X);
    if ok then
      return true, CAST(F, [X0]);
    end if;
  end if;
  return false, _;
end function;

intrinsic IsCoercible(F :: FldPadExact, X) -> BoolElt, .
  {True if X is coercible to an element of F, and the coerced element.}
  ok, x := is_coercible_from_embeddings(F, X);
  if ok then
    return true, x;
  end if;
  ok, x := is_coercible_from_basefield(F, X);
  if ok then
    return true, x;
  end if;
  return false, "not coercible";
end intrinsic;

function makeElt(F, init, mkupdate)
  x := New(FldPadExactElt);
  x`parent := F;
  case Type(mkupdate):
  when UserProgram:
    x`update := mkupdate(x);
  when BoolElt:
    ;
  else
    return false, "bad mkupdate";
  end case;
  x`id := NEXTID();
  case Type(init):
  when FldPadElt:
    ok, init := IS_VALID_APPROX(F, init);
    if ok then
      x`approximation := init;
    else
      return false, "wrong field";
    end if;
  when RngIntElt:
    IncreaseAbsolutePrecision(x, init);
  else
    return false, "bad init";
  end case;
  SetBaselineValuation(x, WeakValuation(x));
  return true, x;
end function;

intrinsic IsCoercible(F :: FldPadExact, X :: Tup) -> BoolElt, .
  {"}
  case #X:
  when 2:
    return makeElt(F, X[1], X[2]);
  when 3:
    ok, x := makeElt(F, X[1], X[2]);
    if ok then
      SetData(x, X[3]);
      return true, x;
    else
      return false, x;
    end if;
  end case;
  return false, "not coercible";
end intrinsic;

function _fromRational(F, X)
  if X eq 0 then
    xF := Approximation(F);
    init := xF ! X;
    mkupdate := func<z | func<apr | true>>;
    return F ! <init, mkupdate>;
  else
    e := AbsoluteRamificationDegree(F);
    p := Prime(F);
    v := e * Valuation(X, p);
    FUDGE := e gt 1 select 2*e else 0;
    xF := Approximation(F, 1+FUDGE);
    init := CAP_PR(CAST(xF, X), 1);
    assert WVAL(init) eq v;
    mkupdate := func<z | function (apr)
      pr := Max(Z!apr`value - v, 1) + FUDGE;
      return Approximation_Lazy(F, pr) mod function (xF)
        loc_FUDGE := FUDGE;
        loc_init := init;
        loc_apr := apr;
        loc_X := X;
        loc_z := z;
        loc_pr := pr;
        Update(z, CAP_APR(CAST(xF, X), apr));
        return true;
      end function;
    end function>;
    return F ! <init, mkupdate>;
  end if;
end function;

function fromRational(F, X)
  if X eq 0 then
    if not assigned F`zero then
      F`zero := _fromRational(F, 0);
    end if;
    return F`zero;
  elif X eq 1 then
    if not assigned F`one then
      F`one := _fromRational(F, 1);
    end if;
    return F`one;
  elif X eq Prime(F) and AbsoluteRamificationDegree(F) eq 1 then
    if not assigned F`uniformizing_element then
      F`uniformizing_element := _fromRational(F, Prime(F));
    end if;
    return F`uniformizing_element;
  else
    return _fromRational(F, X);
  end if;
end function;

intrinsic IsCoercible(F :: FldPadExact, X :: RngIntElt) -> BoolElt, .
  {"}
  return true, fromRational(F, X);
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: FldRatElt) -> BoolElt, .
  {"}
  return true, fromRational(F, X);
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: FldPadExactElt) -> BoolElt, .
  {"}
  if F eq Parent(X) then
    return true, X;
  end if;
  ok, x := is_coercible_from_basefield(F, X);
  if ok then
    return true, x;
  end if;
  return false, "not coercible";
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: []) -> BoolElt, .
  {"}
  require not IsPrimeField(F): "F must be an extension";
  F0 := BaseField(F);
  ok, X := CanChangeUniverse(X, F0);
  if ok then
    case F`type:
    when INERT:
      xF := Approximation(F, 1);
      init := CAST(xF, [Approximation(x, CAPR(x)) : x in X]);
      mkupdate := func<z | function (apr)
        pr := apr - WeakValuation(z);
        return Approximation_Lazy(F, pr) mod function (xF)
          return &cat[Approximation_Lazy(x, apr) : x in X] mod function (xxs)
            Update(z, CAST(xF, xxs));
            return true;
          end function;
        end function;
      end function>;
    when EISEN:
      FUDGE := AbsoluteRamificationDegree(F);
      FUDGE0 := AbsoluteRamificationDegree(F0);
      xF := Approximation(F, 1+FUDGE);
      init := TRIM_APR(CAST(xF, [Approximation(x, CAPR(x : PrCap:=1+FUDGE0)) : x in X]), FUDGE);
      d := Degree(F);
      mkupdate := func<z | function (apr)
        pr := apr - WeakValuation(z);
        return Approximation_Lazy(F, pr+FUDGE) mod function (xF)
          return &cat[Approximation_Lazy(X[i], Ceiling((apr+FUDGE-i+1)/d)) : i in [1..#X]] mod function (xxs)
            loc_z := z;
            loc_apr := apr;
            loc_pr := pr;
            loc_FUDGE := FUDGE;
            loc_xF := xF;
            CHANGE_DPR(xF, pr+FUDGE);
            Update(z, CAP_APR(CAST(xF, xxs), apr));
            return true;
          end function;
        end function;
      end function>;
    when PRIME:
      assert false;
    else
      error "not implemented";
    end case;
    x := F ! <init, mkupdate>;
    // x`coefficients := X;
    return true, x;
  end if;
  return false, "cannot coerce coefficients to the base field";
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: RngPadExactElt) -> BoolElt, .
  {"}
  return IsCoercible(F, X`field_element);
end intrinsic;

intrinsic IsCoercible(F :: FldPadExact, X :: FldPadElt) -> BoolElt, .
  {"}
  ok, app := IS_VALID_APPROX(F, X);
  if ok then
    return true, F ! <app, func<z | function (apr)
      error "cannot increase precision of approximate p-adics";
    end function>>;
  end if;
  return false, "wrong field";
end intrinsic;

intrinsic 'eq'(F :: FldPadExact, E :: FldPadExact) -> BoolElt
  {Equality.}
  return F`id eq E`id;
end intrinsic;

// intrinsic Update(x :: FldPadExactElt, y :: FldPadExactElt)
//   {Updates x to the weak value of y.}
//   F := Parent(x);
//   require F eq Parent(y): "x and y must belong to the same field";
//   renewEltApproximation(x);
//   renewEltApproximation(y);
//   require WEQ(x`approximation, y`approximation): "inconsistent";
//   x`approximation := y`approximation;
// end intrinsic;

intrinsic Update(x :: FldPadExactElt, app :: FldPadElt)
  {Updates x to app.}
  F := x`parent;
  ok, app := IS_VALID_APPROX(F, app);
  require ok: "app is in the wrong field";
  if UPDATE_CONSISTENCY_CHECK then
    require WEQ(x`approximation, app): "inconsistent";
  end if;
  if AbsolutePrecision(app) gt AbsolutePrecision(x`approximation) then
    x`approximation := app;
  end if;
end intrinsic;

intrinsic UpdateZero(x :: FldPadExactElt, apr :: RngIntElt)
  {Updates x to O(pi^apr).}
  Update(x, Zero(x`parent`approximation_field, apr));
end intrinsic;

intrinsic IsExtensionOf(E :: FldPadExact, F :: FldPadExact) -> BoolElt, ExtDataFldPadExact
  {True if E is an extension of F. If so, also returns an object representing the extension.}
  // check if already cached
  if not assigned E`subfield_data then
    E`subfield_data := AssociativeArray();
  end if;
  ok, x := IsDefined(E`subfield_data, F`id);
  if ok then
    return true, x;
  end if;
  // E = F
  if E eq F then
    x := New(ExtDataFldPadExact);
    x`top_field := E;
    x`base_field := F;
    x`type := COMPOUND;
    x`list := [];
    E`subfield_data[F`id] := x;
    return true, x;
  end if;
  // consider base field E0 of E
  if not IsPrimeField(E) then
    E0 := BaseField(E);
    // E0 = F
    if E0 eq F then
      x := New(ExtDataFldPadExact);
      x`top_field := E;
      x`base_field := F;
      x`type := deep_type(E) where deep_type := function (E)
        while E`type eq EMBED do
          E := Domain(E`defining_embedding);
        end while;
        return E`type;
      end function;
      E`subfield_data[F`id] := x;
      return true, x;
    end if;
    // E0 / F
    ok, x0 := IsExtensionOf(E0, F);
    if ok then
      ok, x1 := IsExtensionOf(E, E0);
      assert ok;
      x := New(ExtDataFldPadExact);
      x`top_field := E;
      x`base_field := F;
      x`type := COMPOUND;
      x`list := [x0, x1];
      E`subfield_data[F`id] := x;
      return true, x;
    end if;
  end if;
  // F -> E
  if F`type eq EMBED and Codomain(F`defining_embedding) eq E then
    x := New(ExtDataFldPadExact);
    x`top_field := E;
    x`base_field := F;
    x`type := EMBED;
    E`subfield_data[F`id] := x;
    return true, x;
  end if;
  // false
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: FldPadExact, F :: FldPadExact) -> BoolElt, .
  {True if there is a structure containing E and F, and the common structure.}
  if E eq F then
    return true, E;
  elif IsExtensionOf(E, F) then
    return true, E;
  elif IsExtensionOf(F, E) then
    return true, F;
  else
    return false, _;
  end if;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: FldPadExact, F :: RngInt) -> BoolElt, .
  {"}
  return true, E;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: RngInt, F :: FldPadExact) -> BoolElt, .
  {"}
  return true, F;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: FldPadExact, F :: FldRat) -> BoolElt, .
  {"}
  return true, E;
end intrinsic;

intrinsic ExistsCoveringStructure(E :: FldRat, F :: FldPadExact) -> BoolElt, .
  {"}
  return true, F;
end intrinsic;

intrinsic ExtConstructor(E :: FldPadExact, t :: Tup) -> FldPadExact
  {The extension of E defined by t.}
  case #t:
  when 1:
    if Type(t[1]) eq RngIntElt then
      return UnramifiedExtension(E, t[1]);
    end if;
    ok, f := IsCoercible(PolynomialRing(E), t[1]);
    if IsInertial(f) then
      return UnramifiedExtension(f);
    elif IsEisenstein(f) then
      return TotallyRamifiedExtension(f);
    end if;
  end case;
  error "RHS must be an integer or coercible to an inertial or Eisenstein polynomial";
end intrinsic;

intrinsic '+'(x :: FldPadExactElt) -> FldPadExactElt
  {Unary addition.}
  return x;
end intrinsic;

intrinsic '+'(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {"}
  return f;
end intrinsic;

intrinsic IsDefinitelyZero(x :: FldPadExactElt) -> BoolElt
  {True if x is precisely zero.}
  return WZERO(x) and AbsolutePrecision(x) eq OO;
end intrinsic;

intrinsic IsDefinitelyZero(f :: RngUPolElt_FldPadExact) -> BoolElt
  {True if f is precisely zero.}
  return WZERO(f) and AbsolutePrecision(f) eq OO;
end intrinsic;

intrinsic '&+'(xs :: [FldPadExactElt]) -> FldPadExactElt
  {Addition reduction.}
  F := Universe(xs);
  xs := [F | x : x in xs | not IsDefinitelyZero(x)];
  if #xs eq 0 then
    return CAST(F, 0);
  elif #xs eq 1 then
    return xs[1];
  else
    init := &+[Approximation(x, CAPR(x)) : x in xs];
    mkupdate := func<z | function (apr)
      return &cat[Approximation_Lazy(x, apr) : x in xs] mod function (xxs)
        Update(z, &+xxs);
        return true;
      end function;
    end function>;
    return F ! <init, mkupdate>;
  end if;
end intrinsic;

intrinsic '&+'(fs :: [RngUPolElt_FldPadExact]) -> RngUPolElt_FldPadExact
  {"}
  R := Universe(fs);
  fs := [R | f : f in fs | not IsDefinitelyZero(f)];
  if #fs eq 0 then
    return CAST(R, 0);
  elif #fs eq 1 then
    return fs[1];
  else
    init := &+[Approximation(f, CAPR(f)) : f in fs];
    mkupdate := func<z | function (apr)
      return &cat[Approximation_Lazy(f, apr) : f in fs] mod function (xfs)
        Update(z, &+xfs);
        return true;
      end function;
    end function>;
    return R ! <init, mkupdate>;
  end if;
end intrinsic;

intrinsic '+'(x :: FldPadExactElt, y :: FldPadExactElt) -> FldPadExactElt
  {Addition.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must come from the same field";
  return &+[F | x, y];
end intrinsic;

intrinsic '+'(x :: FldPadExactElt, y) -> .
  {"}
  return do_binop('+', x, y);
end intrinsic;

intrinsic '+'(x, y :: FldPadExactElt) -> .
  {"}
  return do_binop('+', x, y);
end intrinsic;

intrinsic '+'(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {"}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must come from the same ring";
  return &+[R | f, g];
end intrinsic;

intrinsic '+'(f :: RngUPolElt_FldPadExact, g) -> .
  {"}
  return do_binop('+', f, g);
end intrinsic;

intrinsic '+'(f, g :: RngUPolElt_FldPadExact) -> .
  {"}
  return do_binop('+', f, g);
end intrinsic;

intrinsic '-'(x :: FldPadExactElt) -> FldPadExactElt
  {Negation.}
  if not assigned x`negation then
    if IsDefinitelyZero(x) then
      x`negation := x;
    else
      F := Parent(x);
      init := -Approximation(x, CAPR(x));
      mkupdate := func<z | function (apr)
        return Approximation_Lazy(x, apr) mod function (xx)
          Update(z, -xx);
          return true;
        end function;
      end function>;
      x`negation := F ! <init, mkupdate>;
      x`negation`negation := x;
    end if;
  end if;
  return x`negation;
end intrinsic;

intrinsic '-'(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {"}
  if not assigned f`negation then
    if IsDefinitelyZero(f) then
      f`negation := f;
    else
      R := Parent(f);
      init := -Approximation(f, CAPR(f));
      mkupdate := func<z | function (apr)
        return Approximation_Lazy(f, apr) mod function (xf)
          Update(z, -xf);
          return true;
        end function;
      end function>;
      f`negation := R ! <init, mkupdate>;
      f`negation`negation := f;
    end if;
  end if;
  return f`negation;
end intrinsic;

intrinsic '-'(x :: FldPadExactElt, y :: FldPadExactElt) -> FldPadExactElt
  {Subtraction.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must be from the same field";
  x := CAST(F, x);
  y := CAST(F, y);
  if IsDefinitelyZero(y) then
    return CAST(F, x);
  elif IsDefinitelyZero(x) then
    return CAST(F, -y);
  else
    init := Approximation(x, CAPR(x)) - Approximation(y, CAPR(x));
    mkupdate := func<z | function (apr)
      return [Approximation_Lazy(t, apr) : t in [x,y]]
      mod function (xx, xy)
        Update(z, xx - xy);
        return true;
      end function;
    end function>;
    return F ! <init, mkupdate>;
  end if;
end intrinsic;

intrinsic '-'(x :: FldPadExactElt, y) -> .
  {"}
  return do_binop('-', x, y);
end intrinsic;

intrinsic '-'(x, y :: FldPadExactElt) -> .
  {"}
  return do_binop('-', x, y);
end intrinsic;

intrinsic '-'(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {"}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be from the same ring";
  f := CAST(R, f);
  g := CAST(R, g);
  if IsDefinitelyZero(g) then
    return CAST(R, f);
  elif IsDefinitelyZero(f) then
    return CAST(R, -g);
  else
    init := Approximation(f, CAPR(f)) - Approximation(g, CAPR(g));
    mkupdate := func<z | function (apr)
      return [Approximation_Lazy(t, apr) : t in [f,g]]
      mod function (xf, xg)
        Update(z, xf-xg);
        return true;
      end function;
    end function>;
    return R ! <init, mkupdate>;
  end if;
end intrinsic;

intrinsic '-'(x :: RngUPolElt_FldPadExact, y) -> .
  {"}
  return do_binop('-', x, y);
end intrinsic;

intrinsic '-'(x, y :: RngUPolElt_FldPadExact) -> .
  {"}
  return do_binop('-', x, y);
end intrinsic;

intrinsic '/'(x :: FldPadExactElt, y :: FldPadExactElt : Strategy:="default") -> FldPadExactElt
  {Division.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must come from the same field";
  x := CAST(F, x);
  y := CAST(F, y);
  if IsDefinitelyZero(y) then
    error "division by zero";
  elif IsWeaklyZero(y : Strategy:=Strategy) then
    error "division by weak zero";
  elif IsDefinitelyZero(x) then
    return x;
  else
    vy := Valuation(y : Strategy:=Strategy);
    init := Approximation(x, CAPR(x)) / Approximation(y, vy+1);
    mkupdate := func<z | function (apr)
      vx := WeakValuation(x);
      pr := apr - (vx - vy);
      return [Approximation_Lazy(x, vx+pr), Approximation_Lazy(y, vy+pr)]
      mod function (xx, xy)
        Update(z, xx / xy);
        return true;
      end function;
    end function>;
    return F ! <init, mkupdate>;
  end if;
end intrinsic;

intrinsic '/'(x :: FldPadExactElt, y) -> .
  {"}
  return do_binop('/', x, y);
end intrinsic;

intrinsic '/'(x, y :: FldPadExactElt) -> .
  {"}
  return do_binop('/', x, y);
end intrinsic;

intrinsic '^'(x :: FldPadExactElt, n :: RngIntElt : Strategy:="default") -> FldPadExactElt
  {Powering.}
  // TODO: bound the n which get cached?
  F := Parent(x);
  if n eq 0 then
    return CAST(F, 1);
  elif n eq 1 then
    return x;
  end if;
  if not assigned x`power then
    x`power := AssociativeArray();
  end if;
  ok, xn := IsDefined(x`power, n);
  if not ok then
    if n gt 0 then
      if IsDefinitelyZero(x) then
        xn := x;
      else
        FUDGE := e gt 1 select 2*e else 0 where e := AbsoluteRamificationDegree(F);
        init := TRIM_APR(Approximation(x, CAPR(x : PrCap:=1+FUDGE))^n, FUDGE);
        mkupdate := func<z | function (apr)
          v := WeakValuation(x);
          pr := apr - n * v;
          return Approximation_Lazy(x, v+pr+FUDGE) mod function (xx)
            Update(z, CAP_APR(xx^n, apr));
            return true;
          end function;
        end function>;
        xn := F ! <init, mkupdate>;
      end if;
    else
      if IsDefinitelyZero(x) then
        error "division by zero";
      elif IsWeaklyZero(x : Strategy:=Strategy) then
        error "division by weak zero";
      else
        v := Valuation(x : Strategy:=Strategy);
        init := Approximation(x, v+1)^n;
        mkupdate := func<z | function (apr)
          pr := apr - n * v;
          return Approximation_Lazy(x, v+pr) mod function (xx)
            Update(z, xx^n);
            return true;
          end function;
        end function>;
        xn := F ! <init, mkupdate>;
      end if;
    end if;
    x`power[n] := xn;
  end if;
  return xn;
end intrinsic;

intrinsic '^'(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> RngUPolElt_FldPadExact
  {"}
  require n ge 0: "Argument 2 must be at least 0";
  case n:
  when 0:
    return One(Parent(f));
  when 1:
    return f;
  else
    if not assigned f`powers then
      f`powers := [];
    end if;
    if not IsDefined(f`powers, n) then
      m := n div 2;
      f`powers[n] := f^m * f^(n-m);
    end if;
    return f`powers[n];
  end case;
end intrinsic;

intrinsic IsWeaklyZero(x :: FldPadExactElt : Strategy:=false) -> BoolElt
  {True if x is zero up to precision.}
  if Strategy cmpeq false then
    return WZERO(x`approximation);
  elif not WZERO(x) then
    return false;
  else
    return not ExactpAdics_ExecutePrecisionStrategy(function (pr)
      IncreaseBaselinePrecision(x, pr);
      return not WZERO(x`approximation), _;
    end function, Strategy, 0);
  end if;
end intrinsic;

intrinsic IsWeaklyEqual(x :: FldPadExactElt, y :: FldPadExactElt : Strategy:=false) -> BoolElt
  {True if x and y are weakly equal up to precision.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must come from the same field";
  x := CAST(F, x);
  y := CAST(F, y);
  if Strategy cmpeq false then
    // renewEltApproximation(x);
    // renewEltApproximation(y);
    return WEQ(x`approximation, y`approximation);
  elif WEQ(x, y) then
    return not ExactpAdics_ExecutePrecisionStrategy(function (pr)
      IncreaseAbsolutePrecisions([*[*x, pr*],[*y, pr*]*]);
      // renewEltApproximation(x);
      // renewEltApproximation(y);
      return not WEQ(x`approximation, y`approximation), _;
    end function, Strategy, 0);
  else
    return false;
  end if;
end intrinsic;

intrinsic '&*'(xs :: [FldPadExactElt]) -> FldPadExactElt
  {Multiplication reduction.}
  F := Universe(xs);
  if exists{x : x in xs | IsDefinitelyZero(x)} then
    return CAST(F, 0);
  end if;
  if #xs eq 0 then
    return CAST(F, 1);
  elif #xs eq 1 then
    return xs[1];
  else
    init := &*[Approximation(x, CAPR(x)) : x in xs];
    mkupdate := func<z | function (apr)
      FUDGE := e gt 1 select 2*e else 0 where e := AbsoluteRamificationDegree(F);
      pr := apr - &+[WVAL(x) : x in xs];
      return &cat[Approximation_Lazy(x, WVAL(x)+pr+FUDGE) : x in xs]
      mod function (xxs)
        Update(z, CAP_APR(&*xxs, apr));
        return true;
      end function;
    end function>;
    return F ! <init, mkupdate>;
  end if;
end intrinsic;

intrinsic '&*'(fs :: [RngUPolElt_FldPadExact]) -> RngUPolElt_FldPadExact
  {"}
  R := Universe(fs);
  if exists{f : f in fs | IsDefinitelyZero(f)} then
    return CAST(R, 0);
  end if;
  if #fs eq 0 then
    return CAST(R, 1);
  elif #fs eq 1 then
    return fs[1];
  else

    // OLD VERSION: works, but uses a bad lower bound on the valuation for simplicity
    // init := &*[Approximation(f, CAPR(f)) : f in fs];
    // mkupdate := func<z | function (aprs)
    //   d := WeakDegree(z);
    //   apr := &join aprs;
    //   pr := apr - &+[WeakMinValuation(f) : f in fs];
    //   return &cat[Approximation_Lazy(f, WeakMinValuation(f)+pr) : f in fs]
    //   mod function (xfs)
    //     Update(z, &*xfs);
    //     return true;
    //   end function;
    // end function>;
    // return R ! <init, mkupdate>;
  end if;
end intrinsic;

intrinsic '*'(x :: FldPadExactElt, y :: FldPadExactElt) -> FldPadExactElt
  {Multiplication.}
  ok, F := ExistsCoveringStructure(Parent(x), Parent(y));
  require ok: "x and y must come from the same field";
  return &*[F | x, y];
end intrinsic;

intrinsic '*'(x, y :: FldPadExactElt) -> .
  {"}
  return do_binop('*', x, y);
end intrinsic;

intrinsic '*'(x :: FldPadExactElt, y) -> .
  {"}
  return do_binop('*', x, y);
end intrinsic;

intrinsic '*'(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {"}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must come from the same ring";
  f := R ! f;
  g := R ! g;
  K := BaseRing(R);
  df := WeakDegree(f);
  dg := WeakDegree(g);
  return R ! [K| &+[K| Coefficient(f,i)*Coefficient(g,k-i) : i in [Max(0,k-dg)..Min(k,df)]] : k in [0..df+dg]];
end intrinsic;

intrinsic '*'(x, y :: RngUPolElt_FldPadExact) -> .
  {"}
  return do_binop('*', x, y);
end intrinsic;

intrinsic '*'(x :: RngUPolElt_FldPadExact, y) -> .
  {"}
  return do_binop('*', x, y);
end intrinsic;

intrinsic Zero(F :: FldPadExact) -> FldPadExactElt
  {Zero.}
  if not assigned F`zero then
    F`zero := CAST(F, 0);
  end if;
  return F`zero;
end intrinsic;

intrinsic One(F :: FldPadExact) -> FldPadExactElt
  {One.}
  if not assigned F`one then
    F`one := CAST(F, 1);
  end if;
  return F`one;
end intrinsic;

intrinsic UniformizingElement(F :: FldPadExact) -> FldPadExactElt
  {The uniformizing element of F.}
  if not assigned F`uniformizing_element then
    case F`type:
    when PRIME:
      pi := CAST(F, Prime(F));
    when INERT:
      pi := CAST(F, UniformizingElement(BaseField(F)));
    when EISEN:
      pi := Generator(F);
    when EMBED:
      _,m := Image(F`defining_embedding);
      pi := m(UniformizingElement(Domain(m)));
    else
      error "not implemented";
    end case;
    F`uniformizing_element := pi;
  end if;
  return F`uniformizing_element;
end intrinsic;

intrinsic BaseField(F :: FldPadExact) -> FldPadExact
  {The base field of F.}
  if not assigned F`base_field then
    case F`type:
    when INERT, EISEN:
      F0 := BaseRing(DefiningPolynomial(F));
    when EMBED:
      m := F`defining_embedding;
      F0 := Image(Restriction(m, BaseField(Domain(m))));
    when PRIME:
      error "F must be an extension";
    else
      error "not implemented";
    end case;
    F`base_field := F0;
  end if;
  return F`base_field;
end intrinsic;

intrinsic Degree(F :: FldPadExact) -> RngIntElt
  {The degree of F over its base field.}
  if not assigned F`degree then
    case F`type:
    when INERT, EISEN:
      d := Degree(DefiningPolynomial(F));
    when EMBED:
      m := F`defining_embedding;
      return Degree(Domain(m));
    when PRIME:
      error "F must be an extension";
    else
      error "not implemented";
    end case;
    F`degree := d;
  end if;
  return F`degree;
end intrinsic;

intrinsic AbsoluteDegree(F :: FldPadExact) -> RngIntElt
  {The degree of F over its prime field.}
  if not assigned F`absolute_degree then
    case F`type:
    when PRIME:
      d := 1;
    when INERT, EISEN:
      d := Degree(F) * AbsoluteDegree(BaseField(F));
    when EMBED:
      m := F`defining_embedding;
      d := AbsoluteDegree(Domain(m));
    else
      error "not implemented";
    end case;
    F`absolute_degree := d;
  end if;
  return F`absolute_degree;
end intrinsic;

intrinsic InertiaDegree(F :: FldPadExact) -> RngIntElt
  {The inertia degree of F over its base field.}
  if not assigned F`inertia_degree then
    case F`type:
    when INERT:
      d := Degree(F);
    when EISEN:
      d := 1;
    when EMBED:
      m := F`defining_embedding;
      d := InertiaDegree(Domain(m));
    when PRIME:
      error "F must be an extension";
    else
      error "not implemented";
    end case;
    F`inertia_degree := d;
  end if;
  return F`inertia_degree;
end intrinsic;

intrinsic AbsoluteInertiaDegree(F :: FldPadExact) -> RngIntElt
  {The inertia degree of F over its prime field.}
  if not assigned F`absolute_inertia_degree then
    case F`type:
    when PRIME:
      d := 1;
    when INERT, EISEN:
      d := InertiaDegree(F) * AbsoluteInertiaDegree(BaseField(F));
    when EMBED:
      m := F`defining_embedding;
      d := AbsoluteInertiaDegree(Domain(m));
    else
      error "not implemented";
    end case;
    F`absolute_inertia_degree := d;
  end if;
  return F`absolute_inertia_degree;
end intrinsic;

intrinsic RamificationDegree(F :: FldPadExact) -> RngIntElt
  {The ramificationd degree of F over its base field.}
  if not assigned F`ramification_degree then
    case F`type:
    when EISEN:
      d := Degree(F);
    when INERT:
      d := 1;
    when EMBED:
      m := F`defining_embedding;
      d := RamificationDegree(Domain(m));
    when PRIME:
      error "F must be an extension";
    else
      error "not implented";
    end case;
    F`ramification_degree := d;
  end if;
  return F`ramification_degree;
end intrinsic;

intrinsic AbsoluteRamificationDegree(F :: FldPadExact) -> RngIntElt
  {The ramification degree of F over its prime field.}
  if not assigned F`absolute_ramification_degree then
    case F`type:
    when EISEN, INERT:
      d := RamificationDegree(F) * AbsoluteRamificationDegree(BaseField(F));
    when PRIME:
      d := 1;
    when EMBED:
      m := F`defining_embedding;
      d := AbsoluteRamificationDegree(Domain(m));
    else
      error "not implemented";
    end case;
    F`absolute_ramification_degree := d;
  end if;
  return F`absolute_ramification_degree;
end intrinsic;

intrinsic Degree(x :: ExtDataFldPadExact) -> RngIntElt
  {The degree of the extension.}
  if not assigned x`degree then
    case x`type:
    when COMPOUND:
      d := &*[Z| Degree(y) : y in x`list];
    when INERT, EISEN:
      d := Degree(x`top_field);
    when EMBED:
      ok, d := IsDivisibleBy(AbsoluteDegree(x`top_field), AbsoluteDegree(x`base_field));
      assert ok;
    else
      error "not implemented";
    end case;
    x`degree := d;
  end if;
  return x`degree;
end intrinsic;

intrinsic Degree(E :: FldPadExact, F :: FldPadExact) -> RngIntElt
  {The degree of E over F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return Degree(x);
end intrinsic;

intrinsic RamificationDegree(x :: ExtDataFldPadExact) -> RngIntElt
  {The ramification degree of the extension.}
  if not assigned x`ramification_degree then
    case x`type:
    when COMPOUND:
      d := &*[Z| RamificationDegree(y) : y in x`list];
    when INERT, EISEN:
      d := RamificationDegree(x`top_field);
    when EMBED:
      ok, d := IsDivisibleBy(AbsoluteRamificationDegree(x`top_field), AbsoluteRamificationDegree(x`base_field));
      assert ok;
    else
      error "not implemented";
    end case;
    x`ramification_degree := d;
  end if;
  return x`ramification_degree;
end intrinsic;

intrinsic RamificationDegree(E :: FldPadExact, F :: FldPadExact) -> RngIntElt
  {The ramification degree of E over F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return RamificationDegree(x);
end intrinsic;

intrinsic InertiaDegree(x :: ExtDataFldPadExact) -> RngIntElt
  {The inertia degree.}
  if not assigned x`inertia_degree then
    case x`type:
    when COMPOUND:
      d := &*[Z| InertiaDegree(y) : y in x`list];
    when INERT, EISEN:
      d := InertiaDegree(x`top_field);
    when EMBED:
      ok, d := IsDivisibleBy(AbsoluteInertiaDegree(x`top_field), AbsoluteInertiaDegree(x`base_field));
      assert ok;
    else
      error "not implemented";
    end case;
    x`inertia_degree := d;
  end if;
  return x`inertia_degree;
end intrinsic;

intrinsic InertiaDegree(E :: FldPadExact, F :: FldPadExact) -> RngIntElt
  {The inertia degree of E over F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return InertiaDegree(x);
end intrinsic;

intrinsic PolynomialRing(F :: FldPadExact) -> RngUPol_FldPadExact
  {The univariate polynomial ring over F.}
  if not assigned F`polynomial_ring then
    R := New(RngUPol_FldPadExact);
    R`id := NEXTID();
    R`base_ring := F;
    R`approximation_ring := PolynomialRing(F`approximation_field);
    F`polynomial_ring := R;
  end if;
  return F`polynomial_ring;
end intrinsic;

intrinsic Print(R :: RngUPol_FldPadExact, lvl :: MonStgElt)
  {Print.}
  case lvl:
  when "Magma":
    printf "PolynomialRing(%m)", BaseRing(R);
  else
    printf "Polynomial ring";
    if assigned R`varname then
      printf " in %o", R`varname;
    end if;
    printf " over %O", BaseRing(R), lvl;
  end case;
end intrinsic;

intrinsic BaseRing(R :: RngUPol_FldPadExact) -> FldPadExact
  {The base ring of R.}
  return R`base_ring;
end intrinsic;

intrinsic Approximation_Lazy(f :: RngUPolElt_FldPadExact, apr : Quick:=false, FixPr:=true) -> ExactpAdics_Gettr
  {An approximation to f.}
  ok, apr := IsValidAbsolutePrecisionDiff(f, apr);
  require ok: "Argument 2: " cat apr;
  pr := PrecisionRequired(f, apr);
  // vs := [Valuation(c) : c in Coefficients(f`approximation)];
  // Pr := Max([vs[i] eq OO select 0 else APr[i] - vs[i]  : i in [1..#vs]]);
  iapR := IncreaseAbsolutePrecision_Lazy(Parent(f), pr);
  return iapR mod function (ig)
    iap := IncreaseAbsolutePrecision_Lazy(f, apr);
    return iap mod function (ig)
      if Quick then
        xf := f`approximation;
      else
        coeffs := Coefficients(f`approximation);
        U := Universe(coeffs);
        xf := Polynomial([U | CAP_APR(coeffs[i], apr(i-1)) : i in [1..#coeffs]]);
      end if;
      if FixPr then
        xf := ChangeRing(xf, ChangePrecision(BaseRing(xf), Max(1, pr)));
      end if;
      assert forall{i : i in [0..WeakDegree(f)] |
        AbsolutePrecision(Coefficient(xf, i)) ge apr(i)};
      return xf;
    end function;
  end function;
end intrinsic;

intrinsic Approximation(f :: RngUPolElt_FldPadExact, apr : Quick:=false, FixPr:=true) -> ExactpAdics_Gettr
  {"}
  return Evaluate(Approximation_Lazy(f, apr : Quick:=Quick, FixPr:=FixPr));
end intrinsic;

intrinsic IncreaseAbsolutePrecision_Lazy(R :: RngUPol_FldPadExact, pr :: RngIntElt) -> ExactpAdics_Gettr
  {Increases the precision of the approximation to R to at least pr.}
  pr := Max(pr, 1);
  return IncreaseAbsolutePrecision_Lazy(BaseRing(R), pr);
end intrinsic;

intrinsic Approximation_Lazy(R :: RngUPol_FldPadExact, pr :: RngIntElt) -> ExactpAdics_Gettr
  {An approximation to R whose base field has default precision pr.}
  require pr gt 0: "pr must be positive";
  return IncreaseAbsolutePrecision_Lazy(R, pr) mod function (ig)
    xR := R`approximation_ring;
    xK := BaseRing(xR);
    xK`DefaultPrecision := pr;
    return xR;
  end function;
end intrinsic;

intrinsic Approximation(R :: RngUPol_FldPadExact, pr :: RngIntElt) -> RngUPol
  {"}
  return Evaluate(Approximation_Lazy(R, pr));
end intrinsic;

intrinsic Approximation(R :: RngUPol_FldPadExact) -> RngUPol
  {The approximation to R.}
  return R`approximation_ring;
end intrinsic;

intrinsic Print(f :: RngUPolElt_FldPadExact, lvl :: MonStgElt)
  {Prints f.}
  // renewEltApproximation_poly(f);
  case lvl:
  when "Magma":
    printf "%o", f`approximation;
  else
    printf "%o", Format(f : APr:=AbsolutePrecision(f) meet (1+WeakValuation(f)));
  end case;
end intrinsic;

intrinsic AssignNames(~R :: RngUPol_FldPadExact, names :: [MonStgElt])
  {Assigns the name of the variable of R.}
  require #names eq 1: "Argument 2 must have length 1";
  R`varname := names[1];
  AssignNames(~R`approximation_ring, names);
end intrinsic;

intrinsic Names(R :: RngUPol_FldPadExact) -> []
  {The names of R.}
  if assigned R`varname then
    return [R`varname];
  else
    return ["S.1"];
  end if;
end intrinsic;

intrinsic Name(R :: RngUPol_FldPadExact, i :: RngIntElt) -> RngUPolElt_FldPadExact
  {Gets the ith generator of R.}
  require i eq 1: "i must be 1";
  return Generator(R);
end intrinsic;

intrinsic '.'(R :: RngUPol_FldPadExact, i :: RngIntElt) -> RngUPolElt_FldPadExact
  {"}
  require i eq 1: "i must be 1";
  return Generator(R);
end intrinsic;

intrinsic Generator(R :: RngUPol_FldPadExact) -> RngUPolElt_FldPadExact
  {The generator of R.}
  if not assigned R`generator then
    R`generator := CAST(R, [0,1]);
  end if;
  return R`generator;
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X) -> BoolElt, .
  {True if X is coercible to an element of R, and the coerced element.}
  ok, x := IsCoercible(BaseRing(R), X);
  if ok then
    return true, CAST(R, [x]);
  end if;
  return false, "not coercible";
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: RngUPolElt_FldPadExact) -> BoolElt, .
  {"}
  if Parent(X) eq R then
    return true, X;
  else
    return IsCoercible(R, WeakCoefficients(X));
  end if;
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: RngUPolElt) -> BoolElt, .
  {"}
  return IsCoercible(R, Coefficients(X));
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: RngUPolElt[FldPad]) -> BoolElt, .
  {"}
  ok, app := IS_VALID_APPROX(R, X);
  if ok then
    x := New(RngUPolElt_FldPadExact);
    x`id := NEXTID();
    x`parent := R;
    x`approximation := app;
    x`update := function (apr)
      error "cannot increase precision of approximate p-adics";
    end function;
    return true, x;
  end if;
  return IsCoercible(R, Coefficients(X));
end intrinsic;

function makePoly(R, init, mkupdate)
  f := New(RngUPolElt_FldPadExact);
  f`parent := R;
  f`update := mkupdate(f);
  f`id := NEXTID();
  case Type(init):
  when RngUPolElt:
    ok, init := IS_VALID_APPROX(R, init);
    if ok then
      f`approximation := init;
    else
      return false, "wrong field";
    end if;
  else
    return false, "bad init";
  end case;
  SetBaselineValuation(f, WeakValuation(f));
  return true, f;
end function;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: Tup) -> BoolElt, .
  {"}
  if #X eq 2 then
    return makePoly(R, X[1], X[2]);
  elif #X eq 3 then
    ok, g := makePoly(R, X[1], X[2]);
    if ok then
      SetData(g, X[3]);
      return true, g;
    else
      return false, g;
    end if;
  else
    return false, "not coercible";
  end if;
end intrinsic;

intrinsic IsCoercible(R :: RngUPol_FldPadExact, X :: []) -> BoolElt, .
  {"}
  F := BaseRing(R);
  if CanChangeUniverse(X, F) then
    coeffs := [F | CAST(F, x) : x in X];
  else
    return false, "coefficients not coercible to base field";
  end if;
  while #coeffs gt 0 and IsDefinitelyZero(coeffs[#coeffs]) do
    Prune(~coeffs);
  end while;
  xR := Approximation(R, 1);
  init := xR ! [Approximation(x, APR(x) meet (WVAL(x)+1)) : x in coeffs];
  mkupdate := func<f | function (apr)
    return &cat[Approximation_Lazy(coeffs[i+1], apr(i)) : i in [0..WeakDegree(f)]]
    mod function (xcoeffs)
      Update(f, xR ! xcoeffs);
      return true;
    end function;
  end function>;
  f := R ! <init, mkupdate>;
  // f`weak_coefficients := coeffs;
  return true, f;
end intrinsic;

intrinsic WeakDegree(f :: RngUPolElt_FldPadExact) -> RngIntElt
  {The weak degree of f, the degree of its approximation.}
  return Degree(f`approximation);
end intrinsic;

intrinsic WeakValuation(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {The valuations of the coefficients of the approximation of f.}
  return Val_RngUPolElt_FldPad_Make(OO, [0..WeakDegree(f)], [VAL(c) : c in Coefficients(f`approximation)]);
end intrinsic;

intrinsic WeakMinValuation(f :: RngUPolElt_FldPadExact) -> Val_FldPadElt
  {The minimum valuation of the coefficients of the approximation of f.}
  return &meet WeakValuation(f);
end intrinsic;

intrinsic AbsolutePrecision(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {The absolute precisions of the coefficients of the approximation of f.}
  return Val_RngUPolElt_FldPad_Make(OO, [0..WeakDegree(f)], [APR(c) : c in Coefficients(f`approximation)]);
end intrinsic;

intrinsic Precision(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {The precisions of the coefficients of the approximation of f.}
  return APR(f) - PR(f);
end intrinsic;

intrinsic WeakCoefficients(f :: RngUPolElt_FldPadExact) -> []
  {The coefficients of f, possibly including some leading zeros.}
  if not assigned f`weak_coefficients then
    f`weak_coefficients := [Coefficient(f, i) : i in [0..WeakDegree(f)]];
  end if;
  return f`weak_coefficients[1..WeakDegree(f)+1];
end intrinsic;

function _coefficient(f, i)
  R := Parent(f);
  F := BaseRing(R);
  init := Coefficient(f`approximation, i);
  mkupdate := func<z | function (apr)
    fapr := AbsolutePrecision(f);
    return IncreaseAbsolutePrecision_Lazy(f, [<i,apr>])
    mod function (ig)
      Update(z, Coefficient(f`approximation, i));
      return true;
    end function;
  end function>;
  return F ! <init, mkupdate>;
end function;

intrinsic Coefficient(f :: RngUPolElt_FldPadExact, i :: RngIntElt) -> []
  {The ith coefficient of f.}
  require i ge 0: "i must be non-negative";
  if assigned f`weak_coefficients then
    return (i+1 gt #f`weak_coefficients) select CAST(BaseRing(Parent(f), 0)) else f`weak_coefficients[i+1];
  end if;
  if i gt WeakDegree(f) then
    return CAST(BaseRing(Parent(f)), 0);
  end if;
  if not assigned f`coefficient then
    f`coefficient := [];
  end if;
  if IsDefined(f`coefficient, i+1) then
    c := f`coefficient[i+1];
  else
    c := _coefficient(f, i);
    f`coefficient[i+1] := c;
  end if;
  return c;
end intrinsic;

intrinsic 'eq'(R :: RngUPol_FldPadExact, S :: RngUPol_FldPadExact) -> BoolElt
  {Equality.}
  return R`id eq S`id;
end intrinsic;

intrinsic IncreaseAbsolutePrecision(f :: RngUPolElt_FldPadExact, n)
  {Increases the absolute precision of f to n.}
  satisfy_dep(f, n);
end intrinsic;

intrinsic IncreaseAbsolutePrecision_Lazy(f :: RngUPolElt_FldPadExact, n) -> ExactpAdics_Gettr
  {A getter which when evaluated increases the absolute precision of f.}
  ok, n := IsValidAbsolutePrecisionDiff(f, n);
  if not ok then
    error "invalid n";
  end if;
  return ExactpAdics_Getter(false, procedure (~st, ~deps) deps := [*[*f,n*]*]; end procedure, procedure (~st, ~val) assert n le AbsolutePrecision(f); val := true; end procedure);
end intrinsic;

intrinsic IncreaseAbsolutePrecisions(xs)
  {Increases the absolute precision of xs[i][1] to xs[i][2].}
  satisfy_deps_list(xs, Infinity());
end intrinsic;

function merge_polys(f, g)
  // assuming f and g have the same parent and are weakly equal, returns the polynomial got by taking the most precise coefficients from each
  assert Parent(f) eq Parent(g);
  r := CAST(Parent(f), [
    AbsolutePrecision(cf) ge AbsolutePrecision(cg)
    select cf
    else cg
    where cf := Coefficient(f,i)
    where cg := Coefficient(g,i)
    : i in [0..Min(Degree(f), Degree(g))]
  ]);
  return r;
end function;

// intrinsic Update(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact)
//   {Updates f to the weak value of g.}
//   R := Parent(f);
//   require R eq Parent(g): "f and g must belong to the same field";
//   renewEltApproximation_poly(f);
//   renewEltApproximation_poly(g);
//   require WEQ(f`approximation, g`approximation)
//   and Degree(g`approximation) le Degree(f`approximation):
//     "inconsistent";
//   f`approximation := merge_polys(f`approximation, g`approximation);
// end intrinsic;

intrinsic Update(f :: RngUPolElt_FldPadExact, app :: RngUPolElt[FldPad])
  {Updates f to app.}
  R := Parent(f);
  xR := R`approximation_ring;
  ok, app := IS_VALID_APPROX(R, app);
  require ok: "app is in the wrong ring";
  if UPDATE_CONSISTENCY_CHECK then
    require WEQ(f`approximation, app): "inconsistent";
  end if;
  f`approximation := merge_polys(f`approximation, app);
end intrinsic;

intrinsic UpdateZero(f :: RngUPolElt_FldPadExact, aprs :: [RngIntElt])
  {Updates f to sum_i(O(pi^aprs[i+1])*x^i).}
  R := f`parent;
  xR := R`approximation_ring;
  K := BaseRing(R);
  xK := K`approximation_field;
  Update(f, CAST(xR, [Zero(xK, a) : a in aprs]));
end intrinsic;

intrinsic Parent(f :: RngUPolElt_FldPadExact) -> RngUPol_FldPadExact
  {The polynomial ring containing f.}
  return f`parent;
end intrinsic;

intrinsic IsWeaklyZero(f :: RngUPolElt_FldPadExact : Strategy:=false) -> BoolElt
  {True if f is weakly zero.}
  if Strategy cmpeq false then
    return WZERO(f`approximation);
  elif not WZERO(f) then
    return false;
  else
    return not ExactpAdics_ExecutePrecisionStrategy(function (apr)
      IncreaseBaselinePrecision(f, apr);
      return not WZERO(f), _;
    end function, Strategy, 0);
  end if;
end intrinsic;

intrinsic IsWeaklyEqual(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> BoolElt
  {True if f and g are weakly equal.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be defined over the same field";
  f := CAST(R, f);
  g := CAST(R, g);
  // renewEltApproximation_poly(f);
  // renewEltApproximation_poly(g);
  return WEQ(f`approximation, g`approximation);
end intrinsic;

intrinsic ExistsCoveringStructure
  ( R :: RngUPol_FldPadExact
  , S :: RngUPol_FldPadExact
  ) -> BoolElt, .
  {True if there is a polynomial ring containing both R and S.}
  if R eq S then
    return true, R;
  end if;
  ok, F := ExistsCoveringStructure(BaseRing(R), BaseRing(S));
  if ok then
    if BaseRing(R) eq F then
      return true, R;
    elif BaseRing(S) eq F then
      return true, S;
    else
      return true, PolynomialRing(F);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( R :: RngUPol_FldPadExact
  , S :: RngUPol
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), BaseRing(S));
  if ok then
    if E eq BaseRing(R) then
      return true, PolynomialRing(E);
    else
      return true, PolynomialRing(E);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( S :: RngUPol
  , R :: RngUPol_FldPadExact
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), BaseRing(S));
  if ok then
    if E eq BaseRing(R) then
      return true, PolynomialRing(E);
    else
      return true, PolynomialRing(E);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( R :: RngUPol_FldPadExact
  , S :: Str
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), S);
  if ok then
    if E eq BaseRing(R) then
      return true, R;
    else
      return true, PolynomialRing(E);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( S :: Str
  , R :: RngUPol_FldPadExact
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), S);
  if ok then
    if E eq BaseRing(R) then
      return true, R;
    else
      return true, PolynomialRing(E);
    end if;
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( R :: RngUPol
  , S :: FldPadExact
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), S);
  if ok then
    return true, PolynomialRing(E);
  end if;
  return false, _;
end intrinsic;

intrinsic ExistsCoveringStructure
  ( S :: FldPadExact
  , R :: RngUPol
  ) -> BoolElt, .
  {"}
  ok, E := ExistsCoveringStructure(BaseRing(R), S);
  if ok then
    return true, PolynomialRing(E);
  end if;
  return false, _;
end intrinsic;

intrinsic Degree(f :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt
  {The degree of f.}
  if not assigned f`degree then
    d := WeakDegree(f);
    if d ge 0 and IsWeaklyZero(Coefficient(f, d) : Strategy:=Strategy) then
      error "leading coefficient is weakly zero";
    end if;
    f`degree := d;
  end if;
  return f`degree;
end intrinsic;

intrinsic IsEisenstein(f :: RngUPolElt_FldPadExact) -> BoolElt
  {True if f is Eisenstein.}
  if not assigned f`is_eisenstein then
    d := Degree(f);
    if d lt 1 then
      f`is_eisenstein := false;
    else
      IncreaseAbsolutePrecision(f, [<i, (i eq 0) select 2 else 1> : i in [0..d]]);
      xf := f`approximation;
      f`is_eisenstein := Valuation(Coefficient(xf, 0)) eq 1
        and Valuation(Coefficient(xf, d)) eq 0
        and forall{i : i in [1..d-1] | Valuation(Coefficient(xf, i)) gt 0};
    end if;
  end if;
  return f`is_eisenstein;
end intrinsic;

intrinsic WeakLeadingCoefficient(f :: RngUPolElt_FldPadExact) -> BoolElt
  {The leading weak coefficient of f.}
  return Coefficient(f, WeakDegree(f));
end intrinsic;

intrinsic LeadingCoefficient(f :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt
  {The leading coefficient of f.}
  if not assigned f`leading_coefficient then
    d := Degree(f : Strategy:=Strategy);
    f`leading_coefficient := Coefficient(f, d);
  end if;
  return f`leading_coefficient;
end intrinsic;

procedure assignResidueClassFieldNames(~R, F)
  case F`type:
  when PRIME:
    assert IsPrimeField(R);
  when INERT:
    R0 := BaseField(R);
    F0 := BaseField(F);
    assert Degree(R, R0) eq Degree(F);
    if assigned F`varname then
      AssignNames(~R, [F`varname cat "bar"]);
    end if;
    assignResidueClassFieldNames(~R0, F0);
  when EISEN:
    F0 := BaseField(F);
    assignResidueClassFieldNames(~R, F0);
  else
    error "not implemented";
  end case;
end procedure;

intrinsic ResidueClassField(F :: FldPadExact) -> FldFin, Map, Map
  {The residue class field R of F, the map F to R, and the map from the approximation of F to R.}
  if not assigned F`residue_class_field then
    A := Approximation(F, 1);
    OA := Integers(A);
    R, m := ResidueClassField(OA);
    assignResidueClassFieldNames(~R, F);
    function FtoR(x)
      if not assigned x`residue_class then
        error if ValuationLt(x, 0), "not integral";
        x`residue_class := CAST(OA, Approximation(x,1)) @ m;
      end if;
      return x`residue_class;
    end function;
    function RtoF(y)
      x := New(FldPadExactElt);
      x`approximation := CAP_APR(CAST(A, y @@ m), 1);
      x`id := NEXTID();
      x`parent := F;
      x`update := function (apr)
        error "cannot increase precision of preimages of residue classes (consider using WeakApproximation)";
      end function;
      return x;
    end function;
    F`residue_class_field := [*R, map<F -> R | x :-> FtoR(x), y :-> RtoF(y)>, m*];
  end if;
  return Explode(F`residue_class_field);
end intrinsic;

intrinsic ResidueClass(x :: FldPadExactElt) -> FldFinElt
  {The residue class of x.}
  if not assigned x`residue_class then
    F := Parent(x);
    _, m := ResidueClassField(F);
    _ := m(x);
  end if;
  return x`residue_class;
end intrinsic;

intrinsic Valuation(x :: FldPadExactElt : Strategy:="default") -> RngIntElt
  {The valuation of x.}
  if not assigned x`valuation then
    if IsDefinitelyZero(x) then
      x`valuation := Val_FldPadElt_Make(OO);
    elif IsWeaklyZero(x : Strategy:=Strategy) then
      error "weakly zero";
    else
      x`valuation := WeakValuation(x);
    end if;
  end if;
  return x`valuation;
end intrinsic;

intrinsic IsInertial(f :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt
  {True if f is inertial (i.e. it is irreducible as a polynomial over the residue class field).}
  if not assigned f`is_inertial then
    R := Parent(f);
    F := BaseRing(R);
    C, m, xm := ResidueClassField(F);
    d := Degree(f : Strategy:=Strategy);
    IncreaseAbsolutePrecision(f, 1);
    xcoeffs := Coefficients(f`approximation);
    // check integral and "monic"
    if exists{i : i in [0..d] | Valuation(xcoeffs[i+1]) lt 0} then
      f`is_inertial := false;
    elif Valuation(xcoeffs[d+1]) ne 0 then
      f`is_inertial := false;
    else
      // coerce to residue class field and check irreducible
      fC := Polynomial([C | xm(x) : x in Coefficients(f`approximation)]);
      assert Degree(fC) eq d;
      f`is_inertial := IsIrreducible(fC);
    end if;
  end if;
  return f`is_inertial;
end intrinsic;

intrinsic Coefficients(f :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt
  {The coefficients of f.}
  if not assigned f`coefficients then
    d := Degree(f : Strategy:=Strategy);
    f`coefficients := [Coefficient(f, i) : i in [0..d]];
  end if;
  return f`coefficients;
end intrinsic;

function get_approximation(f, apr)
  if apr le AbsolutePrecision(f) then
    return f`approximation;
  else
    // any combination of the below is a reasonable reaction
    // error "not known to required precision";
    print "ERROR: Field is not known to required precision.";
    print "ERROR: This is a bug in the ExactpAdics package.";
    print "ERROR: Please report this to github.com/cjdoris/ExactpAdics/issues";
    IncreaseAbsolutePrecision(f, apr);
    return f`approximation;
  end if;
end function;

intrinsic TotallyRamifiedExtension(f :: RngUPolElt_FldPadExact) -> FldPadExact
  {The totally ramified extension defined by the Eisenstein polynomial f.}
  IncreaseAbsolutePrecision(f, 2); // BUGFIX: magma complains otherwise!
  require IsEisenstein(f) and Degree(f) gt 0: "f must be Eisenstein";
  d := Degree(f);
  F0 := BaseRing(f);
  xF0 := F0`approximation_field;
  xF0`DefaultPrecision := 2;
  F := New(FldPadExact);
  F`id := NEXTID();
  F`type := EISEN;
  F`defining_polynomial := f;
  F`approximation_field := ext<xF0 | map<Z -> PolynomialRing(xF0) | k :-> get_approximation(f, k)>>;
  return F;
end intrinsic;

intrinsic TotallyRamifiedExtension(F :: FldPadExact, f) -> FldPadExact
  {The totally ramified extension of F defined by the Eisenstein polynomial f.}
  ok, f := IsCoercible(PolynomialRing(F), f);
  require ok: "f must be coercible to a polynomial over F";
  return TotallyRamifiedExtension(f);
end intrinsic;

intrinsic TotallyRamifiedExtension(F :: FldPadExact, n :: RngIntElt, pi) -> FldPadExact
  {The totally ramified extension of F got by adjoining the nth root of pi, which must be a uniformizing element.}
  require n ge 1: "n must be at least 1";
  ok, pi := IsCoercible(F, pi);
  require ok: "pi must be coercible to F";
  require IsUniformizingElement(pi): "pi must be a uniformizing element";
  return TotallyRamifiedExtension(Polynomial([F | case<i | 0:-pi, n:1, default:0> : i in [0..n]]));
end intrinsic;

intrinsic TotallyRamifiedExtension(F :: FldPadExact, n :: RngIntElt) -> FldPadExact
  {The totally ramified extension of F got by adjoining the nth root of the uniformizing element of F.}
  return TotallyRamifiedExtension(F, n, UniformizingElement(F));
end intrinsic;

intrinsic IsUniformizingElement(x :: FldPadExactElt) -> BoolElt
  {True iff x is a uniformizing element, i.e. has valuation 1.}
  return ValuationEq(x, 1);
end intrinsic;

intrinsic Extension(f :: RngUPolElt_FldPadExact) -> FldPadExact
  {The extension defined by the inertial or Eisenstein polynomial f.}
  IncreaseAbsolutePrecision(f, 2);
  if IsInertial(f) then
    return UnramifiedExtension(f);
  elif IsEisenstein(f) then
    return TotallyRamifiedExtension(f);
  else
    error "f must currently be inertial or Eisenstein";
  end if;
end intrinsic;

intrinsic Extension(F :: FldPadExact, f) -> FldPadExact
  {The extension of F defined by the inertial or Eisenstein polynomial f.}
  ok, f := IsCoercible(PolynomialRing(F), f);
  require ok: "f must be coercible to a polynomial over F";
  return Extension(f);
end intrinsic;

intrinsic UnramifiedExtension(f :: RngUPolElt_FldPadExact) -> FldPadExact
  {The unramified extension defined by the inertial polynomial f.}
  IncreaseAbsolutePrecision(f, 1);
  require IsInertial(f) and Degree(f) gt 0: "f must be inertial";
  F0 := BaseRing(f);
  xF0 := F0`approximation_field;
  xF0`DefaultPrecision := 1;
  F := New(FldPadExact);
  F`id := NEXTID();
  F`type := INERT;
  F`defining_polynomial := f;
  F`approximation_field := ext<xF0 | map<Z -> PolynomialRing(xF0) | k :-> get_approximation(f, k)>>;
  return F;
end intrinsic;

intrinsic UnramifiedExtension(F :: FldPadExact, f) -> FldPadExact
  {The unramified extension of F defined by the inertial polynomial f.}
  ok, f := IsCoercible(PolynomialRing(F), f);
  require ok: "f must be coercible to a polynomial over F";
  return UnramifiedExtension(f);
end intrinsic;

intrinsic UnramifiedExtension(F :: FldPadExact, n :: RngIntElt) -> FldPadExact
  {An unramified extension of F of degree n.}
  require n gt 0: "n must be positive";
  if n eq 1 then
    return F;
  end if;
  Fbar, modp, xmodp := ResidueClassField(F);
  Ubar := ext<Fbar | n>;
  fmodp := DefiningPolynomial(Ubar, Fbar);
  R := PolynomialRing(F);
  xR := PolynomialRing(F`approximation_field);
  f := WeakApproximation(R ! xR ! [cmodp @@ xmodp : cmodp in Coefficients(fmodp)]);
  return UnramifiedExtension(f);
end intrinsic;

intrinsic BaseRing(f :: RngUPolElt_FldPadExact) -> FldPadExact
  {The base ring of f.}
  if not assigned f`base_ring then
    f`base_ring := BaseRing(Parent(f));
  end if;
  return f`base_ring;
end intrinsic;

intrinsic DefiningPolynomial(K :: FldPadExact) -> RngUPolElt_FldPadExact
  {"}
  if assigned K`defining_polynomial then
    return K`defining_polynomial;
  else
    assert IsPrimeField(K);
    error "K is a prime field";
  end if;
end intrinsic;

intrinsic AssignNames(~F :: FldPadExact, names :: [MonStgElt])
  {Assigns a name to the generator of F.}
  require not IsPrimeField(F): "F must be an extension";
  require #names eq 1: "names must have one element";
  F`varname := names[1];
  AssignNames(~F`approximation_field, names);
end intrinsic;

intrinsic Name(F :: FldPadExact, i :: RngIntElt) -> FldPadExactElt
  {The ith generator of F.}
  require i eq 1: "i must be 1";
  return Generator(F);
end intrinsic;

intrinsic '.'(F :: FldPadExact, i :: RngIntElt) -> FldPadExactElt
  {"}
  require i eq 1: "i must be 1";
  return Generator(F);
end intrinsic;

intrinsic Generator(F :: FldPadExact) -> FldPadExactElt
  {The generating element of F.}
  if not assigned F`generator then
    require not IsPrimeField(F): "F must be an extension";
    F`generator := CAST(F, [0, 1]);
  end if;
  return F`generator;
end intrinsic;

intrinsic WeakApproximation(x :: FldPadExactElt) -> FldPadExactElt
  {An element weakly equal to x.}
  F := x`parent;
  if WZERO(x) then
    return F ! 0;
  else
    mkupdate := func<z | function (apr)
      pr := PrecisionRequired(z, apr);
      return IncreaseAbsolutePrecision_Lazy(F, pr) mod function (ig)
        Update(z, CHANGE_APR(z`approximation, apr));
        return true;
      end function;
    end function>;
    return F ! <x`approximation, mkupdate>;
  end if;
end intrinsic;

intrinsic WeakApproximation(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {An element weakly equal to x.}
  R := f`parent;
  if WZERO(f) then
    return R ! 0;
  else
    g := New(RngUPolElt_FldPadExact);
    g`id := NEXTID();
    g`parent := R;
    g`approximation := f`approximation;
    g`update := function (apr)
      pr := PrecisionRequired(g, apr);
      // dg := WeakDegree(g);
      // xg := g`approximation;
      // pr := Max([(WZERO(c) or v eq OO select 0 else aprs[i+1]-v)
      //   where v := Valuation(c)
      //   where c := Coefficient(xg, i)
      //   : i in [0..dg]
      // ]);
      return IncreaseAbsolutePrecision_Lazy(R, pr) mod function (ig)
        Update(g, CHANGE_APR(g`approximation, apr join APR(g)));
        return true;
      end function;
    end function;
    return g;
  end if;
end intrinsic;

intrinsic Random(F :: FldPadExact, v :: RngIntElt) -> FldPadExactElt
  {A random element of F of value at least v.}
  A := Approximation(F, 1);
  xA := ChangePrecision(A, 1);
  xOA := Integers(xA);
  init := ShiftValuation(CAST(A, CAST(xA, Random(xOA))), v);
  mkupdate := func<z | function (apr)
    v := WeakValuation(z);
    apr0 := AbsolutePrecision(z);
    return Approximation_Lazy(F, apr-v) mod function (A)
      xA := ChangePrecision(A, IntegerValue(apr - apr0));
      xOA := Integers(xA);
      d := ShiftValuation(CAST(A, CAST(xA, Random(xOA))), IntegerValue(apr0));
      // renewEltApproximation(z);
      xz := z`approximation;
      xz2 := d + CHANGE_APR(xz, apr);
      Update(z, xz2);
      return true;
    end function;
  end function>;
  return F ! <init, mkupdate>;
end intrinsic;

intrinsic RandomInteger(F :: FldPadExact) -> FldPadExactElt
  {A random integer of F.}
  return Random(F, 0);
end intrinsic;

intrinsic RandomUnit(F :: FldPadExact, v :: RngIntElt) -> FldPadExactElt
  {A random element of F of value v.}
  repeat
    x := Random(F, v);
  until ValuationEq(x, v);
  return x;
end intrinsic;

intrinsic RandomUnit(F :: FldPadExact) -> FldPadExactElt
  {A random unit of F.}
  return RandomUnit(F, 0);
end intrinsic;

intrinsic ValuationEq(x :: FldPadExactElt, v) -> BoolElt
  {"}
  v := Val_FldPadElt_Make(v);
  if not WZERO(x) then
    return WVAL(x) eq v;
  end if;
  if IsFinite(v) and not IsIntegral(v) then
    return false;
  end if;
  IncreaseAbsolutePrecision(x, v+1);
  return WVAL(x) eq v;
end intrinsic;

intrinsic ValuationNe(x :: FldPadExactElt, v) -> BoolElt
  {True if x does not have valuation v.}
  return not ValuationEq(x, v);
end intrinsic;

intrinsic ValuationGe(x :: FldPadExactElt, v) -> BoolElt
  {True if the valuation of x is at least v.}
  IncreaseAbsolutePrecision(x, Ceiling(v));
  return WeakValuation(x) ge v;
end intrinsic;

intrinsic ValuationGt(x :: FldPadExactElt, v) -> BoolElt
  {True if the valuation of x is greater than v.}
  v := Val_FldPadElt_Make(v);
  if v eq OO then
    return false;
  else
    return ValuationGe(x, v+1);
  end if;
end intrinsic;

intrinsic ValuationLe(x :: FldPadExactElt, v) -> BoolElt
  {True if the valuation of x is at most v.}
  return not ValuationGt(x, v);
end intrinsic;

intrinsic ValuationLt(x :: FldPadExactElt, v) -> BoolElt
  {True if the valuation of x is less than v.}
  return not ValuationGe(x, v);
end intrinsic;

intrinsic Discriminant(f :: RngUPolElt_FldPadExact : Strategy:="default") -> FldPadExactElt
  {The discriminant of f.}
  if not assigned f`discriminant then
    d := Degree(f : Strategy:=Strategy);
    R := Parent(f);
    K := BaseRing(R);
    init := Discriminant(Approximation(f, CAPR(f)));
    mkupdate := func<z | function (apr)
      v := WeakMinValuation(f);
      pr := apr - (2*d-2)*v;
      return Approximation_Lazy(f, v+pr) mod function (xf)
        assert Degree(xf) eq d;
        Update(z, Discriminant(xf));
        return true;
      end function;
    end function>;
    f`discriminant := K ! <init, mkupdate>;
  end if;
  return f`discriminant;
end intrinsic;

intrinsic 'div'(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact : Strategy:="default") -> RngUPolElt_FldPadExact
  {f div g.}
  // put over a common field
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be defined over a common field";
  f := CAST(R, f);
  g := CAST(R, g);
  K := BaseRing(R);
  // check leading coefficients
  dg := Degree(g : Strategy := Strategy);
  wdf := WeakDegree(f);
  // trivial cases
  if dg gt wdf then
    return CAST(R, 0);
  elif dg eq wdf then
    return CAST(R, Coefficient(f, wdf) / Coefficient(g, dg));
  elif dg eq 0 then
    return f / Coefficient(g, 0);
  elif dg lt 0 then
    error "divide by zero";
  end if;
  // general case
  vg := MinValuation(g);
  vlcg := Valuation(LeadingCoefficient(g));
  init := Approximation(f, CAPR(f)) div Approximation(g, CAPR(g));
  mkupdate := func<z | function (aprs)
    apr := &join aprs;
    vf := WeakMinValuation(f);
    v := vf - vg;
    pr := (apr - v) join (vlcg+1-vg) join 0;
    return ExactpAdics_GeneralGetter(pr,
      procedure (~pr, ~getter)
        getter := &cat[
          Approximation_Lazy(f, vf+pr),
          Approximation_Lazy(g, vg+pr)
        ];
      end procedure,
      procedure (xfg, ~pr, ~val)
        xf, xg := Explode(xfg);
        assert Degree(xg) eq dg;
        Update(z, xf div xg);
        if AbsolutePrecision(z) ge aprs then
          val := true;
        else
          pr +:= &join (aprs - AbsolutePrecision(z));
        end if;
      end procedure
    );
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;

intrinsic 'div'(f :: RngUPolElt_FldPadExact, g : Strategy:="default") -> .
  {"}
  return do_binop(func<f, g | 'div'(f, g : Strategy:=Strategy)>, f, g);
end intrinsic;

intrinsic 'div'(f, g :: RngUPolElt_FldPadExact : Strategy:="default") -> .
  {"}
  return do_binop(func<f, g | 'div'(f, g : Strategy:=Strategy)>, f, g);
end intrinsic;

intrinsic MinValuation(f :: RngUPolElt_FldPadExact : Strategy:="default") -> RngIntElt
  {The smallest valuation of the coefficients of f.}
  if not assigned f`min_valuation then
    require not IsWeaklyZero(f : Strategy:=Strategy): "f is weakly zero";
    v := Min([Valuation(c) : i in [0..WeakDegree(f)] | not WZERO(c) where c:=Coefficient(f`approximation,i)]);
    IncreaseAbsolutePrecision(f, v+1);
    f`min_valuation := WeakMinValuation(f);
  end if;
  return f`min_valuation;
end intrinsic;

intrinsic IsUnit(x :: FldPadExactElt) -> BoolElt
  {True if x has valuation 0.}
  return ValuationEq(x, 0);
end intrinsic;

intrinsic IsIntegral(x :: FldPadExactElt) -> BoolElt
  {"}
  return ValuationGe(x, 0);
end intrinsic;

intrinsic ShiftValuation(x :: FldPadExactElt, n :: RngIntElt) -> FldPadExactElt
  {Returns x*pi^n.}
  if n eq 0 then
    return x;
  end if;
  K := Parent(x);
  init := ShiftValuation(Approximation(x, CAPR(x)), n);
  mkupdate := func<z | function(apr)
    return Approximation_Lazy(x, apr-n) mod function (xx)
      Update(z, ShiftValuation(xx, n));
      return true;
    end function;
  end function>;
  return K ! <init, mkupdate>;
end intrinsic;

intrinsic ShiftValuation(x :: FldPadExactElt, n) -> FldPadExactElt
  {"}
  ok, n := IsValidAbsolutePrecision(x, n);
  require ok: n;
  return ShiftValuation(x, IntegerValue(n));
end intrinsic;

// points <x,y> on the edge of the newton polygon with integer coefficients
function nwtnpgon_integer_points(np)
  vs := [car<Z,Z>| v : v in Vertices(np)];
  if #vs eq 0 then
    return vs;
  end if;
  return &cat[i eq 1 select [vs[i]] else ([<j, y0+h*((j-x0) div e)> : j in [x0+e..x1 by e]] where h:=Numerator(s) where e:=Denominator(s) where s:=(y1-y0)/(x1-x0) where x0:=vs[i-1][1] where y0:=vs[i-1][2] where x1:=vs[i][1] where y1:=vs[i][2]) : i in [1..#vs]];
end function;

intrinsic WeakPartialNewtonPolygon(f :: RngUPolElt_FldPadExact) -> NwtnPgon
  {A fragment of the Newton polygon of f, based on its non weakly zero coefficients.}
  df := WeakDegree(f);
  // trivial cases
  if df lt 0 then
    return NewtonPolygon([] : Faces:="Lower");
  elif df eq 0 then
    c := Coefficient(f`approximation, 0);
    if WZERO(c) then
      return NewtonPolygon([] : Faces:="Lower");
    else
      return NewtonPolygon([<0, VAL(c)>] : Faces:="Lower");
    end if;
  end if;
  // iterate until done
  while true do
    xf := f`approximation;
    // find the weak newton polygon of f
    wnp := NewtonPolygon([<i, v> : i in [0..df] | v lt OO where v:=VAL(Coefficient(xf,i))] : Faces:="Lower");
    // the non weakly zero coefficient valuations
    vals := [<i, VAL(c)> : i in [0..df] | not WZERO(c) where c:=Coefficient(xf, i)];
    // those lying on the edge of the Newton polygon
    good_vals := SORT(SequenceToSet(vals) meet SequenceToSet(nwtnpgon_integer_points(wnp)));
    // not many
    if #good_vals eq 0 then
      // if there are none, there's nothing we can do
      return NewtonPolygon([] : Faces:="Lower");
    elif #good_vals eq 1 then
      // if there is one and it's a vertex, then return that
      v := good_vals[1];
      if v in Vertices(wnp) then
        return NewtonPolygon([v] : Faces:="Lower");
      else
        return NewtonPolygon([] : Faces:="Lower");
      end if;
    end if;
    // the newton polygon around the good vertices
    np := NewtonPolygon(good_vals : Faces:="Lower");
    // compute the value of the Newton polygon at each integer 0..df
    // we want to be strictly more precise than this
    vs := ChangeUniverse(Vertices(np), car<Z,Z>);
    aprs := &cat[[y0+(j-x0)*s : j in [j0..j1]] where j0:=(i eq 2 select 0 else x0) where j1:=(i eq #vs select df else x1-1) where s:=(y1-y0)/(x1-x0) where x0,y0:=Explode(vs[i-1]) where x1,y1:=Explode(vs[i]) : i in [2..#vs]];
    assert #aprs eq df+1;
    // if we are already this precise, then we are done
    if forall{i : i in [0..df] | APR(Coefficient(xf, i)) gt aprs[i+1]} then
      return np;
    else
      IncreaseAbsolutePrecision(f, [<i, Floor(aprs[i+1]+1)> : i in [0..df]]);
    end if;
  end while;
end intrinsic;

intrinsic NewtonPolygon(f :: RngUPolElt_FldPadExact : Strategy:="default") -> NwtnPgon
  {The Newton polygon of f.}
  if not assigned f`newton_polygon then
    d := Degree(f : Strategy:=Strategy);
    // trivial case
    if d lt 0 then
      f`newton_polygon := NewtonPolygon([] : Faces:="Lower");
    else
      // check the top and bottom coefficients are nonzero simultaneously
      assert not WZERO(Coefficient(f, d));
      error if IsWeaklyZero(Coefficient(f, 0) : Strategy:=Strategy),
        "constant coefficient is weakly zero";
      // get an initial Newton polygon based on what we already know
      np := func<|NewtonPolygon([
        <i, Valuation(c)>
        : i in [0..d]
        | not WZERO(c)
        where c := Coefficient(f`approximation, i)
      ] : Faces:="Lower")>;
      np0 := np();
      // increase precision of f just enough to determine if there are any more unknowns
      IncreaseAbsolutePrecision(f, &cat[
        (j eq 1)
        select [<0,Ceiling(vs[j][2])>]
        else ([ 
            <i0+i,Ceiling(v0+i*s)>
            : i in [1..i1-i0]
          ] 
          where s:=(v1-v0)/(i1-i0)
          where i0:=CAST(Z, vs[j-1][1])
          where i1:=CAST(Z, vs[j][1])
          where v0:=CAST(Z, vs[j-1][2])
          where v1:=CAST(Z, vs[j][2])
        )
        : j in [1..#vs]
      ] where vs := Vertices(np0));
      // get the actual Newton polygon
      f`newton_polygon := np();
    end if;
  end if;
  return f`newton_polygon;
end intrinsic;


intrinsic ShiftArgument(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt) -> RngUPol_FldPadExact
  {The polynomial f(x+X).}
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "Arguments must be defined over a common field";
  f := ChangeRing(f, K);
  x := K ! x;
  R := Parent(f);
  xf := Approximation(f, CAPR(f));
  xx := Approximation(x, CAPR(x));
  init := Evaluate(xf, Parent(xf).1 + xx);
  e := AbsoluteRamificationDegree(K);
  df := WeakDegree(f);
  p := Prime(K);
  binvals := [[Valuation(Binomial(i,j),p)*e : i in [j..df]] : j in [0..df]];
  mkupdate := func<z | function (apr)
    // f(x+X) = sum_j X^j (sum_i f_i (i choose j) x^(i-j))
    // so f(x+X)_j = sum_i f_i (i choose j) x^(i-j)
    // so if we want f(x+X)_j to absolute precision apr(j)
    // then we want f_i (i choose j) x^(i-j) to absolute precision apr(j)
    // i.e. relative precision pr_ij apr(j) - val(f_i) - val(i choose j) - (i-j) val(x)
    // so we want f_i to absolute precision val(f_i) + pr_ij
    // and x to absolute precision val(x) + pr_ij
    vf := WVAL(f);
    vx := WVAL(x);
    pr := [[apr(j) - vf(i) - binvals[j+1][i-j+1] - vx*(i-j) : i in [j..df]] : j in [0..df]];
    aprx := vx + &join &cat pr;
    aprf := [<i, vf(i) + &join[pr[j+1][i-j+1] : j in [0..i]]> : i in [0..df]];
    return [Approximation_Lazy(f, aprf), Approximation_Lazy(x, aprx)] mod function (xf, xx)
      Update(z, Parent(xf)![&+[Coefficient(xf,i) * Binomial(i,j) * xx^(i-j) : i in [j..df]] : j in [0..df]]);
      return true;
    end function;
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;


// TODO: implement multivariate polynomial rings, and hensel-lifting of solutions of equations therein

declare verbose ExactpAdics_IsHenselLiftable_Root, 1;
declare verbose ExactpAdics_IsHenselLiftable_Factor, 1;

intrinsic IsHenselLiftable(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt : Strategy:="default") -> BoolElt, FldPadExactElt
  {True if x is sufficiently close to a root of f to be Hensel-liftable. If so, also returns the root.}
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "Coefficients of argument 1 and argument 2 must be coercible to a common field";
  f := ChangeRing(f, K);
  x := K ! x;
  R := Parent(f);
  // trivial case, no roots possible
  if WeakDegree(f) le 0 then
    return false, _;
  end if;
  // check the hensel condition
  // we take an approximation of f and x, compute g(X):=f(x+X), and see if its Newton polygon has a vertex at 1
  // we do this by computing the Newton polygon of the weak valuations of g, and seeing if this has a vertex at 1 and the coefficient is not weakly zero
  ok, _, res := ExactpAdics_ExecutePrecisionStrategy(function (pr)
    xf, xx := Explode(Evaluate(Flatten([Approximation_Lazy(f, BaselineValuation(f) + pr), Approximation_Lazy(x, BaselineValuation(x) + pr)])));
    xR := Parent(xf);
    xg := Evaluate(xf, xR.1 + xx);
    np := NewtonPolygon([<i, v> : i in [0..Degree(xg)] | v lt OO where v:=VAL(Coefficient(xg, i))] : Faces:="Lower");
    vs := ChangeUniverse(Vertices(np), car<Z,Z>);
    // these asserts may not hold; it is possible that g has some exactly zero coefficients
    // TODO: deal with this case
    assert vs[1][1] eq 0;
    assert vs[2][1] ge 1;
    // if there is a vertex at 1...
    if vs[2][1] eq 1 then
      // ... and it is a real vertex ...
      if not WZERO(Coefficient(xg, 1)) then
        // then we have a root
        return true, [*true,vs[1][2],vs[2][2]*];
      else
        // else, we don't know
        return false, _;
      end if;
    end if;
    // if there is a face from 0 to n, n>1, then it is not hensel liftable
    assert vs[2][1] gt 1;
    x0,y0:=Explode(vs[1]);
    x1,y1:=Explode(vs[2]);
    s := (y1-y0)/(x1-x0);
    if not WZERO(Coefficient(xg, 0)) and exists{i : i in [2..x1] | (not WZERO(c)) and VAL(c) eq y0+s*(i-x0) where c:=Coefficient(xg, i)} then
      return true, [*false*];
    end if;
    // otherwise we don't know
    return false, false;
  end function, Strategy);
  // did we pass?
  if not res[1] then
    return false, _;
  end if;
  // hooray! now find a lift
  val0 := res[2];
  val1 := res[3];
  g := ShiftArgument(f, x);
  s := val0 - val1;
  h := ShiftSlope(g, s : Offset:=-val0);
  xh := Approximation(h, 1);
  assert VAL(Coefficient(xh, 0)) ge 0;
  assert VAL(Coefficient(xh, 1)) eq 0 and not WZERO(Coefficient(xh, 1));
  assert forall{i : i in [2..WeakDegree(h)] | VAL(Coefficient(xh, i)) gt 0};
  // now hensel lift a root of h
  rh := K!<init, mkupdate>
    where init := Coefficient(xh, 0) / Coefficient(xh, 1)
    where mkupdate := func<z | function (apr)
      n := IntegerValue(apr);
      assert n gt 0;
      return [Approximation_Lazy(K, n), Approximation_Lazy(h, apr)] mod function (xK, xh)
        Q := quo<Integers(xK) | ShiftValuation(xK!1, n)>;
        qh := ChangeRing(xh, Q);
        qr := Q ! z`approximation;
        dqh := Derivative(qh);
        while true do
          qhr := Evaluate(qh, qr);
          dqhr := Evaluate(dqh, qr);
          s := VAL(qhr);
          assert VAL(dqhr) eq 0;
          if s eq n then
            break;
          else
            qr2 := qr - qhr div dqhr;
            assert VAL(Evaluate(qh,qr2)) ge Min(n,2*s);
            qr := qr2;
          end if;
        end while;
        Update(z, xK ! qr);
        return true;
      end function;
    end function>;
  // translate back to a root of f and we're done
  return true, ShiftValuation(rh, s) + x;
end intrinsic;

// intrinsic IsHenselLiftable
//   ( f :: RngUPolElt_FldPadExact
//   , x :: FldPadExactElt
//   : Strategy := "default"
//   , ShiftValuation := false
//   , ShiftSlope := false
//   ) -> BoolElt, FldPadExactElt
//   {Returns true if x is sufficiently close to a root of f to be Hensel-liftable, and if so, also returns the root.}
//   // PUT f AND x IN THE SAME FIELD
//   ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
//   require ok: "f and x must come from a common field";
//   f := ChangeRing(f, K);
//   x := CAST(K, x);
//   R := Parent(f);
//   // DESLOPE f
//   case [*ShiftSlope*]:
//   when [*false*]:
//     require IsIntegral(x): "x must be integral";
//     vx := 0;
//   when [*true*]:
//     vx := Valuation(x : Strategy:=Strategy);
//   when [*"Weak"*]:
//     vx := WeakValuation(x);
//   else
//     error "bad ShiftSlope option";
//   end case;
//   x := SHIFT_VAL(x, -vx);
//   f := SHIFT_SLOPE(f, vx);
//   assert IsIntegral(x);
//   // CHECK f IS INTEGRAL
//   case [*ShiftValuation*]:
//   when [*false*]:
//     require IsIntegral(f): "f must be integral";
//   when [*true*]:
//     v := Valuation(f : Strategy:=Strategy);
//     f := SHIFT_VAL(f, -v);
//   when [*"Weak"*]:
//     v := WeakValuation(f : Strategy:=Strategy);
//     f := SHIFT_VAL(f, -v);
//   else
//     error "bad ShiftValuation option";
//   end case;
//   assert IsIntegral(f);
//   // CHECK THE HENSEL CONDITION v(f(x)) > 2*v(f'(x))
//   fx := Evaluate(f, x);
//   df := Derivative(f);
//   dfx := Evaluate(df, x);
//   function hc()
//     if not WZERO(fx) then
//       s := Valuation(fx);
//       return true, ValuationLt(dfx, Ceiling(s/2));
//     elif not WZERO(dfx) then
//       t := Valuation(dfx);
//       return true, ValuationGt(fx, 2*t);
//     else
//       return false, _;
//     end if;    
//   end function;
//   ok, hcok := hc();
//   if not ok then
//     ok, _, hcok := ExactpAdics_ExecutePrecisionStrategy(function (apr)
//       IncreaseAbsolutePrecisions([*[*fx, apr*], [*dfx, apr*]*]);
//       return hc();
//     end function, Strategy, 0);
//     if not ok then
//       error "f(x) and f'(x) both weakly zero";
//     end if;
//   end if;
//   if not hcok then
//     return false, _;
//   end if;
//   // CONDITION SATISFIED, NOW RETURN THE LIFT
//   t := Valuation(dfx);
//   s := WeakValuation(fx);
//   xx := x`approximation;
//   init := CHANGE_APR(xx, s-t);
//   mkupdate := func<z | function (apr)
//     v := WeakValuation(z) meet WeakMinValuation(f);
//     pr := (apr + t - v) join 0;
//     return ExactpAdics_GeneralGetter(pr,
//       procedure (~pr, ~g)
//         g := Approximation_Lazy(f, v+pr);
//       end procedure,
//       procedure (xf, ~pr, ~val)
//         xz := CAST(BaseRing(xf), GetData(z));
//         xz2 := HenselLift(xf, xz);
//         xfz2 := Evaluate(xf, xz2);
//         // assert WZERO(xfz2);
//         s := Valuation(xfz2);
//         d := apr + t - s;
//         if d gt 0 then
//           pr +:= d;
//         else
//           Update(z, CHANGE_APR(xz2, s-t));
//           SetData(z, xz2);
//           val := true;
//         end if;
//       end procedure
//     );
//   end function>;
//   y := K ! <init, mkupdate, xx>;
//   return true, SHIFT_VAL(y, vx);
// end intrinsic;

intrinsic IsHenselLiftable(f :: RngUPolElt_FldPadExact, x :: . : Strategy:="default") -> BoolElt, FldPadExactElt
  {"}
  ok, x := IsCoercible(BaseRing(f), x);
  require ok: "x must be coercible into the base ring of f";
  // IncreaseAbsolutePrecision(x, AbsolutePrecision(f));
  return IsHenselLiftable(f, x : Strategy:=Strategy);
end intrinsic;

intrinsic IsHenselLiftable(f :: RngUPolElt, x :: FldPadExactElt : Strategy:="default") -> BoolElt, FldPadExactElt
  {"}
  ok, f := CanChangeRing(f, Parent(x));
  require ok: "coefficients of f must be coercible to the field containing x";
  // IncreaseAbsolutePrecision(f, AbsolutePrecision(x));
  return IsHenselLiftable(f, x : Strategy:=Strategy);
end intrinsic;

intrinsic HenselLift(f :: RngUPolElt_FldPadExact, x : Strategy:="default") -> FldPadExactElt
  {Returns the root of f Hensel lifted from x.}
  ok, y := IsHenselLiftable(f, x : Strategy:=Strategy);
  if ok then
    return y;
  else
    error "not Hensel liftable";
  end if;
end intrinsic;

intrinsic HenselLift(f :: RngUPolElt, x : Strategy:="default") -> FldPadExactElt
  {"}
  ok, y := IsHenselLiftable(f, x : Strategy:=Strategy);
  if ok then
    return y;
  else
    error "not Hensel liftable";
  end if;
end intrinsic;

function polyVal(f)
  cs := Coefficients(f);
  if #cs eq 0 then
    return Infinity();
  else
    return Min([Valuation(c) : c in Coefficients(f)]);
  end if;
end function;

// function henselLiftFactorization(f, g, h)
//   dg := Degree(g);
//   dh := Degree(h);
//   df := Degree(f);
//   assert df eq dg+dh;
//   pr := Precision(BaseRing(f));
//   g := ChangePrecision(g, pr);
//   h := ChangePrecision(h, pr);
//   // print "f =", [<RationalField() ! c, AbsolutePrecision(c)> : c in Coefficients(f)];
//   K := BaseRing(f);
//   V := VectorSpace(K, df);
//   M := MatrixAlgebra(K, df);
//   res := Resultant(g, h);
//   assert not WZERO(res);
//   t := Valuation(res);
//   d := g*h - f;
//   s := polyVal(d);
//   assert s ge 2*t + 1;
//   while true do
//     // print "  g =", [<RationalField() ! c, AbsolutePrecision(c)> : c in Coefficients(g)];
//     // print "  h =", [<RationalField() ! c, AbsolutePrecision(c)> : c in Coefficients(h)];
//     r := s - t;
//     b := ShiftValuation(d, -r);
//     B := CAST(V, [Coefficient(b,i) : i in [0..df-1]]);
//     R := CAST(M,
//       [ [ j ge i
//           select Coefficient(g,j-i)
//           else 0
//           : j in [0..df-1]
//         ]
//         : i in [0..dh-1]
//       ]
//       cat
//       [ [ j ge i
//           select Coefficient(h,j-i)
//           else 0
//           : j in [0..df-1]
//         ]
//         : i in [0..dg-1]
//       ]
//     );
//     assert Valuation(Determinant(R)) eq t;
//     U := Solution(R, B);
//     gnew := ChangePrecision(g - Polynomial([ShiftValuation(U[dh+i], r) : i in [1..dg]]), pr);
//     hnew := ChangePrecision(h - Polynomial([ShiftValuation(U[i], r) : i in [1..dh]]), pr);
//     assert Valuation(Resultant(gnew, hnew)) eq t;
//     dnew := gnew*hnew - f;
//     if WEQ(gnew, g) and WEQ(hnew, h) then
//       assert WZERO(dnew);
//       return gnew, hnew;
//     else
//       snew := Min([Valuation(c) : c in Coefficients(dnew)]);
//       assert WEQ(gnew, g) or polyVal(gnew - g) ge r;
//       assert WEQ(hnew, h) or polyVal(hnew - h) ge r;
//       assert WZERO(dnew) or polyVal(dnew) ge 2*r;
//       g := gnew;
//       h := hnew;
//       d := dnew;
//       s := snew;
//     end if;
//   end while;
// end function;

// function henselLiftFactorization2(f, g, h)
//   dg := Degree(g);
//   dh := Degree(h);
//   df := Degree(f);
//   assert df eq dg+dh;
//   pr := Max([AbsolutePrecision(c) : c in Coefficients(f) | AbsolutePrecision(c) lt OO]);
//   R := Parent(f);
//   K := BaseRing(R);
//   OK := Integers(K);
//   QK := quo<OK | ShiftValuation(OK!1, pr)>;
//   QR := PolynomialRing(QK);
//   f := QR ! f;
//   g := QR ! g;
//   h := QR ! h;
//   // print "f =", [<RationalField() ! c, AbsolutePrecision(c)> : c in Coefficients(f)];
//   V := RSpace(QK, df);
//   M := MatrixAlgebra(QK, df);
//   res := Resultant(g, h);
//   assert not WZERO(res);
//   t := Valuation(res);
//   d := g*h - f;
//   s := Min(polyVal(d), pr);
//   assert s ge 2*t + 1;
//   while true do
//     // print "  g =", [<RationalField() ! c, AbsolutePrecision(c)> : c in Coefficients(g)];
//     // print "  h =", [<RationalField() ! c, AbsolutePrecision(c)> : c in Coefficients(h)];
//     r := s - t;
//     b := ShiftValuation(d, -r);
//     Bvec := CAST(V, [Coefficient(b,i) : i in [0..df-1]]);
//     Rmat := CAST(M,
//       [ [ j ge i
//           select Coefficient(g,j-i)
//           else 0
//           : j in [0..df-1]
//         ]
//         : i in [0..dh-1]
//       ]
//       cat
//       [ [ j ge i
//           select Coefficient(h,j-i)
//           else 0
//           : j in [0..df-1]
//         ]
//         : i in [0..dg-1]
//       ]
//     );
//     assert Valuation(Determinant(Rmat)) eq t;
//     ok, U := IsConsistent(Rmat, Bvec);
//     if not ok then
//       print "WARNING: IsHenselLiftable: Using IsInvertible because IsConsistent failed!";
//       ok, Rinv := IsInvertible(Rmat);
//       assert ok;
//       U := Bvec * Rinv;
//     end if;
//     gnew := g - Polynomial([QK|ShiftValuation(U[dh+i], r) : i in [1..dg]]);
//     hnew := h - Polynomial([QK|ShiftValuation(U[i], r) : i in [1..dh]]);
//     assert Valuation(Resultant(gnew, hnew)) eq t;
//     dnew := gnew*hnew - f;
//     if WEQ(gnew, g) and WEQ(hnew, h) then
//       assert WZERO(dnew);
//       return R!gnew, R!hnew;
//     else
//       snew := Min(polyVal(dnew), pr);
//       assert WEQ(gnew, g) or polyVal(gnew - g) ge r;
//       assert WEQ(hnew, h) or polyVal(hnew - h) ge r;
//       assert WZERO(dnew) or snew ge 2*r;
//       g := gnew;
//       h := hnew;
//       d := dnew;
//       s := snew;
//     end if;
//   end while;
// end function;

// intrinsic HenselLift_Doris(f :: RngUPolElt[FldPad], g :: RngUPolElt[FldPad], h :: RngUPolElt[FldPad]) -> RngUPolElt, RngUPolElt
//   {Assuming g and h satisfy the Hensel condition v(f-g*h) > 2*v(Res(g,h)), returns the lifts of g and h to the highest precision possible.}
//   return henselLiftFactorization2(f, g, h);
// end intrinsic;

// intrinsic IsHenselLiftable
//   ( f :: RngUPolElt_FldPadExact   // a polynomial
//   , g :: RngUPolElt_FldPadExact   // an approximate factor
//   : Strategy := "default"        // default strategy
//   , ShiftSlope := false
//   , ShiftValuation := false
//   , WeakResultant := false
//   ) -> BoolElt, RngUPolElt_FldPadExact
//   {Returns true if g is sufficiently close to a factor of f to be Hensel-liftable, and if so, returns the factor.}
//   // PUT f AND g OVER THE SAME FIELD
//   ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
//   require ok: "f and g must be defined over a common field";
//   f := CAST(R, f);
//   g := CAST(R, g);
//   // Shift slopes
//   if ShiftSlope cmpeq false then
//     slope := 0;
//   elif ShiftSlope cmpeq true then
//     npg := NewtonPolygon(g : Strategy:=Strategy);
//     slope := -Ceiling(Max(Slopes(npg)));
//   elif Type(ShiftSlope) eq RngIntElt then
//     slope := ShiftSlope;
//   else
//     error "bad ShiftSlope option";
//   end if;
//   f := SHIFT_SLOPE(f, slope : Pivot:=WeakDegree(f));
//   g := SHIFT_SLOPE(g, slope : Pivot:=WeakDegree(g));
//   // Shift valuations
//   if ShiftValuation cmpeq false and ShiftSlope cmpeq false then
//     vf := 0;
//     vg := 0;
//     require IsIntegral(f): "f must be integral";
//     require IsIntegral(g): "g must be integral";
//   elif ShiftValuation cmpeq true
//   or (ShiftValuation cmpeq false and ShiftSlope cmpne false)
//   then
//     vf := -Valuation(f : Strategy:=Strategy);
//     vg := -Valuation(g : Strategy:=Strategy);
//   elif ShiftValuation cmpeq "Weak" then
//     vf := -WeakValuation(f);
//     vg := -WeakValuation(g);
//   else
//     error "bad ShiftValuation option";
//   end if;
//   f := SHIFT_VAL(f, vf);
//   g := SHIFT_VAL(g, vg);
//   assert IsIntegral(f);
//   assert IsIntegral(g);
//   // Compute the co-factor
//   h := f div g;
//   // Compute a resultant
//   dg := Degree(g : Strategy:=Strategy);
//   res := WeakResultant select WRES(g, h) else RES(g, h);
//   // Compute the error
//   err := f - g*h;
//   // Check the Hensel condition
//   function hc()
//     if not WZERO(res) then
//       return true, ValuationGt(err, 2*VAL(res));
//     elif not WZERO(err) then
//       return true, ValuationLt(res, Ceiling(VAL(err)/2));
//     else
//       return false, _;
//     end if;
//   end function;
//   ok, hcok := hc();
//   if not ok then
//     ok, _, hcok := ExactpAdics_ExecutePrecisionStrategy(function (apr)
//       IncreaseAbsolutePrecisions([*<err, apr>, <res, apr>*]);
//       return hc();
//     end function, Strategy, 0);
//     if not ok then
//       error "resultant and f-gh both weakly zero";
//     end if;
//   end if;
//   if not hcok then
//     return false, _;
//   end if;
//   // hensel condition passed, now find the factor
//   df := WeakDegree(f);
//   dh := df - dg;
//   lcg := Coefficient(g, dg);
//   lcf := Coefficient(f, df);
//   if dg eq df then
//     assert not IsWeaklyZero(lcg : Strategy:=Strategy);
//     assert not IsWeaklyZero(lcf : Strategy:=Strategy);
//     gg := f * (lcg / lcf);
//   else
//     assert dg lt df;
//     lch := lcf / lcg;
//     t := Valuation(res);
//     s := WeakValuation(err);
//     xg := Approximation(g);
//     xh := Approximation(h);
//     init := CAP_APR(xg, [s-t : i in [0..Degree(xg)]]);
//     mkupdate := func<z | function (aprs)
//       apr := Max(aprs);
//       v := Min([WeakValuation(z), WeakValuation(f), WeakValuation(lcg), WeakValuation(lch)]);
//       pr := apr + t - v;
//       if pr gt 0 then
//         return ExactpAdics_GeneralGetter(pr,
//           procedure (~pr, ~g)
//             g := Flatten([
//               Approximation_Lazy(f : APr:=v+pr),
//               Approximation_Lazy(lcg : APr:=v+pr),
//               Approximation_Lazy(lch : APr:=v+pr)
//             ]);
//           end procedure,
//           procedure (x, ~pr, ~val)
//             // we don't require that the f, g or h be monic, and Hensel lifting assumes that the top coefficient is already correct and only changes lower coefficients, so we need to put the exact correct coefficients in
//             xf, xlcg, xlch := Explode(x);
//             xg_old, xh_old := Explode(GetData(z));
//             xf := [BaseRing(xf) | Coefficient(xf, i) : i in [0..df]] @ Polynomial;
//             xg := [BaseRing(xf) | i eq dg select xlcg else Coefficient(xg_old, i) : i in [0..dg]] @ Polynomial;
//             xh := [BaseRing(xf) | i eq dh select xlch else Coefficient(xh_old, i) : i in [0..dh]] @ Polynomial;
//             xg2, xh2 := henselLiftFactorization2(xf, xg, xh);
//             xd := xf - xg2*xh2;
//             s := polyVal(xd);
//             d := apr + t - s;
//             if d le 0 then
//               Update(z, CAP_APR(xg2, [s-t : i in [0..Degree(xg2)]]));
//               SetData(z, [*xg2, xh2*]);
//               val := true;
//             else
//               pr +:= d;
//             end if;
//           end procedure);
//       else
//         UpdateZero(z, aprs);
//       end if;
//     end function>;
//     gg := R ! <init, mkupdate, [*xg,xh*]>;
//   end if;
//   return true, SHIFT_SLOPE(SHIFT_VAL(gg, -vg), -slope);
// end intrinsic;

// intrinsic HenselLift
//   ( f :: RngUPolElt_FldPadExact   // a polynomial
//   , g :: RngUPolElt_FldPadExact   // an approximate factor
//   : Strategy := "default"        // default strategy
//   , ShiftSlope := false
//   , ShiftValuation := false
//   , WeakResultant := false
//   ) -> RngUPolElt_FldPadExact
//   {Hensel lifts g to a factor of f.}
//   ok, g2 := IsHenselLiftable(f, g : Strategy:=Strategy, ShiftSlope:=ShiftSlope, ShiftValuation:=ShiftValuation, WeakResultant:=WeakResultant);
//   require ok: "not hensel liftable";
//   return g2;
// end intrinsic;

intrinsic CanChangeRing(f :: RngUPolElt_FldPadExact, K :: FldPadExact) -> RngUPolElt_FldPadExact
  {True if f can be coerced to a polynomial over K. If so, also returns the coerced polynomial.}
  if BaseRing(f) eq K then
    return true, f;
  else
    return IsCoercible(PolynomialRing(K), f);
  end if;
end intrinsic;

intrinsic CanChangeRing(f :: RngUPolElt, K :: FldPadExact) -> RngUPolElt_FldPadExact
  {"}
  return IsCoercible(PolynomialRing(K), f);
end intrinsic;

intrinsic ChangeRing(f, K) -> .
  {Change the ring of f to K.}
  ok, g := CanChangeRing(f, K);
  if ok then
    return g;
  else
    error "not coercible:", g;
  end if;
end intrinsic;

function shiftVal(x, n)
  y := ShiftValuation(x, n);
  // print "shift", x, y;
  assert AbsolutePrecision(y) eq AbsolutePrecision(x)+n;
  assert Valuation(y) eq Valuation(x)+n;
  assert Precision(y) eq Precision(x);
  // if not WZERO(x) then
  //   assert not WZERO(y);
  //   assert WZERO(ShiftValuation(x/y, n)-1);
  // end if;
  return y;
end function;

function shiftVal_poly(f, ns)
  cs := Coefficients(f);
  return Parent(f) ! [shiftVal(cs[i], ns[i]) : i in [1..#cs]];
end function;

intrinsic ShiftValuation(f :: RngUPolElt_FldPadExact, ns) -> RngUPolElt_FldPadExact
  {f with coefficients shifted by corresponding elements of ns.}
  ok, ns := IsValidAbsolutePrecision(f, ns);
  require ok: "Argument 2 must be coercible to a valuation of f";
  if IsDefinitelyZero(f) then
    return f;
  end if;
  d := WeakDegree(f);
  nseq := [IntegerValue(ns(i)) : i in [0..d]];
  init := shiftVal_poly(Approximation(f, CAPR(f)), nseq);
  mkupdate := func<z | function (aprs)
    return Approximation_Lazy(f, aprs - ns)
    mod function (xf)
      Update(z, shiftVal_poly(xf, nseq));
      return true;
    end function;
  end function>;
  return Parent(f) ! <init, mkupdate>;
end intrinsic;

intrinsic ShiftSlope(f :: RngUPolElt_FldPadExact, n : Pivot:=0, Offset:=0) -> RngUPolElt_FldPadExact
  {Returns f(x*pi^n)/pi^(n*Pivot) (which increases the slopes of the Newton polygon of f by n, and leaves the Pivot'th coefficient the same).}
  n := Val_FldPadElt_Make(n);
  Offset := Val_FldPadElt_Make(Offset);
  require Type(Pivot) eq RngIntElt: "Pivot must be an integer";
  if ((n eq 0) and (Offset eq 0)) or IsDefinitelyZero(f) then
    return f;
  end if;
  return ShiftValuation(f, [<i, n*(i - Pivot)+Offset> : i in [0..WeakDegree(f)]]);
end intrinsic;

intrinsic SetData(x :: FldPadExactElt, data)
  {Sets the custom data field.}
  x`data := data;
end intrinsic;

intrinsic SetData(f :: RngUPolElt_FldPadExact, data)
  {"}
  f`data := data;
end intrinsic;

intrinsic GetData(x :: FldPadExactElt) -> .
  {Retrieves the custom data field.}
  return x`data;
end intrinsic;

intrinsic GetData(f :: RngUPolElt_FldPadExact) -> .
  {"}
  return f`data;
end intrinsic;

intrinsic IsIntegral(f :: RngUPolElt_FldPadExact) -> RngUPolElt
  {"}
  if not assigned f`is_integral then
    // can we answer without increasing precision?
    if exists{c : c in Coefficients(f`approximation) | (not WZERO(c)) and Valuation(c) lt 0} then
      f`is_integral := false;
    else
      // now increase precision and check again
      IncreaseAbsolutePrecision(f, 0);
      f`is_integral := forall{c : c in Coefficients(f`approximation) | Valuation(c) ge 0};
    end if;
  end if;
  return f`is_integral;  
end intrinsic;

intrinsic Derivative(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> RngUPolElt_FldPadExact
  {The nth derivative of f.}
  require n ge 0: "n must be non-negative";
  if n eq 0 then
    return f;
  end if;
  R := Parent(f);
  d := WeakDegree(f);
  if n gt d then
    return CAST(R, 0);
  end if;
  if not assigned f`derivative then
    f`derivative := [];
  end if;
  if not IsDefined(f`derivative, n) then
    K := BaseRing(R);
    e := AbsoluteRamificationDegree(K);
    p := Prime(K);
    bs := [NumberOfPermutations(i,n) : i in [n..d]];
    vbs := [e*Valuation(b,p) : b in bs];
    init := Derivative(Approximation(f, CAPR(f)), n);
    mkupdate := func<z | function (aprs)
      faprs := AbsolutePrecision(f);
      return Approximation_Lazy(f, [i lt n select <i, faprs(i)> else <i, aprs(i-n)-vbs[i-n+1]> : i in [n..WeakDegree(f)]]) mod function (xf)
        Update(z, Derivative(xf, n));
        return true;
      end function;
    end function>;
    f`derivative[n] := R ! <init, mkupdate>;
  end if;
  return f`derivative[n];
end intrinsic;

intrinsic Derivative(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {The derivative of f.}
  return Derivative(f, 1);
end intrinsic;

declare verbose ExactpAdics_Evaluate, 2;

intrinsic Evaluate(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {f(g).}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "Argument 1 and argument 2 must be coercible to a common ring";
  f := R ! f;
  g := R ! g;
  // trivial cases
  if IsDefinitelyZero(f) or WeakDegree(f) eq 0 then
    return f;
  elif IsDefinitelyZero(g) then
    return Slice(f, [0]);
  elif WeakDegree(g) eq 0 then
    return Evaluate(f, Coefficient(g,0));
  end if;
  // main case (f and g are both non-constant)
  return &+[Coefficient(f,i) * g^i : i in [0..WeakDegree(f)]];
end intrinsic;

intrinsic Evaluate(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt) -> FldPadExactElt
  {f(x).}
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "x and the coefficients of f must lie in the same field";
  f := ChangeRing(f, K);
  x := CAST(K, x);
  R := Parent(f);
  // trivial cases
  if IsDefinitelyZero(f) then
    return CAST(K, 0);
  elif IsDefinitelyZero(x) or WeakDegree(f) eq 0 then
    return Coefficient(f, 0);
  end if;
  // main case
  xf := Approximation(f, CAPR(f));
  xx := Approximation(x, CAPR(x));
  init := Evaluate(xf, xx);
  mkupdate := func<z | function (apr)
    vx := WeakValuation(x);
    d := WeakDegree(f);
    vfs := WeakValuation(f);
    pr := apr - &meet ShiftSlope(vfs, vx);
    return [
      Approximation_Lazy(f, [<i,apr-i*vx> : i in [0..d]]),
      Approximation_Lazy(x, vx+pr)
    ] mod function (xf, xx)
      Update(z, Evaluate(xf, xx));
      return true;
    end function;
  end function>;
  ret := K ! <init, mkupdate>;
  return ret;
end intrinsic;

intrinsic Evaluate(f :: RngUPolElt_FldPadExact, x) -> FldPadExactElt
  {"}
  ok, x := IsCoercible(BaseRing(f), x);
  require ok: "x must be coercible to the coefficient ring of f";
  return Evaluate(f, x);
end intrinsic;

intrinsic Evaluate(f :: RngUPolElt, x :: FldPadExactElt) -> FldPadExactElt
  {"}
  ok, f := CanChangeRing(f, Parent(x));
  require ok: "f must be coercible to the field containing x";
  return Evaluate(f, x);
end intrinsic;

issqfree := IsSquarefree;

intrinsic Integers(F :: FldPadExact, v :: RngIntElt) -> RngPadExact
  {The ring of elements of F of valuation at least v.}
  if v eq 0 and assigned F`integers then
    return F`integers;
  end if;
  R := New(RngPadExact);
  R`id := NEXTID();
  R`radius := v;
  R`field_of_fractions := F;
  if v eq 0 then
    F`integers := R;
  end if;
  return R;
end intrinsic;

intrinsic Integers(F :: FldPadExact) -> RngPadExact
  {The ring of integers of F.}
  return Integers(F, 0);
end intrinsic;

intrinsic FieldOfFractions(F :: FldPadExact) -> FldPadExact
  {The field of fractions.}
  return F;
end intrinsic;

intrinsic FieldOfFractions(R :: RngPadExact) -> FldPadExact
  {"}
  return R`field_of_fractions;
end intrinsic;

intrinsic Print(R :: RngPadExact, lvl :: MonStgElt)
  {Prints R.}
  case lvl:
  when "Magma":
    printf "Integers(%m, %m)", R`field_of_fractions, R`radius;
  else
    if R`radius eq 0 then
      printf "Ring of integers of %O", R`field_of_fractions, lvl;
    else
      printf "Ring of elements of valuation at least %O of %O", R`radius, lvl, R`field_of_fractions, lvl;
    end if;
  end case;
end intrinsic;

intrinsic 'eq'(R :: RngPadExact, S :: RngPadExact) -> BoolElt
  {Equality.}
  return (R`field_of_fractions eq S`field_of_fractions) and (R`radius eq S`radius);
end intrinsic;

intrinsic IsCoercible(R :: RngPadExact, X) -> BoolElt, .
  {True if X is coercible into R and the coerced element.}
  ok, x := IsCoercible(FieldOfFractions(R), X);
  if ok then
    return IsCoercible(R, x);
  end if;
  return false, "not coercible";
end intrinsic;

intrinsic IsCoercible(R :: RngPadExact, X :: FldPadExactElt) -> BoolElt, .
  {"}
  ok, x := IsCoercible(FieldOfFractions(R), X);
  if ok then
    if ValuationGe(x, R`radius) then
      y := New(RngPadExactElt);
      y`parent := R;
      y`field_element := x;
      y`id := NEXTID();
      return true, y;
    else
      return false, "valuation too small";
    end if;
  end if;
  return false, "not coercible";
end intrinsic;

intrinsic IsCoercible(R :: RngPadExact, X :: RngPadExactElt) -> BoolElt, .
  {"}
  if Parent(X) eq R then
    return true, X;
  else
    return IsCoercible(R, X`field_element);
  end if;
end intrinsic;

intrinsic Parent(x :: RngPadExactElt) -> RngPadExact
  {Parent of x.}
  return x`parent;
end intrinsic;

intrinsic Print(x :: RngPadExactElt, lvl :: MonStgElt)
  {Print.}
  Print(x`field_element, lvl);
end intrinsic;

intrinsic Random(R :: RngPadExact) -> RngPadExactElt
  {A random element of R.}
  return CAST(R, Random(FieldOfFractions(R), R`radius));
end intrinsic;

intrinsic Format(x :: FldPadExactElt : APr := AbsolutePrecision(x) meet (WeakValuation(x) + 1)) -> MonStgElt
  {Returns a string representation of x.}
  ok, APr := IsValidAbsolutePrecision(x, APr);
  require ok: "APr: " cat APr;
  IncreaseAbsolutePrecision(x, APr);
  return Sprintf("%o", CHANGE_APR(x`approximation, APr));
end intrinsic;

intrinsic Format(f :: RngUPolElt_FldPadExact : APr := AbsolutePrecision(f) meet (WeakValuation(f) + 1)) -> MonStgElt
  {Returns a string representation of f.}
  ok, APr := IsValidAbsolutePrecision(f, APr);
  require ok: "APr: " cat APr;
  IncreaseAbsolutePrecision(f, APr);
  // renewEltApproximation_poly(f);
  return Sprintf("%o", CHANGE_APR(f`approximation, APr));
end intrinsic;

intrinsic Random(R :: RngUPol_FldPadExact, d :: RngIntElt : Eisenstein:=false, Inertial:=false, Monic:=false, Irreducible:=false) -> RngUPolElt_FldPadExact
  {A random element of R of the given degree.}
  K := BaseRing(R);
  Monic or:= Eisenstein or Inertial;
  error if Monic and d lt 0, "Monic polynomials have degree at least 0";
  repeat
    ok := true;
    if Eisenstein then
      require d ge 1: "Eisenstein polynomials have degree at least 1";
      f := CAST(R, [K|
        (i eq 0) select
          RandomUnit(K,1)
        else (i eq d) select
          Monic select
            1
          else
            RandomUnit(K)
        else
          Random(K,1)
        : i in [0..d]
      ]);
    elif Inertial then
      repeat
        f := CAST(R, [K|
          (i eq 0) select
            RandomUnit(K)
          else (i eq d) select
            Monic select
              1
            else
              RandomUnit(K)
          else
            RandomInteger(K)
          : i in [0..d]
        ]);
      until IsInertial(f);
    else
      f := CAST(R, [K| (i eq d and Monic) select 1 else RandomInteger(K) : i in [0..d]]);
      if Irreducible then
        ok and:= IsIrreducible(f);
      end if;
    end if;
  until ok;
  return f;
end intrinsic;

intrinsic '/'(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt : Strategy:="default") -> RngUPolElt_FldPadExact
  {Division.}
  ok, F := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "x and the coefficients of f must come from the same field";
  R := PolynomialRing(F);
  f := CAST(R, f);
  x := CAST(F, x);
  // check x is non-zero
  if IsDefinitelyZero(x) then
    error "division by zero";
  elif IsWeaklyZero(x : Strategy:=Strategy) then
    error "division by weak zero";
  end if;
  // trivial cases
  if IsDefinitelyZero(f) then
    return f;
  end if;
  // general case
  vx := Valuation(x);
  init := Approximation(f, CAPR(f)) / Approximation(x, CAPR(x));
  mkupdate := func<z | function (aprs)
    pr := &join(aprs - WeakValuation(f) + vx);
    if pr gt 0 then
      return [
        Approximation_Lazy(f, aprs+vx),
        Approximation_Lazy(x, pr+vx)
      ] mod function (xf, xx)
        Update(z, xf / xx);
        return true;
      end function;
    else
      UpdateZero(z, aprs);
      return true;
    end if;
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;

intrinsic '/'(f :: RngUPolElt, x :: FldPadExactElt : Strategy:="default") -> RngUPolElt_FldPadExact
  {"}
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  f := ChangeRing(f, K);
  x := K ! x;
  return '/'(f, x : Strategy:=Strategy);
end intrinsic;

intrinsic '/'(f :: RngUPolElt_FldPadExact, x : Strategy:="default") -> RngUPol_FldPadExact
  {"}
  ok, K := ExistsCoveringStructure(BaseRing(f), Parent(x));
  f := ChangeRing(f, K);
  x := K ! x;
  return '/'(f, x : Strategy:=Strategy);
end intrinsic;

intrinsic '*'(f :: RngUPolElt_FldPadExact, x :: FldPadExactElt) -> RngUPolElt_FldPadExact
  {Multiplication.}
  ok, F := ExistsCoveringStructure(BaseRing(f), Parent(x));
  require ok: "x and the coefficients of f must come from the same field";
  R := PolynomialRing(F);
  f := CAST(R, f);
  x := CAST(F, x);
  // trivial cases
  if IsDefinitelyZero(f) or IsDefinitelyZero(x) then
    return Zero(R);
  end if;
  // general case
  xf := Approximation(f, CAPR(f));
  xx := Approximation(x, CAPR(x));
  init := xf * xx;
  mkupdate := func<z | function (aprs)
    vx := WeakValuation(x);
    vf := WeakValuation(f);
    pr := &join(aprs - vf - vx);
    return [
      Approximation_Lazy(f, aprs-vx),
      Approximation_Lazy(x, vx+pr)
    ] mod function (xf, xx)
      Update(z, xf * xx);
      return true;
    end function;
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;

intrinsic '*'(x :: FldPadExactElt, f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {"}
  return f * x;
end intrinsic;

intrinsic Resultant(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact : Strategy:="default", fStrategy:=Strategy, gStrategy:=Strategy) -> FldPadExactElt
  {The resultant of f and g.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be defined over a common field";
  return Resultant([R| f, g] : Strategies:=[*fStrategy, gStrategy*]);
end intrinsic;

intrinsic WeakResultant(f :: RngUPolElt_FldPadExact, g :: RngUPolElt_FldPadExact) -> FldPadExactElt
  {The weak resultant of f and g.}
  ok, R := ExistsCoveringStructure(Parent(f), Parent(g));
  require ok: "f and g must be defined over a common field";
  return WeakResultant([R|f,g]);
end intrinsic;

// given a sequence of p-adic polynomials, returns their resultant WITHOUT increasing the precision of the field they are in
function resultant(fs)
  R := Universe(fs);
  K := BaseRing(R);
  vs := [Min([Valuation(c) : c in Coefficients(f)] cat [Infinity()]) : f in fs];
  ds := [Degree(f) : f in fs];
  d := &+ds;
  v := &+[vs[i]*(d - ds[i]) : i in [1..#fs]];
  zfs := [ShiftValuation(fs[i], -vs[i]) : i in [1..#fs]];
  apr := Min([AbsolutePrecision(c) : c in Coefficients(f), f in fs]);
  OK := Integers(K);
  QK := quo<OK | ShiftValuation(OK ! 1, apr)>;
  QR := PolynomialRing(QK);
  qzfs := [QR ! zf : zf in zfs];
  qzres := &*[Resultant(qzfs[i], qzfs[j]) : j in [i+1..#fs], i in [1..#fs]];
  zres := K ! OK ! qzres;
  res := ShiftValuation(zres, v);
  return res;
end function;

intrinsic Resultant(fs :: [RngUPolElt_FldPadExact] : Strategy:="default", Strategies:=[*Strategy : f in fs*]) -> FldPadExactElt
  {The generalized resultant of fs.}
  require IS_INSTANCE(Strategies,{List, SeqEnum})
  and (#Strategies eq #fs):
    "Strategies must be a list or sequence with the same length as fs";
  // ensure the degrees of fs are known before computing a weak resultant
  _ := [Degree(fs[i] : Strategy:=Strategies[i]) : i in [1..#fs]];
  return WeakResultant(fs);
end intrinsic;

intrinsic WeakResultant(fs :: [RngUPolElt_FldPadExact]) -> FldPadExactElt
  {The weak resultant of fs, i.e. the resultant assuming the weak degree of each f in fs is correct.}
  R := Universe(fs);
  K := BaseRing(R);
  ds := [WeakDegree(f) : f in fs];
  vs := [WeakValuation(f) : f in fs];
  d := &+ds;
  dds := [d-d0 : d0 in ds];
  init := resultant([Approximation(f : Pr:=1, Weak) : f in fs]);
  mkupdate := func<z | function (apr)
    vs := [WeakValuation(f) : f in fs];
    v := &+[vs[i]*dds[i] : i in [1..#fs]];
    pr := apr - v;
    return &cat[Approximation_Lazy(fs[i] : APr:=vs[i]+pr) : i in [1..#fs]]
    mod function (xfs)
      Update(z, resultant(xfs));
      return true;
    end function;
  end function>;
  return K ! <init, mkupdate>;
end intrinsic;

procedure assignValuationBelow_poly(f,n)
  if assigned f`valuation then
    ;
  elif IsDefinitelyZero(f) then
    f`valuation := Infinity();
  else
    IncreaseAbsolutePrecision(f, n);
    apr := AbsolutePrecision(f);
    assert apr ge n;
    v := Min([Valuation(c) : c in Coefficients(f`approximation)]);
    if v lt apr then
      f`valuation := v;
    end if;
  end if;
end procedure;

intrinsic ValuationEq(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is n.}
  assignValuationBelow_poly(f, n+1);
  return assigned f`valuation and f`valuation eq n;
end intrinsic;

intrinsic ValuationNe(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is not n.}
  return not ValuationEq(f, n);
end intrinsic;

intrinsic ValuationLe(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is at most n.}
  assignValuationBelow_poly(f, n+1);
  return assigned f`valuation and f`valuation le n;
end intrinsic;

intrinsic ValuationLt(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is less than n.}
  assignValuationBelow_poly(f, n);
  return assigned f`valuation and f`valuation lt n;
end intrinsic;

intrinsic ValuationGe(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is at least n.}
  return not ValuationLt(f, n);
end intrinsic;

intrinsic ValuationGt(f :: RngUPolElt_FldPadExact, n :: RngIntElt) -> BoolElt
  {True if the valuation of f is greater than n.}
  return not ValuationLe(f, n);
end intrinsic;

function np_face_factorization(f, face, Residual)
  R := Parent(f);
  K := BaseRing(R);
  // unpack the face
  slope := CAST(Q, Slope(face));
  w := CAST(Z, Width(face));
  v0, v1 := Explode(EndVertices(face));
  x0, y0 := Explode(v0);
  x1, y1 := Explode(v1);
  x0 := Z!x0;
  x1 := Z!x1;
  y0 := Z!y0;
  y1 := Z!y1;
  assert x0 ge 0;
  assert x1 le WeakDegree(f);
  assert x0 lt x1;
  h := Numerator(-slope);
  e := Denominator(-slope);
  // get the residual polynomial
  FK, KtoFK := ResidueClassField(K);
  res := ResidualPolynomial(f, face);
  // factorize the residual polynomial
  if Residual then
    rfacs := [x[1]^x[2] : x in Factorization(res)];
  else
    rfacs := [res];
  end if;
  // trivial case: whole polynomial
  if w ge WeakDegree(f) and #rfacs eq 1 then
    return [f];
  end if;
  // maybe extend the base field
  if e eq 1 then
    L := K;
    S := R;
    fS := f;
  else
    pi := UniformizingElement(K);
    L := TotallyRamifiedExtension(K, e);
    xL := L`approximation_field;
    xK := K`approximation_field;
    xKtoxL := function (x)
      v := Valuation(x);
      if v eq OO then
        return xL ! 0;
      else
        return ShiftValuation(CAST(xL, ShiftValuation(x, -v)), v*e);
      end if;
    end function;
    xLtoxK := function (x)
      v := Valuation(x) div e;
      return ShiftValuation(CAST(xK, ShiftValuation(x, -v*e)), v);
    end function;
    S := PolynomialRing(L);
    fS := S ! <init, mkupdate>
      where init := xS ! [xKtoxL(c) : c in Coefficients(xf)]
      where xf := Approximation(f : Pr:=1, Weak)
      where xS := Approximation(S, 1)
      where mkupdate := func<z | function (aprs)
        xf := f`approximation;
        d := WeakDegree(f);
        pr := Max([v eq OO select 0 else aprs[i+1]-v*e where v:=Valuation(Coefficient(xf,i)) : i in [0..d]]);
        if pr gt 0 then
          return Approximation_Lazy(S, pr) mod function (xS)
            return Approximation_Lazy(f : APr:=[Ceiling(a/e) : a in aprs]) mod function (xf)
              Update(z, xS ! [xKtoxL(c) : c in Coefficients(xf)]);
              return true;
            end function;
          end function;
        else
          UpdateZero(z, aprs);
          return true;
        end if;
      end function>;
  end if;
  // deslope fS
  fSds := ShiftValuation(ShiftSlope(fS, h : Pivot:=x1), -y1*e);
  assert IsIntegral(fSds);
  assert ValuationEq(Coefficient(fSds, x0), 0);
  assert ValuationEq(Coefficient(fSds, x1), 0);
  // get approximate factors
  aSdss := [Polynomial([CAST(L, WeakApproximation(c@@KtoFK)) : c in Coefficients(r2)]) where r2:=Evaluate(r, Parent(r).1^e) : r in rfacs];
  assert &+[WeakDegree(a) : a in aSdss] eq w;
  // get factors
  gSdss := [HenselLift(fSds, aSds : WeakResultant) : aSds in aSdss];
  // reslope
  gSs := [ShiftSlope(gSds, -h : Pivot:=Degree(gSds)) : gSds in gSdss];
  // coerce back to the base field
  if e eq 1 then
    gs := gSs;
  else
    gs := [CAST(R,[Coefficient(c,0) : c in Coefficients(gS)]) : gS in gSs];
  end if;
  assert &+[Degree(g) : g in gs] eq w;
  return gs;
end function;

function npfactorization(f, faces, Residual)
  return &cat[np_face_factorization(f, face, Residual) : face in faces];
end function;

intrinsic NewtonPolygonFactorization
  ( f :: RngUPolElt_FldPadExact
  : Strategy := "default"
  , Residual := false
  ) -> [], FldPadExactElt
  {A list of factors of f corresponding to the slopes of the Newton polygon of f.}
  // TODO: allow for the possibility that f0 has high valuation; if f1 also has high valuation then we can't tell if that is one or two slopes, but if f1 has a low valuation, then there is a single big slope and it should be Hensel liftable from 0; currently if f0 has a high valuation then the call to NewtonPolygon() fails because it can't be computed exactly. To do this: (a) see if f0 is weakly zero; if not then proceed as normal; (b) If so, then check if f1 is weakly zero; if so then abort; (c) Find the root near 0 --- if v(f0)>2v(f1) then 0 itself is Hensel liftable --- and divide by this factor and then proceed with the cofactor.
  if not assigned f`npfactorization then
    f`npfactorization := AssociativeArray();
  end if;
  key := Residual;
  if not IsDefined(f`npfactorization, key) then
    if IsDefinitelyZero(f) then
      error "zero polynomial";
    end if;
    // get the newton polygon
    lc := LeadingCoefficient(f : Strategy:=Strategy);
    np := NewtonPolygon(f : Strategy:=Strategy);
    faces := Faces(np);
    f`npfactorization[key] := [* npfactorization(f, faces, Residual), lc *];
  end if;
  return Explode(f`npfactorization[key]);
end intrinsic;

intrinsic Slice(f :: RngUPolElt_FldPadExact, idxs :: [RngIntElt]) -> RngUPolElt_FldPadExact
  {The polynomial with the given coefficients of f.}
  require forall{i : i in idxs | i ge 0}: "idxs must be non-negative";
  R := Parent(f);
  if #idxs eq 0 then
    return CAST(R, []);
  end if;
  xf := Approximation(f, CAPR(f));
  init := Parent(xf) ! [IsDefined(idxs,i) select Coefficient(xf, idxs[i]) else 0 : i in [1..#idxs]];
  // make an array a := [<j, [i : idxs[i] eq j]>]
  a := AssociativeArray();
  for i in [1..#idxs] do
    if IsDefined(idxs, i) then
      j := idxs[i];
      if IsDefined(a, j) then
        Append(~a[j], i);
      else
        a[j] := [i];
      end if;
    end if;
  end for;
  a := [<j, a[j]> : j in Keys(a)];
  print a;
  mkupdate := func<z | function (aprs)
    return Approximation_Lazy(f, [<x[1], &join[aprs(i-1) : i in x[2]]> : x in a]) mod function (xf)
      Update(z, Parent(xf) ! [IsDefined(idxs,i) select Coefficient(xf, idxs[i]) else 0 : i in [1..#idxs]]);
      return true;
    end function;
  end function>;
  return R ! <init, mkupdate>;
end intrinsic;

intrinsic Reverse(f :: RngUPolElt_FldPadExact : Strategy:="default") -> RngUPolElt_FldPadExact
  {The polynomial with the reversed coefficients of f: f(1/x)*x^deg(f).}
  d := Degree(f : Strategy:=Strategy);
  return Slice(f, [d..0 by -1]);
end intrinsic;

intrinsic WeakReverse(f :: RngUPolElt_FldPadExact) -> RngUPolElt_FldPadExact
  {The polynomial with the reversed weak coefficient of f: f(1/x)*x^weakdeg(f).}
  d := WeakDegree(f);
  return Slice(f, [d..0 by -1]);
end intrinsic;

intrinsic Decimate(f :: RngUPolElt_FldPadExact, n :: RngIntElt : Phase:=0) -> RngUPolElt_FldPadExact
  {The polynomial of the ith coefficients of f where i=Phase mod n.}
  require n gt 0: "n must be positive";
  d := WeakDegree(f);
  return Slice(f, [Phase mod n .. d by n]);
end intrinsic;

intrinsic Polynomial(coeffs :: [FldPadExactElt]) -> RngUPolElt_FldPadExact
  {The polynomial with the given coefficients.}
  K := Universe(coeffs);
  R := PolynomialRing(K);
  return CAST(R, coeffs);
end intrinsic;

intrinsic Polynomial(K :: FldPadExact, coeffs :: []) -> RngUPolElt_FldPadExact
  {The polynomial over K with the given coefficients.}
  ok, coeffs := CanChangeUniverse(coeffs, K);
  require ok: "coeffs must be coercible to K";
  return CAST(PolynomialRing(K), coeffs);
end intrinsic;

intrinsic Coefficient(x :: FldPadExactElt, i :: RngIntElt) -> FldPadExactElt
  {The generator^i coefficient of x in K(generator)/K.}
  K := Parent(x);
  require not IsPrimeField(K): "x does not lie in an extension";
  d := Degree(K);
  require i ge 0 and i lt d: "i must be between 0 and degree-1";
  if assigned x`coefficients then
    if assigned x`coefficient then
      delete x`coefficient;
    end if;
    return x`coefficients[i+1];
  end if;
  if not assigned x`coefficient then
    x`coefficient := [* false : j in [0..d-1] *];
  end if;
  if x`coefficient[i+1] cmpeq false then
    K0 := BaseField(K);
    case K`type:
    when EISEN:
      init := CAP_PR(ELTSEQ(Approximation(x))[i+1], 1);
      mkupdate := func<z | function (apr)
        return Approximation_Lazy(x : APr:=apr*d+i) mod function (xx)
          Update(z, ELTSEQ(xx)[i+1]);
          return true;
        end function;
      end function>;
      x`coefficient[i+1] := K0 ! <init, mkupdate>;
    when INERT:
      init := CAP_PR(ELTSEQ(Approximation(x))[i+1], 1);
      mkupdate := func<z | function (apr)
        return Approximation_Lazy(x : APr:=apr) mod function (xx)
          Update(z, ELTSEQ(xx)[i+1]);
          return true;
        end function;
      end function>;
      x`coefficient[i+1] := K0 ! <init, mkupdate>;
    when PRIME:
      assert false;
    else
      error "not implemented";
    end case;
  end if;
  return x`coefficient[i+1];
end intrinsic;

intrinsic Coefficients(x :: FldPadExactElt) -> []
  {The coefficients of x in the basis generator^i in K(generator)/K.}
  if not assigned x`coefficients then
    K := Parent(x);
    d := Degree(K);
    x`coefficients := [Coefficient(x, i) : i in [0..d-1]];
  end if;
  return x`coefficients;
end intrinsic;

intrinsic Eltseq(x :: FldPadExactElt) -> []
  {"}
  return Coefficients(x);
end intrinsic;

// true if E/BaseField(E) determines a unique extension
function isDefinitelyUnique1(E)
  if Precision(E) eq OO then
    return true;
  end if;
  f := DefiningPolynomial(E);
  d := Degree(E);
  if IsUnramified(E) then
    assert IsInertial(f);
    apr := 1;
  elif IsTotallyRamified(E) then
    assert IsEisenstein(f);
    D := Discriminant(f);
    if WZERO(D) then
      return false;
    end if;
    vD := Valuation(D);
    j := vD - d + 1;
    FUDGE := 2*AbsoluteRamificationDegree(E);
    apr := Floor(1 + 2*j/d) + 1 + FUDGE;
  else
    assert false;
  end if;
  return forall{c : c in Coefficients(f) | AbsolutePrecision(c) ge apr};
end function;

function isDefinitelyUnique(E, F)
  twr := TOWER(E, F);
  return forall{i : i in [2..#twr] | isDefinitelyUnique1(twr[i])};
end function;

intrinsic ExactpAdicField(xxL :: FldPad : NoCheckUnique:=false) -> FldPadExact, Map
  {Given a p-adic field xxL, returns L isomorphic to xxL and a map xxL -> xL.}
  if IsPrimeField(xxL) then
    L := ExactpAdicField(Prime(xxL));
    L`approximation_field := xxL;
    return L, map<xxL -> xxL | x :-> x, y :-> y>;
  else
    return ExactpAdicField(xxL, ExactpAdicField(PrimeField(xxL)) : NoCheckUnique:=NoCheckUnique);
  end if;
end intrinsic;

// given xxL/xxK and xxK~K, returns L/K with L~K
intrinsic ExactpAdicField(xxL :: FldPad, mK :: Map, K :: FldPadExact : NoCheckUnique:=false) -> FldPadExact, Map
  {Given an extension xxL/xxK and mK : xxK -> xK where xK is the approximation field of K, returns L/K isomorphic to xxL/xxK and a map xxL -> xL.}
  xxK := Domain(mK);
  // base case
  if xxL eq xxK then
    require Codomain(mK) eq K`approximation_field: "";
    return K, mK;
  end if;
  // check xxL is a good extension
  require not IsPrimeField(xxL): "xxL must be an extension of xxK";
  if not NoCheckUnique then
    require isDefinitelyUnique1(xxL): "xxL does not define a unique extension";
  end if;
  // recursively find the base field
  xxL0 := BaseField(xxL);
  L0, mL0 := ExactpAdicField(xxL0, mK, K : NoCheckUnique:=NoCheckUnique);
  xL0 := L0`approximation_field;
  // make the defining polynomial
  xxf := DefiningPolynomial(xxL);
  R := PolynomialRing(L0);
  xR := R`approximation_ring;
  xf := CAST(xR, [c @ mL0 : c in Coefficients(xxf)]);
  if Precision(xxL) eq OO then
    e := RamificationDegree(xxL);
    FUDGE := e gt 1 select 2*e else 0;
    mkupdate := func<z | function (aprs)
      apr := Max(aprs);
      return Approximation_Lazy(R, apr) mod function (xR)
        locxxL := xxL;
        locxxL`DefaultPrecision := apr*e + FUDGE;
        xxf := CAP_APR(xxf, [apr*e : c in Coefficients(xxf)]) where xxf := DefiningPolynomial(locxxL);
        xf := CAST(xR, [c @ mL0 : c in Coefficients(xxf)]);
        Update(z, xf);
        return true;
      end function;
    end function>;
    f := R ! <xf, mkupdate>;
  else
    f := WeakApproximation(CAST(R, xf));
  end if;
  // make the extension
  L := Extension(f);
  xL := L`approximation_field;
  // make the map
  mL := map<xxL -> xL |
    y :-> CAST(xL, [c@mL0 : c in Eltseq(y)]),
    x :-> CAST(xxL, [c@@mL0 : c in Eltseq(x)])>;
  // done
  return L, mL;
end intrinsic;

intrinsic ExactpAdicField(xxL :: FldPad, xxK :: FldPad, K :: FldPadExact : NoCheckUnique:=false) -> FldPadExact, Map
  {Given xxL/xxK where xxK is coercible to and from xK where xK is the approximation field of K, returns L/K isomorphic to xxL/xxK, and a map xxL -> xL.}
  xK := K`approximation_field;
  mK := map<xxK -> xK | x :-> CAST(xK, x), y :-> CAST(xxK, y)>;
  return ExactpAdicField(xxL, mK, K : NoCheckUnique:=NoCheckUnique);
end intrinsic;

intrinsic ExactpAdicField(xxL :: FldPad, K :: FldPadExact : NoCheckUnique:=false) -> FldPadExact, Map
  {Given xxL/xK where xK is the approximation field of K, returns L/K isomorphic to xxL/xK, and a map xL -> xxL.}
  xK := K`approximation_field;
  mK := map<xK -> xK | x :-> x, y :-> y>;
  return ExactpAdicField(xxL, mK, K : NoCheckUnique:=NoCheckUnique);
end intrinsic;

procedure assignQuotientRingNames(~R, F)
  case F`type:
  // when PRIME:
    // assert IsPrimeField(R);
  when INERT, EISEN:
    R0 := BaseRing(R);
    F0 := BaseField(F);
    assert Degree(R, R0) eq Degree(F);
    if assigned F`varname then
      AssignNames(~R, [F`varname cat "bar"]);
    end if;
    assignQuotientRingNames(~R0, F0);
  when PRIME:
    ;
  else
    error "not implemented";
  end case;
end procedure;

intrinsic Quotient(F :: FldPadExact, n :: RngIntElt) -> RngPadRes, Map
  {The integers Q of F mod pi^n, and the map F to Q.}
  require n ge 0: "n must be non-negative";
  xF := Approximation(F, n);
  xOF := Integers(xF);
  xQF := quo<xOF | ShiftValuation(xOF ! 1, n)>;
  assignQuotientRingNames(~xQF, F);
  function FtoQ(x)
    return CAST(xQF, Approximation(x : APr:=n));
  end function;
  function QtoF(y)
    x := New(FldPadExactElt);
    x`parent := F;
    x`id := NEXTID();
    x`approximation := CAST(xF, CAST(xOF, y));
    x`update := function (apr)
      error "cannot increase precision of images of p-adic quotients";
    end function;
    return x;
  end function;
  return xQF,
    map<F -> xQF | x :-> FtoQ(x), y :-> QtoF(y)>;
end intrinsic;

intrinsic QuoConstructor(F :: FldPadExact, t :: .) -> RngPadRes, Map
  {The quotient of F by t.}
  require #t ge 1: "RHS must be nonempty";
  // coerce generators into F
  xs := [F|];
  for x in t do
    ok, y := IsCoercible(F, x);
    if not ok then
      error "RHS must all be coercible to F";
    end if;
    Append(~xs, y);
  end for;
  // get the valuation of the smallest element
  error if forall{x : x in xs | WZERO(x)}, "generators are all weakly zero";
  v := Min([WeakValuation(x) : x in xs | not WZERO(x)]);
  require v ge 0: "RHS must be integral";
  IncreaseAbsolutePrecisions([*<x, v> : x in xs*]);
  v := Min([WeakValuation(x) : x in xs | not WZERO(x)]);
  require v ge 0: "RHS must be integral";
  return Quotient(F, v);
end intrinsic;

function factorialValuation(n, p)
  assert p gt 0;
  assert n ge 0;
  // v_p(n!)
  v := 0;
  q := p;
  while q le n do
    v +:= n div q;
    q *:= p;
  end while;
  return v;
end function;

function binomialValuation(n, k, p)
  return factorialValuation(n, p) - factorialValuation(k, p) - factorialValuation(n - k, p);
end function;

intrinsic RamificationPolygon(f :: RngUPolElt_FldPadExact) -> NwtnPgon
  {The ramification polygon of the extension defined by f.}
  if not assigned f`ramification_polygon then
    if IsEisenstein(f) then
      // the newton polygon of r(x) where
      // v(r_j) = min[j<=i<=d] d*v_K((i choose j)*f_i)+(i-j)
      d := Degree(f);
      K := BaseRing(f);
      e := AbsoluteRamificationDegree(K);
      p := Prime(K);
      // we deduce that v(r_j) <= d*v_K((d choose j))+(d-j)
      // and hence we need to known v_K(f_i) <? v_K((d choose j)) - v_K((i choose j)) + 1-i/d
      aprs := [0] cat [Max([Ceiling(e*(binomialValuation(d,j,p) - binomialValuation(i,j,p)) + 1 - i/d) : j in [1..i]]) : i in [1..d]];
      IncreaseAbsolutePrecision(f, aprs);
      // now compute
      vfs := [Valuation(c) : c in Coefficients(f`approximation)[2..d+1]];
      vrs := [Min([d*e*binomialValuation(i,j,p)+d*vfs[i]+(i-j) : i in [j..d] | vfs[i] lt OO]) : j in [1..d]];
      f`ramification_polygon := NewtonPolygon([<j, vrs[j]> : j in [1..d]] : Faces:="Lower");
    elif IsInertial(f) then
      d := Degree(f);
      f`ramification_polygon := NewtonPolygon([<1,0>, <d,0>] : Faces:="Lower");
    else
      error "only implemented for inertial or Eisenstein polynomials";
    end if;
  end if;
  return f`ramification_polygon;
end intrinsic;

intrinsic RamificationPolygon(F :: FldPadExact) -> NwtnPgon
  {The ramification polygon of F over its base field.}
  return RamificationPolygon(DefiningPolynomial(F));
end intrinsic;

intrinsic Print(h :: HassHerbTransFunc, lvl :: MonStgElt)
  {Prints h.}
    printf "Hasse-Herbrand transition function of an extension of ramification degree %o", h`degree;
end intrinsic;

intrinsic Degree(h :: HassHerbTransFunc) -> RngIntElt
  {The degree of the extension this is the transition function of.}
  return h`degree;
end intrinsic;

intrinsic Vertices(h :: HassHerbTransFunc) -> []
  {The vertices of the function.}
  return h`vertices;
end intrinsic;

intrinsic '@'(v, h :: HassHerbTransFunc) -> .
  {Evaluates h at v.}
  if v le 0 then
    return (Q!1) * v;
  end if;
  for i in [2..#h`vertices] do
    v1, u1 := Explode(h`vertices[i]);
    if v le v1 then
      v0, u0 := Explode(h`vertices[i-1]);
      return u0 + (v-v0)*(u1-u0)/(v1-v0);
    end if;
  end for;
  v1, u1 := Explode(LAST(h`vertices));
  assert v gt v1;
  return u1 + (v-v1) / h`degree;
end intrinsic;

intrinsic '@@'(u, h :: HassHerbTransFunc) -> .
  {The inverse of h at u.}
  if u le 0 then
    return (Q!1) * u;
  end if;
  for i in [2..#h`vertices] do
    v1, u1 := Explode(h`vertices[i]);
    if u le u1 then
      v0, u0 := Explode(h`vertices[i-1]);
      return v0 + (u-u0)*(v1-v0)/(u1-u0);
    end if;
  end for;
  v1, u1 := Explode(LAST(h`vertices));
  assert u gt u1;
  return v1 + (u-u1) * h`degree;
end intrinsic;

function hhtf_from_ramification_polygon(rp, d)
  assert Vertices(rp)[1][1] eq 1;
  assert LAST(Vertices(rp))[1] eq d;
  U := [<Q!0, Q!0>];
  for face in Reverse(Faces(rp)) do
    v1 := -Slope(face);
    v0, u0 := Explode(LAST(U));
    e := Z ! EndVertices(face)[2][1];
    assert IsDivisibleBy(d, e);
    assert v1 gt v0;
    u1 := u0 + (e/d)*(v1-v0);
    assert u1 gt u0;
    Append(~U, <v1, u1>);
  end for;
  h := New(HassHerbTransFunc);
  h`degree := d;
  h`vertices := U;
  return h;
end function;

function hhtf_trivial()
  h := New(HassHerbTransFunc);
  h`degree := 1;
  h`vertices := [<Q!0,Q!0>];
  return h;
end function;

intrinsic TransitionFunction(F :: FldPadExact) -> HassHerbTransFunc
  {The Hasse-Herbrand transition function of F over its base field.}
  if not assigned F`transition_function then
    case F`type:
    when PRIME:
      error "F must be an extension";
    when INERT:
      h := hhtf_trivial();
    when EISEN:
      rp := RamificationPolygon(F);
      d := Degree(F);
      h := hhtf_from_ramification_polygon(rp, d);
    else
      error "not implemented";
    end case;
    F`transition_function := h;
  end if;
  return F`transition_function;
end intrinsic;

intrinsic TransitionFunction(F :: FldPad) -> HassHerbTransFunc
  {"}
  if IsPrimeField(F) then
    error "F must be an extension";
  end if;
  F0 := BaseField(F);
  if RamificationDegree(F) eq 1 then
    return hhtf_trivial();
  elif RamificationDegree(F) eq Degree(F) then
    f := DefiningPolynomial(F);
    alpha := F.1;
    r := Evaluate(f, Polynomial([alpha,1]));
    assert Degree(r) eq Degree(f);
    assert IsWeaklyZero(Coefficient(r, 0));
    rp := NewtonPolygon([<i, Valuation(Coefficient(r,i))> : i in [1..Degree(r)]] : Faces:="Lower");
    assert forall{v : v in Vertices(rp) | not IsWeaklyZero(Coefficient(r, Z ! v[1]))};
    d := Degree(F);
    return hhtf_from_ramification_polygon(rp, d);
  else
    error "not implemented";
  end if;
end intrinsic;

function hhtf_merge_tower(hs)
  h := New(HassHerbTransFunc);
  h`degree := 1;
  h`vertices := [<Q!0, Q!0>];
  for h1 in hs do
    h0 := h;
    vs := SORT({vu[1] : vu in h1`vertices} join {vu[1] @@ h1 : vu in h0`vertices});
    h := New(HassHerbTransFunc);
    h`degree := h1`degree * h0`degree;
    h`vertices := [<v, v@h1@h0> : v in vs];
  end for;
  return h;
end function;

intrinsic TransitionFunction(x :: ExtDataFldPadExact) -> HassHerbTransFunc
  {The Hasse-Herbrand transition function.}
  if not assigned x`transition_function then
    case x`type:
    when COMPOUND:
      h := hhtf_merge_tower([TransitionFunction(y) : y in x`list]);
    when INERT, EISEN:
      h := TransitionFunction(x`top_field);
    when EMBED:
      // TODO: implement "division" of transition functions
      error "not implemented";
    else
      error "not implemented";
    end case;
    x`transition_function := h;
  end if;
  return x`transition_function;
end intrinsic;

intrinsic TransitionFunction(E :: FldPadExact, F :: FldPadExact) -> HassHerbTransFunc
  {The Hasse-Herbrand transition function of E/F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return TransitionFunction(x);
end intrinsic;

intrinsic TransitionFunction(E :: FldPad, F :: FldPad) -> HassHerbTransFunc
  {"}
  twr := TOWER(E, F);
  return hhtf_merge_tower([TransitionFunction(t) : t in twr[2..#twr]]);
end intrinsic;

intrinsic 'eq'(h1 :: HassHerbTransFunc, h2 :: HassHerbTransFunc) -> BoolElt
  {True if h1 and h2 are equal as field invariants, i.e. they define the same function.}
  return Degree(h1) eq Degree(h2) and Vertices(h1) eq Vertices(h2);
end intrinsic;

intrinsic LowerBreaks(h :: HassHerbTransFunc) -> []
  {The lower breaks of h.}
  return [x[1] : x in Vertices(h)];
end intrinsic;

intrinsic UpperBreaks(h :: HassHerbTransFunc) -> []
  {The upper breaks of h.}
  return [x[2] : x in Vertices(h)];
end intrinsic;

intrinsic RamificationPolygon(h :: HassHerbTransFunc) -> NwtnPgon
  {The ramification polygon of a totally ramified extension with the given transition function.}
  if not assigned h`ramification_polygon then
    e := h`degree;
    vs := [<e, 0>];
    vus := Vertices(h);
    for i in [2..#vus] do
      slope := -vus[i][1];
      if i eq #vus then
        x1 := 1;
      else
        v0, u0 := Explode(vus[i]);
        v1, u1 := Explode(vus[i+1]);
        x1 := Z ! (e * (u1 - u0) / (v1 - v0));
      end if;
      x0, y0 := Explode(LAST(vs));
      assert x1 lt x0;
      y1 := Z ! (y0 + slope*(x1-x0));
      Append(~vs, <x1, y1>);
    end for;
    h`ramification_polygon := NewtonPolygon(vs : Faces:="Lower");
  end if;
  return h`ramification_polygon;
end intrinsic;

intrinsic RamificationPolygon(x :: ExtDataFldPadExact) -> NwtnPgon
  {The ramification polygon.}
  if not assigned x`ramification_polygon then
    d := Degree(x);
    rp0 := RamificationPolygon(TransitionFunction(x));
    rp := NewtonPolygon(Vertices(rp0) cat [<d,0>] : Faces:="Lower");
    x`ramification_polygon := rp;
  end if;
  return x`ramification_polygon;
end intrinsic;

intrinsic RamificationPolygon(E :: FldPadExact, F :: FldPadExact) -> NwtnPgon
  {The ramification polygon of E/F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return RamificationPolygon(x);
end intrinsic;

// to determine if x in E/F  (degree d) is primitive:
// a) if d=1, then yes
// b) if not primitive, then x satisfies a polynomial of degree less than d; in fact, it satisfies a polynomial of degree dividing d, so it satisfies a polynomial of degree at most d0 where d0 is the largest proper divisor of d
// c) take an approximation xx of x to some precision
// d) compute xx^i for 0<=i<=d0
// e) compute the F-coefficients of xx^i
// f) see if they are linearly dependent; specifically can we solve sum[i=0,d-1](a_i x^i) = x^d
// g) if this is not solvable, then x is primitive
// h) otherwise, x might be primitive
// 
// To get the minimal polynomial, do steps c-f with d instead of d0; this will be solvable and the answer will be unique.

function deep_eltseq(x, X)
  // assert Parent(x) eq X`top_field;
  case X`type:
  when COMPOUND:
    xs := [x];
    for Y in Reverse(X`list) do
      xs := &cat[deep_eltseq(x, Y) : x in xs];
    end for;
    return xs;
  when EISEN, INERT:
    return ELTSEQ(x);
  when EMBED:
    error "not implemented";
  else
    error "not implemented";
  end case;
end function;

function vector(x, X)
  return Vector(deep_eltseq(x, X));  
end function;

intrinsic IsDefinitelyPrimitive(x, X :: ExtDataFldPadExact : Strategy:="default") -> BoolElt, RngUPol_FldPadExact
  {True if x is a primitive element of X. If so, also returns the minimal polynomial.}
  ok, x := IsCoercible(X`top_field, x);
  require ok: "x must be coercible to the top field of X";
  d := Degree(X);
  // trivial case
  if d eq 1 then
    return true, Polynomial([X`base_field | -x, 1]);
  end if;
  // check if x is the generator
  if BaseField(X`top_field) eq X`base_field and x`id eq Generator(X`top_field)`id then
    return true, DefiningPolynomial(X`top_field);
  end if;
  // general case
  require not IsWeaklyZero(x : Strategy:=Strategy): "x is weakly zero";
  vx := Valuation(x);
  e := RamificationDegree(X);
  s := vx div e;
  y := ShiftValuation(X`base_field ! 1, s);
  x2 := x / y;
  assert not WZERO(x2);
  assert ValuationEq(x2, vx mod e);
  isKnown := false;
  // TODO: check if x is a uniformizer
  if IsTotallyRamified(X) and IsUniformizingElement(x) then
    isKnown := true;
    Strategy := 1+RamificationDegree(X);
  end if;
  // TODO: check if x is an inertial generator
  if IsUnramified(X)
  and Degree(MinimalPolynomial(ResidueClass(x), ResidueClassField(X`base_field)))
    eq InertiaDegree(X)
  then
    isKnown := true;
    Strategy := 1;
  end if;
  ok, _, m := ExactpAdics_ExecutePrecisionStrategy(function (pr)
    xx := Approximation(x2 : APr:=pr);
    M := Matrix([vector(xx^i, X) : i in [0..d-1]]);
    dM := Determinant(M);
    if WZERO(dM) then
      return false, _;
    end if;
    t := Valuation(dM);
    V := vector(-(xx^d), X);
    C := Solution(M, V);
    s := Min([Valuation(c) : c in ELTSEQ(C*M-V)]);
    xm := Polynomial(ELTSEQ(C) cat [1]);
    xm := CHANGE_APR(xm, [s-t : i in [0..d-1]] cat [1]);
    mkupdate := func<z | function (aprs)
      apr := Max(aprs);
      return Approximation_Lazy(x2 : APr:=e*(apr+t)) mod function (xx)
        M := Matrix([vector(xx^i, X) : i in [0..d-1]]);
        dM := Determinant(M);
        assert not WZERO(dM);
        assert Valuation(dM) eq t;
        V := vector(-(xx^d), X);
        C := Solution(M, V);
        s := Min([Valuation(c) : c in ELTSEQ(C*M-V)]);
        assert s ge apr+t;
        xm := Polynomial(ELTSEQ(C) cat [1]);
        xm := CHANGE_APR(xm, [s-t : i in [0..d]]);
        Update(z, xm);
        return true;
      end function;
    end function>;
    return true, PolynomialRing(X`base_field) ! <xm, mkupdate>;
  end function, Strategy, 0);
  if ok then
    return true, ShiftSlope(m, -s : Pivot:=d);
  else
    assert not isKnown;
    return false, _;
  end if;
end intrinsic;

intrinsic IsDefinitelyPrimitive(x, E :: FldPadExact, F :: FldPadExact : Strategy:="default") -> BoolElt, RngUPolElt_FldPadExact
  {True if x is primitive for E/F, i.e. E=F(x). If so, also returns the minimal polynomial of x over F.}
  ok, X := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return IsDefinitelyPrimitive(x, X);
  isKnown := false;
end intrinsic;

intrinsic IsDefinitelyPrimitive(x :: FldPadExactElt, F :: FldPadExact : Strategy:="default") -> BoolElt, RngUPolElt_FldPadExact
  {True if x in E is primitive for E/F, i.e. E=F(x). If so, also returns the minimal polynomial of x over F.}
  return IsDefinitelyPrimitive(x, Parent(x), F : Strategy:=Strategy);
end intrinsic;

intrinsic MinimalPolynomial(x, X :: ExtDataFldPadExact : Strategy:="default") -> RngUPolElt_FldPadExact
  {The minimal polynomial of x in X. Requires that x be primitive for X.}
  ok, m := IsDefinitelyPrimitive(x, X : Strategy:=Strategy);
  require ok: "cannot prove that x is primitive ";
  return m;
end intrinsic;

intrinsic MinimalPolynomial(x :: FldPadExactElt, F :: FldPadExact : Strategy:="default") -> RngUPolElt_FldPadExact
  {The minimal polynomial of x over F. Requires that x is a primitive element for E/F where E is the field containing x.}
  ok, m := IsDefinitelyPrimitive(x, F : Strategy:=Strategy);
  require ok: "cannot prove that x is primitive over F";
  return m;
end intrinsic;

intrinsic IsIrreducible
  ( f :: RngUPolElt_FldPadExact     // we want the factorization of f
  : Strategy := "default"           // the strategy
  , MainStrategy := Strategy        // the main factorization strategy
  , Proof := true                   // true if we want provable results
  ) -> []
  {True iff f is irreducible. If Proof is true, then also returns an irreducibility certificate, otherwise the result is unproven.}
  facs, lc, certs := Factorization(f : Strategy:=Strategy, MainStrategy:=MainStrategy, Certificates:=Proof);
  if #facs eq 1 and facs[1][2] eq 1 then
    if Proof then
      return true, certs[1];
    else
      return true, _;
    end if;
  else
    return false, _;
  end if;
end intrinsic;

intrinsic ResidualPolynomial(f :: RngUPolElt_FldPadExact, face :: NwtnPgonFace) -> RngUPolElt
  {The residual polynomial of the given face of the Newton polygon of f.}
  if not assigned f`residual_polynomial then
    f`residual_polynomial := AssociativeArray();
  end if;
  ok, r := IsDefined(f`residual_polynomial, face);
  if not ok then
    // unpack the face
    iv0, iv1 := Explode(EndVertices(face));
    i0, v0 := Explode(iv0);
    i0 := Z ! i0;
    v0 := Z ! v0;
    i1, v1 := Explode(iv1);
    i1 := Z ! i1;
    v1 := Z ! v1;
    assert (i1 - i0) gt 0;
    slope := (v1 - v0)/(i1 - i0);
    // check the face
    IncreaseAbsolutePrecision(f, [Ceiling(v0 + (i-i0)*slope) : i in [0..WeakDegree(f)]]);
    xf := f`approximation;
    assert not WZERO(Coefficient(xf, i0));
    assert Valuation(Coefficient(xf, i0)) eq v0;
    assert not WZERO(Coefficient(xf, i1));
    assert Valuation(Coefficient(xf, i1)) eq v1;
    assert forall{i : i in [i0+1..i1-1] | Valuation(Coefficient(xf, i)) ge v0 + (i-i0)*slope};
    assert forall{i : i in [0..i0-1] | Valuation(Coefficient(xf, i)) gt v0 + (i-i0)*slope};
    assert forall{i : i in [i1+1..WeakDegree(f)] | Valuation(Coefficient(xf, i)) gt v0 + (i-i0)*slope};
    // compute the residual polynomial
    h := Numerator(-slope);
    e := Denominator(-slope);
    ok, d := IsDivisibleBy(i1-i0, e);
    assert ok;
    r2 := ShiftValuation(Slice(f, [i0 .. i1 by e]), [h*i-v0 : i in [0..d]]);
    r := Polynomial([ResidueClass(c) : c in Coefficients(r2)]);
    assert Degree(r) eq d;
    assert Coefficient(r, 0) ne 0;
    f`residual_polynomial[face] := r;
  end if;
  return r;
end intrinsic;

intrinsic ResidualPolynomials(f :: RngUPolElt_FldPadExact) -> RngUPolElt
  {The residual polynomials of f.}
  if not assigned f`residual_polynomials then
    f`residual_polynomials := [ResidualPolynomial(f, face) : face in Faces(NewtonPolygon(f))];
  end if;
  return f`residual_polynomials;
end intrinsic;

intrinsic InertiaGenerator(F :: FldPadExact) -> FldPadExactElt
  {An element of F generating the maximal unramified subextension of F over its prime subfield, and its minimal polynomial.}
  if not assigned F`inertia_generator then
    RF, modp := ResidueClassField(F);
    F`inertia_generator := WeakApproximation(PrimitiveElement(RF) @@ modp);
  end if;
  return F`inertia_generator;
end intrinsic;

intrinsic PrimitiveElement(F :: FldPadExact) -> FldPadExactElt
  {A primitive element of F over Qp.}
  if not assigned F`primitive_element then
    F`primitive_element := PrimitiveElement(F, PrimeField(F));
  end if;
  return F`primitive_element;
end intrinsic;

intrinsic PrimitiveElement(x :: ExtDataFldPadExact) -> FldPadExactElt
  {A primitive element for the extension.}
  if not assigned x`primitive_element then
    if Degree(x) eq 1 then
      e := CAST(x`top_field, 1);
    elif BaseField(x`top_field) eq x`base_field then
      e := Generator(x`top_field);
    elif RamificationDegree(x) eq 1 then
      e := InertiaGenerator(x`top_field);
    elif InertiaDegree(x) eq 1 then
      e := UniformizingElement(x`top_field);
    else
      e := InertiaGenerator(x`top_field) + UniformizingElement(x`top_field);
    end if;
    x`primitive_element := e;
  end if;
  return x`primitive_element;
end intrinsic;

intrinsic PrimitiveElement(E :: FldPadExact, F :: FldPadExact) -> FldPadExactElt
  {A primitive element of E/F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return PrimitiveElement(x);
end intrinsic;

function smallestIndex(xs)
  // (determinable), (unique), (index)
  n := #xs;
  wzis := [i : i in [1..n] | WZERO(xs[i])];
  if #wzis eq 0 then
    vs := [Valuation(x) : x in xs];
    v, i := Max(vs);
    return true, forall{j : j in [1..#xs] | vs[j] lt v or j eq i}, i;
  elif #wzis eq 1 then
    i := wzis[1];
    v := Max([Valuation(xs[j]) : j in [1..n] | j ne i]);
    if ValuationGt(xs[i], v) then
      return true, true, i;
    else
      return smallestIndex(xs);
    end if;
  else
    return false, _, _;
  end if;
end function;

intrinsic IndexOfSmallest(xs :: [FldPadExactElt] : Strategy:="default", Unique:=false) -> RngIntElt
  {The index i maximizing Valuation(xs[i]). If Unique, raises an error if there is no unique smallest.}
  // trivial cases
  if #xs eq 0 then
    error "xs must not be empty";
  elif #xs eq 1 then
    return 1;
  end if;
  ok, unique, i := smallestIndex(xs);
  if not ok then
    ok, _, ret := ExactpAdics_ExecutePrecisionStrategy(function (pr)
      IncreaseAbsolutePrecisions([*<x,pr> : x in xs*]);
      ok, unique, i := smallestIndex(xs);
      if ok then
        return true, [*unique, i*];
      else
        return false, _;
      end if;
    end function, Strategy, 0);
    unique, i := Explode(ret);
  end if;
  if ok then
    if unique or (not Unique) then
      return i;
    else
      error "not unique";
    end if;
  else
    error "several elements weakly zero";
  end if;
end intrinsic;

intrinsic IndexOfClosest(x :: FldPadExactElt, ys :: [FldPadExactElt] : Strategy:="default", Unique:=false) -> RngIntElt
  {The index i maximizing Valuation(x-ys[i]). If Unique, raises an error if there is no unique closest.}
  return IndexOfSmallest([x-y : y in ys] : Strategy:=Strategy, Unique:=Unique);
end intrinsic;

intrinsic Smallest(xs :: [FldPadExactElt] : Strategy:="default", Unique:=false) -> FldPadExactElt, RngIntElt
  {The smallest element of xs, and its index.}
  i := IndexOfSmallest(xs : Strategy:=Strategy, Unique:=Unique);
  return xs[i], i;
end intrinsic;

intrinsic Closest(x :: FldPadExactElt, ys :: [FldPadExactElt] : Strategy:="default", Unique:=false) -> FldPadExactElt, RngIntElt
  {The closest element y of ys to x and its index.}
  i := IndexOfClosest(x, ys : Strategy:=Strategy, Unique:=Unique);
  return ys[i], i;
end intrinsic;

intrinsic Flatten(x :: ExtDataFldPadExact) -> ExtDataFldPadExact
  {Returns a version of x with type COMPOUND and all elements of x`list have type not COMPOUND.}
  if not assigned x`flatten then
    y := New(ExtDataFldPadExact);
    y`type := COMPOUND;
    case x`type:
    when COMPOUND:
      y`list := (#x`list eq 0) select [] else &cat[Flatten(z)`list : z in x`list];
    when EISEN, INERT, EMBED:
      y`list := [x];
    else
      error "not implemented";
    end case;
    y`top_field := x`top_field;
    y`base_field := x`base_field;
    x`flatten := y;
    y`flatten := y;
  end if;
  return x`flatten;
end intrinsic;

intrinsic IsInStandardForm(x :: ExtDataFldPadExact) -> BoolElt
  {True if E/F is in standard form.}
  if not assigned x`is_in_standard_form then
    x2 := Flatten(x);
    case #x2`list:
    when 0:
      ok := true;
    when 1:
      ok := x2`list[1] in [INERT, EISEN];
    when 2:
      ok := x2`list[1]`type eq INERT and x2`list[2]`type eq EISEN;
    else
      ok := false;
    end case;
    x`is_in_standard_form := ok;
  end if;
  return x`is_in_standard_form;
end intrinsic;

intrinsic IsInStandardForm(E :: FldPadExact, F :: FldPadExact) -> BoolElt
  {True if E/F is in standard form: E is a totally ramified extension of an unramified extension of F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return IsInStandardForm(x);
end intrinsic;

intrinsic StandardForm(x :: ExtDataFldPadExact) -> ExtDataFldPadExact
  {Returns a standard form of x.}
  if not assigned x`standard_form then
    if IsInStandardForm(x) then
      y := x;
    elif IsUnramified(x) then
      K := BaseField(x);
      L := TopField(x);
      d := Degree(x);
      y := UnramifiedExtension(K, d) / K;
    elif IsTotallyRamified(x) then
      K := BaseField(x);
      L := TopField(x);
      m := MinimalPolynomial(UniformizingElement(L), x);
      y := TotallyRamifiedExtension(K, m) / K;
    else
      K := BaseField(x);
      L := TopField(x);
      d := Degree(x);
      e := RamificationDegree(x);
      f := InertiaDegree(x);
      m := MinimalPolynomial(UniformizingElement(L) + InertiaGenerator(L), x);
      U := UnramifiedExtension(K, f);
      Ubar, bar := ResidueClassField(U);
      u := Roots(Polynomial([Ubar | ResidueClass(c) : c in Coefficients(m)]))[1][1] @@ bar @ WeakApproximation;
      mu := Polynomial([&+[U| &*[U| Binomial(i,j), Coefficient(m, i), u^(i-j)] : i in [j..d]] : j in [0..d]]); // f(x+u)
      facs := NewtonPolygonFactorization(mu);
      mi := THE([fac : fac in facs | Degree(fac) eq e and IsEisenstein(fac)]);
      y := TotallyRamifiedExtension(U, mi) / K;
    end if;
    assert IsInStandardForm(y);
    x`standard_form := y;
  end if;
  return x`standard_form;
end intrinsic;

intrinsic StandardForm(E :: FldPadExact, F :: FldPadExact) -> FldPadExact
  {Returns a standard form version of E/F (that is, a totally ramified extension of an unramified extension of F).}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return StandardForm(x)`top_field;
end intrinsic;

intrinsic DiscriminantValuation(F :: FldPadExact) -> RngIntElt
  {The valuation of the discriminant of F over its base field.}
  if not assigned F`discriminant_valuation then
    rp := RamificationPolygon(F);
    i0, v0 := Explode(Vertices(rp)[1]);
    assert i0 eq 1;
    F`discriminant_valuation := v0;
  end if;
  return F`discriminant_valuation;
end intrinsic;

intrinsic DiscriminantValuation(x :: ExtDataFldPadExact) -> RngIntElt
  {The valuation of the discriminant.}
  if not assigned x`discriminant_valuation then
    rp := RamificationPolygon(x);
    i0, v0 := Explode(Vertices(rp)[1]);
    assert i0 eq 1;
    x`discriminant_valuation := v0;
  end if;
  return x`discriminant_valuation;
end intrinsic;

intrinsic DiscriminantValuation(E :: FldPadExact, F :: FldPadExact) -> RngIntElt
  {The valuation of the discriminant of E/F.}
  ok, x := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return DiscriminantValuation(x);
end intrinsic;

function completion(K, P)
  xxC, KtoxxC_old := Completion(K, P);
  e := AbsoluteRamificationDegree(xxC);
  FUDGE := e gt 1 select 2*e else 0;
  if FUDGE gt 0 then
    KtoxxC := map<K -> xxC | x :-> (function (x)
      xxC2 := xxC;
      pr := xxC2`DefaultPrecision;
      xxC2`DefaultPrecision := pr + FUDGE;
      y := CAP_PR(KtoxxC_old(x), pr);
      xxC2`DefaultPrecision := pr;
      return y;
    end function)(x), y :-> y @@ KtoxxC_old>;
  else
    KtoxxC := KtoxxC_old;
  end if;
  C, xxCtoxC := ExactpAdicField(xxC);
  KtoxC := KtoxxC * xxCtoxC;
  function _KtoC(x)
    assert Parent(x) eq K;
    if x eq 0 then
      return C ! 0;
    end if;
    xxC2 := xxC;
    xxC2`DefaultPrecision := 1;
    init := CAP_PR(KtoxC(x), 1);
    mkupdate := func<z | function (apr)
      v := WeakValuation(z);
      pr := apr - v;
      xxC2 := xxC;
      xxC2`DefaultPrecision := pr + FUDGE;
      Update(z, CAP_APR(KtoxC(x), apr));
      return ExactpAdics_ConstGetter(true);
    end function>;
    return C ! <init, mkupdate>;
  end function;
  KtoC := map<K -> C | x :-> _KtoC(x)>;
  add_embedding(C, KtoC);
  return C, KtoC, KtoxC;
end function;

intrinsic ExactCompletion(K :: FldRat, P :: RngIntElt) -> FldPadExact, Map, Map
  {The completion C of K at P as an exact p-adic field. Also returns the embedding K to C, and the invertible map K to xC (the approximation field for C).}
  return completion(K, P);
end intrinsic;

intrinsic ExactCompletion(K :: FldRat, P :: RngInt) -> FldPadExact, Map, Map
  {"}
  return completion(K, P);
end intrinsic;

intrinsic ExactCompletion(K :: FldNum, P :: RngOrdIdl) -> FldPadExact, Map, Map
  {"}
  return completion(K, P);
end intrinsic;

intrinsic ExactCompletion(K :: FldNum, P :: PlcNumElt) -> FldPadExact, Map, Map
  {"}
  return completion(K, P);
end intrinsic;

intrinsic DescribeExtension(X :: ExtDataFldPadExact : BaseName:="") -> MonStgElt
  {A string describing the extension E/F with F described as FName.}
  if not assigned X`describe_extension then
    case X`type:
    when COMPOUND:
      d := Join([DescribeExtension(Y) : Y in Reverse(X`list)], " over ");
    when INERT:
      d := Sprintf("Unramified extension of degree %o", Degree(X));
    when EISEN:
      d := Sprintf("Totally ramified extension of degree %o", Degree(X));
    when EMBED:
      d := Sprintf("Extension of embedding of degree %o", Degree(X));
    else
      error "not implemented";
    end case;
    X`describe_extension := d;
  end if;
  d := X`describe_extension;
  if #BaseName eq 0 then
    return d;
  elif #d eq 0 then
    return BaseName;
  else
    return Sprintf("%o over %o", d, BaseName);
  end if;
end intrinsic;

intrinsic DescribeExtension(E :: FldPadExact, F :: FldPadExact : BaseName:="") -> MonStgElt
  {A string describing the extension E/F with F described as FName.}
  ok, X := IsExtensionOf(E, F);
  require ok: "E must be an extension of F";
  return DescribeExtension(X : BaseName:=BaseName);
end intrinsic;

intrinsic Print(x :: ExtDataFldPadExact, lvl :: MonStgElt)
  {Prints x.}
  printf "Extension Data";
end intrinsic;

intrinsic TopField(x :: ExtDataFldPadExact) -> FldPadExact
  {The top field of x.}
  return x`top_field;
end intrinsic;

intrinsic BaseField(x :: ExtDataFldPadExact) -> FldPadExact
  {The base field of x.}
  return x`base_field;
end intrinsic;

function quotientMap(K, n)
  // make a higher-precision version first
  e := AbsoluteRamificationDegree(K);
  if Precision(K) eq OO then
    K2 := K;
    K`DefaultPrecision := Max(K`DefaultPrecision, n+2*e);
  else
    K2 := ChangePrecision(K, Max(Precision(K), n+2*e));
  end if;
  OK2 := Integers(K2);
  QK2 := quo<OK2 | ShiftValuation(OK2!1, n+2*e)>;
  // make the version we want
  OK := Integers(K);
  QK := quo<OK | ShiftValuation(OK!1, n+2*e)>;
  m := map<K -> QK | x :-> QK!QK2!OK2!CHANGE_APR(K2!x,n+2*e), y :-> K!OK!OK2!QK2!y>;
  return QK, m;
end function;

// function henselLiftMultiroot(fs, xs, t)
//   fs_in := fs;
//   xs_in := xs;
//   R := Universe(fs);
//   K := BaseRing(R);
//   // assert K eq Universe(xs);
//   n := Rank(R);
//   assert n eq #xs;
//   assert n gt 0;
//   pr := Max([APR(c) : c in Coefficients(f), f in fs | APR(c) lt OO]);
//   QK, KtoQ := quotientMap(K, n);
//   // OK := Integers(K);
//   // QK := quo<OK | ShiftValuation(OK!1, pr)>;
//   QR := PolynomialRing(QK, n);
//   RtoQ := map<R -> QR | f :-> Polynomial([KtoQ(c) : c in cs], [Monomial(QR, Exponents(m)) : m in ms]) where cs, ms := CoefficientsAndMonomials(f)>;
//   fs := [RtoQ(f) : f in fs];
//   xs := [KtoQ(x) : x in xs];
//   V := RSpace(QK, n);
//   M := MatrixAlgebra(QK, n);
//   J := Transpose(JacobianMatrix(fs));
//   DJ := Determinant(J);
//   Jx := Evaluate(DJ, xs);
//   assert not WZERO(Jx);
//   assert Valuation(Jx) eq t;
//   ds := [Evaluate(f, xs) : f in fs];
//   s := Min([Valuation(d) : d in ds]);
//   assert s gt 2*t;
//   while true do
//     r := s - t;
//     Bvec := CAST(V, [ShiftValuation(d, -r) : d in ds]);
//     Rmat := CAST(M, [[Evaluate(J[i,j], xs) : j in [1..n]] : i in [1..n]]);
//     assert Valuation(Determinant(Rmat)) eq t;
//     U := Solution(Rmat, Bvec);
//     xsnew := [xs[i] - ShiftValuation(U[i], r) : i in [1..n]];
//     assert Valuation(Evaluate(DJ, xsnew)) eq t;
//     dsnew := [Evaluate(f, xsnew) : f in fs];
//     if forall{i : i in [1..n] | WEQ(xs[i], xsnew[i])} then
//       assert forall{d : d in dsnew | WZERO(d)};
//       return [x@@KtoQ : x in xsnew];
//     else
//       snew := Min([Valuation(d) : d in dsnew]);
//       assert forall{d : d in dsnew | WZERO(d)} or snew ge 2*r;
//       s := snew;
//       ds := dsnew;
//       xs := xsnew;
//     end if;
//   end while;
// end function;

// function henselLiftMultiroot_simple(fs, xs, t)
//   R := Universe(fs);
//   K := BaseRing(R);
//   xs := [CAST(K,x) : x in xs];
//   n := Rank(R);
//   assert n eq #xs;
//   assert n gt 0;
//   pr := Max([APR(c) : c in Coefficients(f), f in fs | APR(c) lt OO]);
//   xs := [CHANGE_APR(x, pr) : x in xs];
//   V := RSpace(K, n);
//   M := MatrixAlgebra(K, n);
//   K`DefaultPrecision := pr;
//   J := Transpose(JacobianMatrix(fs));
//   DJ := Determinant(J);
//   Jx := Evaluate(DJ, xs);
//   assert not WZERO(Jx);
//   assert Valuation(Jx) eq t;
//   ds := [Evaluate(f, xs) : f in fs];
//   s := Min([Valuation(d) : d in ds]);
//   assert s gt 2*t;
//   while true do
//     r := s - t;
//     Bvec := CAST(V, [CHANGE_APR(ShiftValuation(d, -r),pr-r) : d in ds]);
//     Rmat := CAST(M, [[CHANGE_APR(Evaluate(J[i,j], xs),pr) : j in [1..n]] : i in [1..n]]);
//     assert Valuation(Determinant(Rmat)) eq t;
//     ok, U := IsConsistent(Rmat, Bvec);
//     if not ok then
//       print "WARNING: IsHenselLiftable: Using IsInvertible because IsConsistent failed!";
//       ok, Rinv := IsInvertible(Rmat);
//       assert ok;
//       U := Bvec * Rinv;
//     end if;
//     xsnew := [CHANGE_APR(xs[i] - ShiftValuation(U[i], r), pr) : i in [1..n]];
//     assert Valuation(Evaluate(DJ, xsnew)) eq t;
//     dsnew := [Evaluate(f, xsnew) : f in fs];
//     if forall{i : i in [1..n] | WEQ(xs[i], xsnew[i])} then
//       assert forall{d : d in dsnew | WZERO(d) or Valuation(d) ge pr};
//       return xsnew;
//     else
//       snew := Min([Valuation(d) : d in dsnew]);
//       assert forall{d : d in dsnew | WZERO(d)} or snew ge 2*r;
//       s := snew;
//       ds := dsnew;
//       xs := xsnew;
//     end if;
//   end while;
// end function;

intrinsic IsSquare(x :: FldPadExactElt : Strategy:="default") -> BoolElt, FldPadExactElt
  {True iff x is a square. (Strategy is used to determine if x is nonzero.)}
  return IsPower(x, 2);
end intrinsic;

intrinsic IsPower(x :: FldPadExactElt, n :: RngIntElt : Strategy:="default") -> BoolElt, FldPadExactElt
  {True iff x is an nth power. (Strategy is used to determine if x is nonzero.)}
  requirege n, 1;
  if n eq 1 then
    return true, x;
  elif IsDefinitelyZero(x) then
    return true, x;
  end if;
  require not IsWeaklyZero(x : Strategy:=Strategy): "Argument 1 must be nonzero";
  v := Valuation(x);
  ok, v0 := IsDivisibleBy(v, n);
  if not ok then
    return false, _;
  end if;
  x0 := ShiftValuation(x, -v);
  K := Parent(x);
  R := PolynomialRing(K);
  f := R ! [K| case<i | 0:-x0, n:1, default:0> : i in [0..n]];
  p := Prime(K);
  e := AbsoluteRamificationDegree(K);
  vn := Valuation(n, p) * e;
  rs := Roots(f : Strategy := [* vn+1, <"limit", 10*vn>, <"randomize">, <"double"> *]);
  if #rs gt 0 then
    return true, ShiftValuation(rs[1][1], v0);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic EltConstructor(E :: FldPadExact, t :: .) -> FldPadExactElt
  {Makes an element of E.}
  if #t eq 1 then
    return CAST(E, t[1]);
  elif #t gt 1 then
    E0 := BaseField(E);
    return CAST(E, [E0 | x : x in t]);
  else
    error "RHS must be nonempty";
  end if;
end intrinsic;

intrinsic Temporary(F :: FldPadExact) -> TmpFldPadExact
  {The temporary elements of F.}
  if not assigned F`temporary then
    T := New(TmpFldPadExact);
    T`field := F;
    F`temporary := T;
  end if;
  return F`temporary;
end intrinsic;

intrinsic Temporary(x :: FldPadExactElt) -> TmpFldPadExactElt
  {A temporary representation of x.}
  if not assigned x`temporary then
    t := New(TmpFldPadExactElt);
    t`parent := Temporary(Parent(x));
    t`get_approximation := func<apr | Approximation_Lazy(x : APr:=apr)>;
    t`weak_valuation := WeakValuation(x);
    t`absolute_precision := AbsolutePrecision(x);
    if not WZERO(x) or IsDefinitelyZero(x) then
      t`valuation := WVAL(x);
    end if;
    x`temporary := t;
  end if;
  return x`temporary;
end intrinsic;

intrinsic Parent(t :: TmpFldPadExactElt) -> TmpFldPadExact
  {The parent of t.}
  return t`parent;
end intrinsic;

intrinsic Print(T :: TmpFldPadExact, lvl :: MonStgElt)
  {Print T.}
  case lvl:
  when "Magma":
    printf "Temporary(%m)", T`field;
  else
    printf "Temporary elements of %O", T`field, lvl;
  end case;
end intrinsic;

intrinsic Print(t :: TmpFldPadExactElt, lvl :: MonStgElt)
  {Print t.}
  printf "Temporary %O", Evaluate(t), lvl;
end intrinsic;

intrinsic Evaluate(t :: TmpFldPadExactElt) -> FldPadExactElt
  {Returns a permanent version of t.}
  T := Parent(t);
  K := T`field;
  wv := t`weak_valuation;
  get := t`get_approximation;
  init := Evaluate(t`get_approximation(t`absolute_precision));
  assert WZERO(init) or (Valuation(init) ge wv);
  mkupdate := func<z | function (apr)
    return get(apr) mod function (xz)
      assert WZERO(xz) or VAL(xz) ge wv;
      Update(z, xz);
      return true;
    end function;
  end function>;
  return K ! <init, mkupdate>;
end intrinsic;

intrinsic WeakValuation(t :: TmpFldPadExactElt) -> RngIntElt
  {A lower bound on the valuation of t.}
  return t`weak_valuation;
end intrinsic;

intrinsic AbsolutePrecision(t :: TmpFldPadExactElt) -> RngIntElt
  {The absolute precision to which a permanent version of t will be made.}
  return t`absolute_precision;
end intrinsic;

intrinsic '&+'(ts :: [TmpFldPadExactElt]) -> TmpFldPadExactElt
  {Addition.}
  T := Universe(ts);
  if #ts eq 0 then
    return T ! 0;
  elif #ts eq 1 then
    return ts[1];
  else
    t := New(TmpFldPadExactElt);
    t`parent := T;
    t`weak_valuation := Min([t`weak_valuation : t in ts]);
    t`absolute_precision := Min([t`absolute_precision : t in ts]);
    t`get_approximation := function (apr)
      return &cat[t`get_approximation(apr) : t in ts] mod function (xts)
        return &+xts;
      end function;
    end function;
    return t;
  end if;
end intrinsic;

intrinsic '+'(s :: TmpFldPadExactElt, t :: TmpFldPadExactElt) -> TmpFldPadExactElt
  {"}
  ok, T := ExistsCoveringStructure(Parent(s), Parent(t));
  require ok: "s and t must come from a common field";
  return &+[T|s,t];
end intrinsic;

intrinsic BaseField(T :: TmpFldPadExactElt) -> TmpFldPadExactElt
  {The base field of T.}
  return Temporary(BaseField(T`field));
end intrinsic;

intrinsic ExistsCoveringStructure(S :: TmpFldPadExact, T :: TmpFldPadExact) -> BoolElt, .
  {True if there is a structure containing both S and T.}
  if S eq T then
    return S;
  end if;
  ok, F := ExistsCoveringStructure(S`field, T`field);
  if ok then
    return true, Temporary(F);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic ExistsCoveringStructure(S :: TmpFldPadExact, T :: Str) -> BoolElt, .
  {"}
  ok, F := ExistsCoveringStructure(S`field, T);
  if ok then
    return true, Temporary(F);
  else
    return false, _;
  end if;
end intrinsic;

intrinsic ExistsCoveringStructure(S :: Str, T :: TmpFldPadExact) -> BoolElt, .
  {"}
  return ExistsCoveringStructure(T, S);
end intrinsic;

intrinsic 'eq'(S :: TmpFldPadExact, T :: TmpFldPadExact) -> BoolElt
  {Equality.}
  return S`field eq T`field;
end intrinsic;

intrinsic IsCoercible(T :: TmpFldPadExact, X) -> BoolElt, .
  {True if X is coercible to T, and the coerced element.}
  return false, "not coercible";
end intrinsic;

function cast_up_extension(X, x)
  assert x in X`base_field`approximation_field;
  case X`type:
  when COMPOUND:
    for Y in X`list do
      x := cast_up_extension(Y, x);
    end for;
    return x;
  when EISEN, INERT:
    return CAST(X`top_field`approximation_field, [x]);
  when EMBED:
    error "not implemented";
  else
    error "not implemented";
  end case;
end function;

intrinsic IsCoercible(T :: TmpFldPadExact, X :: TmpFldPadExactElt) -> BoolElt, .
  {"}
  if Parent(X) eq T then
    return true, X;
  end if;
  ok, ex := IsExtensionOf(T`field, X`parent`field);
  if ok then
    e := RamificationDegree(ex);
    Y := New(TmpFldPadExactElt);
    Y`parent := T;
    Y`weak_valuation := e * X`weak_valuation;
    Y`absolute_precision := e * X`absolute_precision;
    if assigned X`valuation then
      Y`valuation := e * X`valuation;
    end if;
    Y`get_approximation := function (apr)
      return X`get_approximation(Ceiling(apr / e)) mod function (xx)
        return cast_up_extension(ex, xx);
      end function;
    end function;
    return true, Y;
  end if;
  return false, "not coercible";
end intrinsic;

function tmpFromRational(T, X)
  Y := New(TmpFldPadExactElt);
  Y`parent := T;
  if X eq 0 then
    Y`weak_valuation := OO;
    Y`absolute_precision := OO;
    Y`get_approximation := func<apr | T`field`approximation_field ! 0>;
    Y`valuation := OO;
  else
    e := AbsoluteRamificationDegree(T`field);
    p := Prime(T`field);
    v := Valuation(X, p) * e;
    Y`weak_valuation := v;
    Y`absolute_precision := v + 1;
    Y`valuation := v;
    Y`get_approximation := function (apr)
      pr := Max(apr - v, 1);
      return Approximation_Lazy(T`field, pr) mod function (xT)
        return CAST(xT, X);
      end function;
    end function;
  end if;
  return Y;
end function;

intrinsic IsCoercible(T :: TmpFldPadExact, X :: RngIntElt) -> BoolElt, .
  {"}
  return true, tmpFromRational(T, X);
end intrinsic;

intrinsic IsCoercible(T :: TmpFldPadExact, X :: FldRatElt) -> BoolElt, .
  {"}
  return true, tmpFromRational(T, X);
end intrinsic;

intrinsic Eltseq(x :: TmpFldPadExactElt) -> []
  {Eltseq.}
  return [Coefficient(x, i) : i in [0..Degree(x`parent`field)-1]];
end intrinsic;

intrinsic Coefficient(x :: TmpFldPadExactElt, i :: RngIntElt) -> TmpFldPadExactElt
  {Eltseq[i].}
  T := Parent(x);
  F := T`field;
  require i ge 0 and i lt Degree(F): "i out of range";
  y := New(TmpFldPadExactElt);
  y`parent := Temporary(BaseField(F));
  case F`type:
  when INERT:
    y`weak_valuation := x`weak_valuation;
    y`absolute_precision := x`absolute_precision;
    y`get_approximation := func<apr | x`get_approximation(apr) mod func<xx | ELTSEQ(xx)[i+1]>>;
  when EISEN:
    e := RamificationDegree(F);
    y`weak_valuation := Ceiling((x`weak_valuation - i + 1) / e);
    y`absolute_precision := Ceiling((x`absolute_precision - i + 1) / e);
    y`get_approximation := func<apr | x`get_approximation(apr*e+i-1) mod func<xx | ELTSEQ(xx)[i+1]>>;
  when EMBED:
    error "not implemented";
  else
    error "not implemented";
  end case;
  return y;
end intrinsic;

intrinsic RamificationResidualPolynomials(f :: RngUPolElt_FldPadExact) -> []
  {The residual polynomials of the ramification polygon of f.}
  if not assigned f`ramification_residual_polynomials then
    f`ramification_residual_polynomials := [RamificationResidualPolynomial(f, face) : face in RamificationPolygon(f)];
  end if;
  return f`ramification_residual_polynomials;
end intrinsic;

intrinsic RamificationResidualPolynomial(f :: RngUPolElt_FldPadExact, face :: NwtnPgonFace) -> RngUPolElt
  {The residual polynomial of the given face of the ramification polygon of f.}
  require IsEisenstein(f): "f must be Eisenstein";
  if not assigned f`ramification_residual_polynomial then
    f`ramification_residual_polynomial := AssociativeArray();
  end if;
  ok, r := IsDefined(f`ramification_residual_polynomial, face);
  if not ok then
    F := BaseRing(f);
    FF, FtoFF := ResidueClassField(F);
    eF := AbsoluteRamificationDegree(F);
    d := Degree(f);
    p := Prime(F);
    v0, v1 := Explode(EndVertices(face));
    x0 := Z ! v0[1];
    y0 := Z ! v0[2];
    x1 := Z ! v1[1];
    y1 := Z ! v1[2];
    assert x0 ge 1;
    assert x1 gt x0;
    assert x1 le d;
    slope := (y1 - y0) / (x1 - x0);
    h := Numerator(-slope);
    e := Denominator(-slope);
    assert IsPowerOf(x0, p);
    ok, w0 := IsDivisibleBy(x1, x0);
    assert ok;
    if not IsDivisibleBy(w0, p) then
      assert x1 eq d;
      tame := true;
    else
      assert IsPowerOf(x1, p);
      tame := false;
    end if;
    coeffs := [FF|];
    for j in [x0..x1 by e] do
      v := Z ! (y0 + (j-x0)*slope);
      i := j + (v mod d);
      if i le d then
        c := Binomial(i, j) * Coefficient(f, i);
        tgt := Z ! ((v - i + j) / d);
        coeff := ResidueClass(ShiftValuation(c, -tgt));
      else
        coeff := 0;
      end if;
      assert coeff ne 0 or (j gt x0 and j lt x1);
      Append(~coeffs, coeff);
    end for;
    r := Polynomial(coeffs);
    assert Degree(r) eq (x1-x0)/e;
    f`ramification_residual_polynomial[face] := r;
  end if;
  return r;
end intrinsic;

intrinsic RamificationPolynomial(L :: FldPadExact) -> RngUPolElt_FldPadExact
  {The ramification polynomial of L with respect to its defining polynomial.}
  if not assigned L`ramification_polynomial then
    require L`type eq EISEN: "L must be totally ramified over its base field";
    f := DefiningPolynomial(L);
    assert IsEisenstein(f);
    pi := UniformizingElement(L);
    d := Degree(f);
    cs := [L| c : c in Coefficients(f)];
    pipwrs := [pi^n : n in [0..d]];
    L`ramification_polynomial := Polynomial([L| j eq 0 select 0 else &+[&*[L| Binomial(i,j), cs[i+1], pipwrs[i-j+1]] : i in [j..d]] : j in [0..d]]);
  end if;
  return L`ramification_polynomial;
end intrinsic;

function residueDegreeOfRootOfUnity(p,e)
  assert IsPrime(p);
  assert not IsDivisibleBy(e,p);
  f := 1;
  while not IsDivisibleBy(p^f-1,e) do
    f +:= 1;
  end while;
  return f;
end function;

intrinsic GreveField(f :: RngUPolElt_FldPadExact) -> FldPadExact
  {The Greve field of the Eisenstein polynomial f.}
  if not assigned f`greve_field then
    require IsEisenstein(f): "f must be Eisenstein";
    F := BaseRing(f);
    p := Prime(f);
    eF := AbsoluteRamificationDegree(F);
    fF := AbsoluteInertiaDegree(F);
    // get the information we need about each face
    rp := RamificationPolygon(f);
    faces := [];
    FACE := recformat<face, r, slope, h, e>;
    for face in Faces(rp) do
      r := RamificationResidualPolynomial(f, face);
      x0 := Z ! EndVertices(face)[1][1];
      x1 := Z ! EndVertices(face)[2][1];
      assert IsDivisibleBy(x1, x0);
      w := x1 - x0;
      assert Degree(r) eq w;
      assert forall{i : i in [x0..x1] | IsDivisibleBy(i, x0) or Coefficient(r,i) eq 0};
      assert IsPowerOf(x0, p);
      r0 := Polynomial([Coefficient(r,i) : i in [0..w by x0]]);
      slope := Slope(face) * x0;
      h := Numerator(-slope);
      e := Denominator(-slope);
      assert not IsDivisibleBy(e,p);
      Append(~faces, rec<FACE | face:=face, r:=r0, slope:=slope, h:=h, e:=e>);
    end for;
    // compute the unramified extension
    fr := LCM([Degree(fac[1]) : fac in Factorization(x`r), x in faces]);
    e := LCM([x`e : x in faces]);
    fe := residueDegreeOfRootOfUnity(p,e);
    ftotF := LCM(fe, fr*fF);
    ok, ftot := IsDivisibleBy(ftotF,fF);
    assert ok;
    U := UnramifiedExtension(F, ftot);
    // compute the tame extension
    
    error "not implemented";
  end if;
  return f`greve_field;
end intrinsic;

intrinsic IsUnramified(F) -> BoolElt
  {True if F is unramified.}
  return RamificationDegree(F) eq 1;
end intrinsic;

intrinsic IsUnramified(E, F) -> BoolElt
  {True if E/F is unramified.}
  return RamificationDegree(E, F) eq 1;
end intrinsic;

intrinsic IsRamified(F) -> BoolElt
  {True if F is ramified.}
  return RamificationDegree(F) ne 1;
end intrinsic;

intrinsic IsRamified(E, F) -> BoolElt
  {True if E/F is ramified.}
  return RamificationDegree(E, F) ne 1;
end intrinsic;

intrinsic IsTotallyRamified(F) -> BoolElt
  {True if F is totally ramified.}
  return InertiaDegree(F) eq 1;
end intrinsic;

intrinsic IsTotallyRamified(E, F) -> BoolElt
  {True if E/F is totally ramified.}
  return InertiaDegree(E, F) eq 1;
end intrinsic;

intrinsic IsWildlyRamified(F) -> BoolElt
  {True if F is wildly ramified.}
  return IsDivisibleBy(RamificationDegree(F), Prime(F));
end intrinsic;

intrinsic IsWildlyRamified(E, F) -> BoolElt
  {True if E/F is wildly ramified.}
  return IsDivisibleBy(RamificationDegree(E, F), Prime(F));
end intrinsic;

intrinsic IsTotallyWildlyRamified(F) -> BoolElt
  {True if F is totally wildly ramified.}
  return IsTotallyRamified(F) and IsPowerOf(RamificationDegree(F), Prime(F));
end intrinsic;

intrinsic IsTotallyWildlyRamified(E, F) -> BoolElt
  {True if E/F is totally wildly ramified.}
  return IsTotallyRamified(E,F) and IsPowerOf(RamificationDegree(E,F), Prime(F));
end intrinsic;

intrinsic '/'(E :: FldPadExact, F :: FldPadExact) -> ExtDataFldPadExact
  {The extension E/F.}
  ok, X := IsExtensionOf(E, F);
  require ok: "E is not an extension of F";
  return X;
end intrinsic;

intrinsic '/'(E :: FldPadExact, X :: ExtDataFldPadExact) -> ExtDataFldPadExact
  {Extension E/X.}
  ok, X0 := IsExtensionOf(E, TopField(X));
  require ok: "E is not an extension of X";
  return X0 / X;
end intrinsic;

intrinsic '/'(X :: ExtDataFldPadExact, F :: FldPadExact) -> ExtDataFldPadExact
  {Extension X/F.}
  ok, X0 := IsExtensionOf(BaseField(X), F);
  require ok: "X is not an extension of F";
  return X / X0;
end intrinsic;

intrinsic '/'(X1 :: ExtDataFldPadExact, X2 :: ExtDataFldPadExact) -> ExtDataFldPadExact
  {Extension X1/X2.}
  if BaseField(X1) eq TopField(X2) then
    X := New(ExtDataFldPadExact);
    X`base_field := BaseField(X2);
    X`top_field := TopField(X1);
    X`type := COMPOUND;
    X`list := [X2, X1];
    return X;
  end if;
  ok, X3 := IsExtensionOf(BaseField(X1), TopField(X2));
  require ok: "Base field of argument 1 must be an extension of top field of argument 2";
  X := New(ExtDataFldPadExact);
  X`base_field := BaseField(X2);
  X`top_field := TopField(X1);
  X`type := COMPOUND;
  X`list := [X2, X3, X1];
  return X;
end intrinsic;

intrinsic Print(h :: HomFldPadExact, lvl :: MonStgElt)
  {Prints h.}
  printf "%o fixing %o from %o to %o", IsInvertible(h) select "Isomorphism" else "Homomorphism", BaseField(h), DescribeExtension(h`xdomain : BaseName:="the base field"), ok select DescribeExtension(X : BaseName:="itself") else DescribeExtension(h`xcodomain : BaseName:="the base field") where ok,X := IsExtensionOf(Codomain(h), Domain(h));
end intrinsic;

intrinsic BaseField(h :: HomFldPadExact) -> FldPadExact
  {The base field of h, which is fixed.}
  return BaseField(h`xdomain);
end intrinsic;

intrinsic Domain(h :: HomFldPadExact) -> FldPadExact
  {"}
  return TopField(h`xdomain);
end intrinsic;

intrinsic Codomain(h :: HomFldPadExact) -> FldPadExact
  {"}
  return TopField(h`xcodomain);
end intrinsic;

intrinsic '@'(x, h :: HomFldPadExact) -> FldPadExactElt
  {Applies the map.}
  ok, x := IsCoercible(Domain(h), x);
  require ok: "Argument 1 must be coercible into domain of argument 2";
  terms := [<x, [Codomain(h)|]>];
  Xs := Reverse(Flatten(h`xdomain)`list);
  imgs := h`generator_images;
  // get cached basis images
  if not assigned h`basis_images then
    bs := [[Codomain(h)|]];
    for i in [1..#Xs] do
      assert i le #imgs;
      X := Xs[i];
      img := imgs[i];
      case Type(img):
      when FldPadExactElt:
        assert Parent(img) eq Codomain(h);
        case X`type:
        when INERT, EISEN:
          bs := [Append(b, img^i) : i in [0..Degree(X)-1], b in bs];
        else
          error "not implemented for this type of extension";
        end case;
      when UserProgram:
        assert i eq #imgs;
        break;
      else
        assert false;
      end case;
    end for;
    h`basis_images := [&*b : b in bs];
  end if;
  bs := h`basis_images;
  // get coefficients
  cs := [x];
  for i in [1..#Xs] do
    assert i le #imgs;
    X := Xs[i];
    img := imgs[i];
    case Type(img):
    when FldPadExactElt:
      case X`type:
      when INERT, EISEN:
        cs := &cat[Eltseq(c) : c in cs];
      else
        error "not implemented for this type of extension";
      end case;
    when UserProgram:
      assert i eq #imgs;
      cs := [img(c) : c in cs];
      break;
    end case;
  end for;
  // compute
  assert #cs eq #bs;
  return &+[bs[i] * cs[i] : i in [1..#cs]];
end intrinsic;

intrinsic IsInvertible(h :: HomFldPadExact) -> BoolElt, HomFldPadExact
  {True if h has an inverse, and the inverse.}
  if assigned h`inverse then
    return true, h`inverse;
  else
    return false, _;
  end if;
end intrinsic;

intrinsic Inverse(h :: HomFldPadExact) -> HomFldPadExact
  {The inverse of h.}
  ok, i := IsInvertible(h);
  require ok: "Argument 1 must be invertible";
  return i;
end intrinsic;

intrinsic '@@'(x, h :: HomFldPadExact) -> FldPadExactElt
  {Applies the inverse map.}
  ok, i := IsInvertible(h);
  require ok: "Argument 1 must be invertible";
  return x @ i;
end intrinsic;

intrinsic TrivialEmbedding(X :: ExtDataFldPadExact) -> HomFldPadExact
  {The trivial embedding of BaseField(X) into TopField(X).}
  h := New(HomFldPadExact);
  E := TopField(X);
  F := BaseField(X);
  h`xdomain := F / F;
  h`xcodomain := X;
  h`generator_images := [* func<x | E ! x> *];
  if E eq F then
    h`inverse := h;
  end if;
  return h;
end intrinsic;

intrinsic TrivialEmbedding(F :: FldPadExactElt, E :: FldPadExactElt) -> HomFldPadExact
  {The trivial embedding of F into E.}
  return TrivialEmbedding(E/F);
end intrinsic;

intrinsic '*'(h1 :: HomFldPadExact, h2 :: HomFldPadExact) -> HomFldPadExact
  {The composition x @ (h1 * h2) = x @ h1 @ h2.}
  D1 := Domain(h1);
  C1 := Codomain(h1);
  B1 := BaseField(h1);
  D1B1 := h1`xdomain;
  C1B1 := h1`xcodomain;
  D2 := Domain(h2);
  C2 := Codomain(h2);
  B2 := BaseField(h2);
  D2B2 := h2`xdomain;
  C2B2 := h2`xcodomain;
  ok, D2C1 := IsExtensionOf(D2, C1);
  require ok: "Domain of argument 2 must be an extension of codomain of argument 1";
  // compute the domain, codomain and base field
  D := D1;
  C := C2;
  ok, B1B2 := IsExtensionOf(B1, B2);
  if ok then
    B := B2;
    DB := D1B1/B1B2;
    CB := C2B2;
  else
    ok, B2B1 := IsExtensionOf(B2, B1);
    if ok then
      B := B1;
      DB := D1B1;
      CB := C2B2/B2B1;
    else
      B := PrimeField(B1);
      DB := D1B1/B;
      CB := C2B2/B;
    end if;
  end if;
  // compute generator images
  imgs := [**];
  imgs1 := h1`generator_images;
  Xs := Reverse(Flatten(DB)`list);
  for i in [1..#Xs] do
    X := Xs[i];
    if i le #imgs1 then
      img1 := imgs1[i];
      case Type(img1):
      when FldPadExactElt:
        assert Parent(img1) eq C1;
        Append(~imgs, img1 @ h2);
      when UserProgram:
        Append(~imgs, func<x | img1(x)@h2>);
        break;
      end case;
    else
      case X`type:
      when INERT, EISEN:
        Append(~imgs, Generator(TopField(X)) @ h2);
      else
        error "not implemented for this type of extension";
      end case;
    end if;
  end for;
  // compute the map
  h := New(HomFldPadExact);
  h`xdomain := DB;
  h`xcodomain := CB;
  h`generator_images := imgs;
  return h;
end intrinsic;

intrinsic Embeddings(X :: ExtDataFldPadExact, h :: HomFldPadExact) -> []
  {The embeddings of TopField(X) into Codomain(h) extending h:BaseField(X)->Codomain(h).}
  require BaseField(X) eq Domain(h): "Base field of argument 1 must equal domain of argument 2";
  case X`type:
  when COMPOUND:
    hs := [h];
    for X0 in X`list do
      hs := &cat[Universe([[h]]) | Embeddings(X0, h) : h in hs];
    end for;
    return hs;
  when EISEN, INERT:
    f := DefiningPolynomial(TopField(X));
    hf := Polynomial([c@h : c in Coefficients(f)]);
    hs := [];
    // TODO: what strategy to give to Roots?
    for r in Roots(hf) do
      h1 := New(HomFldPadExact);
      h1`xdomain := X / h`xdomain;
      h1`xcodomain := h`xcodomain;
      h1`generator_images := [* r[1] *] cat [* img : img in h`generator_images *];
      Append(~hs, h1);
    end for;
    return hs;
  else
    error "not implemented for this type of extension";
  end case;
end intrinsic;

intrinsic Embeddings(X1 :: ExtDataFldPadExact, X2 :: ExtDataFldPadExact, h0 :: HomFldPadExact) -> []
  {The embeddings of TopField(X1) into TopField(X2) extending h0:BaseField(X1)->BaseField(X2).}
  require BaseField(X1) eq Domain(h0): "Base field of argument 1 must equal domain of argument 3";
  require BaseField(X2) eq Codomain(h0): "Base field of argument 2 must equal codomain of argument 3";
  return Embeddings(X1, h0 * TrivialEmbedding(X2));
end intrinsic;

intrinsic Embeddings(X1 :: ExtDataFldPadExact, X2 :: ExtDataFldPadExact) -> []
  {The embeddings of TopField(X1) into TopField(X2) fixing BaseField(X1)=BaseField(X2).}
  require BaseField(X1) eq BaseField(X2): "Base field of argument 1 must equal base field of argument 2";
  return Embeddings(X1, TrivialEmbedding(X2));
end intrinsic;

intrinsic SetBaselineValuation(x :: FldPadExactElt, n)
  {Sets the baseline valuation.}
  x`baseline_valuation := n;
end intrinsic;

intrinsic SetBaselineValuation(f :: RngUPolElt_FldPadExact, n)
  {"}
  ok, n := IsValidAbsolutePrecision(f, n);
  require ok: "invalid n";
  f`baseline_valuation := n;
end intrinsic;

intrinsic BaselineValuation(x :: FldPadExactElt) -> RngIntElt
  {The baseline valuation.}
  return x`baseline_valuation;
end intrinsic;

intrinsic BaselineValuation(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {"}
  return f`baseline_valuation;
end intrinsic;

intrinsic BaselinePrecision(x :: FldPadExactElt) -> Val_FldPadElt
  {The baseline precision of x: AbsolutePrecision(x) - BaselineValuation(x).}
  return APR(x) - BVAL(x);
end intrinsic;

intrinsic BaselinePrecision(f :: RngUPolElt_FldPadExact) -> Val_RngUPolElt_FldPad
  {The baseline precision of f: AbsolutePrecision(f) - BaselineValuation(f).}
  return APR(f) - BVAL(f);
end intrinsic;

intrinsic IncreaseBaselinePrecision(x :: FldPadExactElt, n)
  {Increases the baseline precision.}
  INC_APR(x, BVAL(x) + n);
end intrinsic;

intrinsic IncreaseBaselinePrecision(f :: RngUPolElt_FldPadExact, n)
  {"}
  INC_APR(f, BVAL(f) + n);
end intrinsic;

intrinsic Factorization_Doris
  ( f :: RngUPolElt_FldPadExact
  : Strategy     := "default"    // the default strategy
  , MainStrategy := Strategy     // the main factorization strategy
  , Extensions   := false        // when true, include extensions in the certificate
  ) -> [], FldPadExactElt, []
  {The factorization of f as a sequence of <factor,multiplicity> pairs, the leading coefficient, and a corresponding sequence of factorization certificates.}
  if assigned f`factorization_doris then
    factors, lc := Explode(f`factorization_doris);
    changed := false;
  else
    // get the leading coefficient
    lc := LeadingCoefficient(f : Strategy:=Strategy);
    // get the factorization certificates
    ok, pr, xcerts := ExactpAdics_ExecutePrecisionStrategy(function (pr)
      // TODO: "APr:=pr" isn't great, use something covariant with shifting and sloping at least? BaselineNewtonPolygonPrecision?
      xf := Approximation(f : APr:=pr);
      // now factor
      try
        xcerts := Factorization_Doris(xf : Quick);
      catch err
        if IS_PREC_ERR(err) then
          return false, _;
        else
          xcerts := Factorization_Doris(xf : Quick);
        end if;
      end try;
      return true, xcerts;
    end function, MainStrategy);
    error if not ok, PREC_ERR("could not factorize");
    // make certificates
    R := Parent(f);
    FACTOR := recformat<xcert, xcert2, cert, fac, mult>;
    CERT := recformat<E, F, Rho, Pi, Extension>;
    factors := [rec<FACTOR | xcert:=xcert, cert:=rec<CERT | E:=xcert`E, F:=xcert`F, Rho:=WeakApproximation(CAST(R, xcert`rho)), Pi:=WeakApproximation(CAST(R, xcert`pi))>> : xcert in xcerts];
    // single factor lifting
    // there is a version of Hensel's lemma which applies immediately; but for now, we just cheat and do single factor lifting enough to apply a weaker version of Hensel's lemma
    for i in [1..#factors] do
      ok, _, fac := ExactpAdics_ExecutePrecisionStrategy(function (pr)
        xf := Approximation(f : APr:=pr);
        xR := Parent(xf);
        pr := Precision(BaseRing(xR));
        xfac := xR ! factors[i]`xcert`g;
        niters := 0;
        while true do
          assert niters lt 20;
          niters +:= 1;
          xfac := xR ! [BaseRing(xR) | IsWeaklyZero(c) select 0 else ChangePrecision(c, pr) : c in Coefficients(xfac)];
          c0 := xf mod xfac;
          c1 := (xf div xfac) mod xfac;
          g, c1inv := XGCD(c1, xfac);
          if not IsWeaklyEqual(g, 1) then
            return false, _;
          end if;
          xfacnew := xfac + ((c0 * c1inv) mod xfac);
          if WEQ(xfacnew, xfac) then
            ok, fac := IsHenselLiftable(f, WeakApproximation(CAST(R, xfac)) : Strategy:=Strategy, ShiftValuation, ShiftSlope);
            if ok then
              return true, fac;
            else
              return false, _;
            end if;
          else
            xfac := xfacnew;
          end if;
        end while;
      end function, MainStrategy);
      error if not ok, PREC_ERR("could not do initial single factor lifting");
      factors[i]`fac := fac;
      factors[i]`mult := 1;
    end for;
    changed := true;
  end if;
  // get extensions
  // again, although we already have most information to do this, we just cheat and call Factorization again until we get the right answer...
  if Extensions then
    for i in [1..#factors] do
      if not assigned factors[i]`xcert2 then
        ok, _, xcert2 := ExactpAdics_ExecutePrecisionStrategy(function (pr)
          xfac := Approximation(factors[i]`fac : APr:=pr);
          try
            xcerts2 := Factorization_Doris(xfac : Extensions);
          catch err
            if IS_PREC_ERR(err) then
              return false, _;
            else
              xcerts2 := Factorization_Doris(xfac : Extensions);
            end if;
          end try;
          assert #xcerts2 eq 1;
          xR := Parent(xfac);
          xK := BaseRing(xR);
          xxL := xcerts2[1]`L;
          if isDefinitelyUnique(xxL, xK) then
            return true, xcerts2[1];
          else
            return false, _;
          end if;
        end function, MainStrategy);
        error if not ok, PREC_ERR("could not find extensions");
        factors[i]`xcert2 := xcert2;
        factors[i]`cert`Extension := ExactpAdicField(xcert2`L, xcert2`K, BaseRing(f));
        changed := true;
      end if;
    end for;
  end if;
  // done
  if changed then
    f`factorization_doris := [* factors, lc *];
  end if;
  return [<x`fac, x`mult> : x in factors], lc, [x`cert : x in factors];
end intrinsic;

intrinsic IsIrreducible_Doris(f :: RngUPolElt_FldPadExact : Strategy:="default") -> BoolElt, .
  {True iff f is irreducible. If true, also returns an irreducibility certificate. If false, returns a factor.}
  if assigned f`is_irreducible_doris then
    ret := f`is_irreducible_doris;
  else
    // TODO: implement a version of Factorization_Doris which terminates as soon as a single factor is found and use this
    facs, lc, certs := Factorization_Doris(f : Strategy:=Strategy);
    if #facs eq 1 and facs[1][2] eq 1 then
      ret := [* true, certs[1] *];
    else
      ret := [* false, facs[1][1] *];
    end if;
    f`is_irreducible_doris := ret;
  end if;
  return Explode(ret);
end intrinsic;

