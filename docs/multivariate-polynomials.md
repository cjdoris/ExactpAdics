# Multivariate polynomials
{:#multivariate-polynomials}


**Contents**
* [Creation of rings](#creation-of-rings)
* [Basic operations on rings](#basic-operations-on-rings)
* [Creation of polynomials](#creation-of-polynomials)
* [Basic operations on polynomials](#basic-operations-on-polynomials)
* [Approximation](#approximation)
* [Printing](#printing)
* [Hensel lifting](#hensel-lifting)

## Creation of rings
{:#creation-of-rings}

<a id="PolynomialRing--FldPadExact--etc"></a><a id="PolynomialRing--FldPadExact--RngIntElt"></a><a id="PolynomialRing"></a>
> **PolynomialRing** (F :: *FldPadExact*, n :: *RngIntElt*)
> 
> -> *RngMPol_FldPadExact*
> {:.ret}
{:.intrinsic}

A polynomial ring of rank `n` over `F`.


## Basic operations on rings
{:#basic-operations-on-rings}

<a id="BaseRing"></a><a id="BaseRing--RngMPol_FldPadExact"></a>
> **BaseRing** (R :: *RngMPol_FldPadExact*)
> 
> -> *FldPadExact*
> {:.ret}
{:.intrinsic}

The coefficient ring of `R`.


<a id="Rank--RngMPol_FldPadExact"></a><a id="Rank"></a>
> **Rank** (R :: *RngMPol_FldPadExact*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The rank of `R`.


<a id="AssignNames--RngMPol_FldPadExact--seq-MonStgElt"></a><a id="AssignNames"></a><a id="AssignNames--RngMPol_FldPadExact--etc"></a>
> **AssignNames** (~R :: *RngMPol_FldPadExact*, names :: [*MonStgElt*])
{:.intrinsic}

Assigns `names` to the generators of `R`.


<a id="Name--RngMPol_FldPadExact--etc"></a><a id=".--RngMPol_FldPadExact--etc"></a><a id=".--RngMPol_FldPadExact--RngIntElt"></a><a id="."></a><a id="Name"></a><a id="Name--RngMPol_FldPadExact--RngIntElt"></a>
> **Name** (R :: *RngMPol_FldPadExact*, i :: *RngIntElt*)
> 
> **\'.\'** (R :: *RngMPol_FldPadExact*, i :: *RngIntElt*)
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

The `i`th generator of `R`.




<a id="GeneratorsSequence--RngMPol_FldPadExact"></a><a id="GeneratorsSequence"></a>
> **GeneratorsSequence** (R :: *RngMPol_FldPadExact*)
> 
> -> []
> {:.ret}
{:.intrinsic}

The indeterminates generating `R`.


<a id="eq--RngMPol_FldPadExact--RngMPol_FldPadExact"></a><a id="eq--RngMPol_FldPadExact--etc"></a><a id="eq"></a>
> **\'eq\'** (R :: *RngMPol_FldPadExact*, S :: *RngMPol_FldPadExact*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

Equality. True if and only if `R` and `S` were generated by the same call to `PolynomialRing`.


## Creation of polynomials
{:#creation-of-polynomials}

<a id="IsCoercible"></a><a id="IsCoercible--RngMPol_FldPadExact--any"></a><a id="IsCoercible--RngMPol_FldPadExact--etc"></a>
> **IsCoercible** (R :: *RngMPol_FldPadExact*, X)
> 
> -> *BoolElt*, Any
> {:.ret}
{:.intrinsic}

True if `X` is coercible into `R`. If so, also returns the coerced element. If not, returns a string explaining why.

Succeeds if either:
- `X` is an element of `R`
- `X` is a `RngMPolElt` and its coefficients are coercible into the base ring of `R`
- `X` is a tuple `<cs, es>` where `cs` is a sequence of coefficients coercible into the base ring of `R` and `es` is a corresponding sequence of exponent vectors.
- `X` is a tuple `<init, mkupdate>` or `<init, mkupdate, data>` where `init` is an initial approximation (a `RngMPolElt`) and `mkupdate` is a function making an update function.


<a id="CanChangeRing--RngMPolElt_FldPadExact--FldPadExact"></a><a id="CanChangeRing"></a><a id="CanChangeRing--RngMPolElt_FldPadExact--etc"></a><a id="CanChangeRing--RngMPolElt--FldPadExact"></a><a id="CanChangeRing--RngMPolElt--etc"></a>
> **CanChangeRing** (f :: *RngMPolElt_FldPadExact*, K :: *FldPadExact*)
> 
> **CanChangeRing** (f :: *RngMPolElt*, K :: *FldPadExact*)
> 
> -> *BoolElt*, *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

True if `f` can be coerced to a polynomial over `K`. If so, also returns the coerced polynomial. If not, returns a string explaining why.




## Basic operations on polynomials
{:#basic-operations-on-polynomials}

<a id="BaseRing-2"></a><a id="BaseRing--RngMPolElt_FldPadExact"></a>
> **BaseRing** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *FldPadExact*
> {:.ret}
{:.intrinsic}

The base ring of `f`.


<a id="DotProduct--seq-RngMPolElt_FldPadExact--etc"></a><a id="DotProduct"></a><a id="DotProduct--seq-RngMPolElt_FldPadExact--seq-FldPadExactElt"></a>
> **DotProduct** (fs :: [*RngMPolElt_FldPadExact*], xs :: [*FldPadExactElt*])
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Equivalent to `&+[fs[i]*xs[i] : i in [1..n]]` where `n` = `#fs` = `#xs`.


<a id="IsIntegral"></a><a id="IsIntegral--RngMPolElt_FldPadExact"></a>
> **IsIntegral** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

True iff all coefficients of `f` have valuation at least 0.


<a id="ShiftArgument--RngMPolElt_FldPadExact--etc"></a><a id="ShiftArgument--RngMPolElt_FldPadExact--seq-FldPadExactElt"></a><a id="ShiftArgument"></a>
> **ShiftArgument** (f :: *RngMPolElt_FldPadExact*, xs :: [*FldPadExactElt*])
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

The polynomial `f(X1+xs[1],X2+xs[2]...)`.


<a id="*--RngMPolElt_FldPadExact--etc"></a><a id="*"></a><a id="*--RngMPolElt_FldPadExact--FldPadExactElt"></a>
> **\'\*\'** (f :: *RngMPolElt_FldPadExact*, x :: *FldPadExactElt*)
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Multiplication of `f` by a scalar `x`.


<a id="ShiftValuation--RngMPolElt_FldPadExact--any"></a><a id="ShiftValuation--RngMPolElt_FldPadExact--etc"></a><a id="ShiftValuation"></a>
> **ShiftValuation** (f :: *RngMPolElt_FldPadExact*, n)
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Shifts the valuation of the `e`th coefficient of `f` by `n(e)` where `n` is a valuation for `f`.


<a id="ShiftSlope--RngMPolElt_FldPadExact--etc"></a><a id="ShiftSlope"></a><a id="ShiftSlope--RngMPolElt_FldPadExact--seq"></a>
> **ShiftSlope** (f :: *RngMPolElt_FldPadExact*, ns :: [])
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Shifts the valuation of the `e`th coefficient of `f` by `ns.e`.


<a id="&+--seq-RngMPolElt_FldPadExact"></a><a id="&+"></a>
> **\'&+\'** (fs :: [*RngMPolElt_FldPadExact*])
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Sum.


## Approximation
{:#approximation}

Intrinsics to do with the current approximation of an exact p-adic polynomial.

<a id="_ExactpAdics_PrecisionRequired--RngMPol_FldPadExact--etc"></a><a id="_ExactpAdics_PrecisionRequired--RngMPol_FldPadExact--RngMPolElt--any"></a><a id="_ExactpAdics_PrecisionRequired"></a>
> **_ExactpAdics_PrecisionRequired** (R :: *RngMPol_FldPadExact*, xf :: *RngMPolElt*, apr)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The (relative) precision required in the base ring to approximate `f` to absolue precision `apr`.


<a id="_ExactpAdics_WeakValuationOfApproximation--RngMPol_FldPadExact--etc"></a><a id="_ExactpAdics_WeakValuationOfApproximation--RngMPol_FldPadExact--RngMPolElt"></a><a id="_ExactpAdics_WeakValuationOfApproximation"></a>
> **_ExactpAdics_WeakValuationOfApproximation** (R :: *RngMPol_FldPadExact*, xf :: *RngMPolElt*)
> 
> -> *Val_RngMPolElt_FldPad*
> {:.ret}
{:.intrinsic}

The weak valuation of `xf`.


<a id="_ExactpAdics_AbsolutePrecisionOfApproximation--RngMPol_FldPadExact--RngMPolElt"></a><a id="_ExactpAdics_AbsolutePrecisionOfApproximation"></a><a id="_ExactpAdics_AbsolutePrecisionOfApproximation--RngMPol_FldPadExact--etc"></a>
> **_ExactpAdics_AbsolutePrecisionOfApproximation** (R :: *RngMPol_FldPadExact*, xf :: *RngMPolElt*)
> 
> -> *Val_RngMPolElt_FldPad*
> {:.ret}
{:.intrinsic}

The weak valuation of `xf`.


<a id="IncreaseAbsolutePrecision_Lazy"></a><a id="IncreaseAbsolutePrecision_Lazy--RngMPol_FldPadExact--RngIntElt"></a><a id="IncreaseAbsolutePrecision_Lazy--RngMPol_FldPadExact--etc"></a>
> **IncreaseAbsolutePrecision_Lazy** (R :: *RngMPol_FldPadExact*, pr :: *RngIntElt*)
> 
> -> *ExactpAdics_Gettr*
> {:.ret}
{:.intrinsic}

Increases the precision of the approximation to `R` to at least `pr`.


<a id="Approximation_Lazy--RngMPol_FldPadExact--RngIntElt"></a><a id="Approximation_Lazy"></a><a id="Approximation_Lazy--RngMPol_FldPadExact--etc"></a>
> **Approximation_Lazy** (R :: *RngMPol_FldPadExact*, pr :: *RngIntElt*)
> 
> -> *ExactpAdics_Gettr*
> {:.ret}
{:.intrinsic}

An approximation to `R` whose base field has default precision `pr`.


<a id="MinValuation--RngMPolElt_FldPadExact"></a><a id="MinValuation"></a>
> **MinValuation** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The smallest valuation of the coefficients of `f`.

**Parameters**
- `Strategy`

<a id="IsWeaklyZero"></a><a id="IsWeaklyZero--RngMPolElt_FldPadExact"></a>
> **IsWeaklyZero** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

True if `f` is weakly zero.

**Parameters**
- `Strategy`

## Printing
{:#printing}

<a id="Format--RngMPolElt_FldPadExact"></a><a id="Format"></a>
> **Format** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *MonStgElt*
> {:.ret}
{:.intrinsic}

A string representation of `f`.


**Parameters**
- `APr`: Output to this absolute precision.

## Hensel lifting
{:#hensel-lifting}

<a id="IsHenselLiftable"></a><a id="IsHenselLiftable--seq-RngMPolElt_FldPadExact--etc"></a><a id="IsHenselLiftable--seq-RngMPolElt_FldPadExact--seq-FldPadExactElt"></a>
> **IsHenselLiftable** (fs :: [*RngMPolElt_FldPadExact*], xs :: [*FldPadExactElt*])
> 
> -> *BoolElt*, []
> {:.ret}
{:.intrinsic}

True if `xs` are Hensel liftable to a system of roots of `fs`. If so, also returns the system of roots.

`fs` must be a system of `n` equations of rank `n`, and `xs` must be a sequence of `n` p-adic numbers.


**Parameters**
- `Strategy := "default"`: The precision strategy to use.
- `Slopes`: When given, must be a sequence of `n` rationals to slope the equations by. That is, conceptually we multiply the `i`th variable by `pi^Slopes[i]` and `xs[i]` correspondingly by `pi^-Slopes[i]`. When not given, the zero slope is used.
- `Shifts`: When given, must be a sequence of `n` rationals to shift the equations by. That is, conceptually we multiply the `i`th equation by `pi^Shifts[i]`. When not given, the best shifts are chosen.

