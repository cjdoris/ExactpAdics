# Multivariate polynomials


**Contents**
* [Creation of rings](#creation-of-rings)
* [Basic operations on rings](#basic-operations-on-rings)
* [Creation of polynomials](#creation-of-polynomials)
* [Basic operations on polynomials](#basic-operations-on-polynomials)
* [Approximation](#approximation)
* [Printing](#printing)
* [Hensel lifting](#hensel-lifting)

## Creation of rings

> **PolynomialRing** (F :: *FldPadExact*, n :: *RngIntElt*)
> 
> -> *RngMPol_FldPadExact*
> {:.ret}
{:.intrinsic}

A polynomial ring of rank `n` over `F`.


## Basic operations on rings

> **BaseRing** (R :: *RngMPol_FldPadExact*)
> 
> -> *FldPadExact*
> {:.ret}
{:.intrinsic}

The coefficient ring of `R`.


> **Rank** (R :: *RngMPol_FldPadExact*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The rank of `R`.


> **AssignNames** (~R :: *RngMPol_FldPadExact*, names :: [*MonStgElt*])
{:.intrinsic}

Assigns `names` to the generators of `R`.


> **Name** (R :: *RngMPol_FldPadExact*, i :: *RngIntElt*)
> 
> **\'.\'** (R :: *RngMPol_FldPadExact*, i :: *RngIntElt*)
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

The `i`th generator of `R`.




> **GeneratorsSequence** (R :: *RngMPol_FldPadExact*)
> 
> -> []
> {:.ret}
{:.intrinsic}

The indeterminates generating `R`.


> **\'eq\'** (R :: *RngMPol_FldPadExact*, S :: *RngMPol_FldPadExact*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

Equality. True if and only if `R` and `S` were generated by the same call to `PolynomialRing`.


## Creation of polynomials

> **IsCoercible** (R :: *RngMPol_FldPadExact*, X)
> 
> -> *BoolElt*, Any
> {:.ret}
{:.intrinsic}

True if `X` is coercible into `R`. If so, also returns the coerced element. If not, returns a string explaining why.

Succeeds if either:
- `X` is an element of `R`
- `X` is a `RngMPolElt` and its coefficients are coercible into the base ring of `R`
- `X` is a tuple `<cs, es>` where `cs` is a sequence of coefficients coercible into the base ring of `R` and `es` is a corresponding sequence of exponent vectors.
- `X` is a tuple `<init, mkupdate>` or `<init, mkupdate, data>` where `init` is an initial approximation (a `RngMPolElt`) and `mkupdate` is a function making an update function.


> **CanChangeRing** (f :: *RngMPolElt_FldPadExact*, K :: *FldPadExact*)
> 
> **CanChangeRing** (f :: *RngMPolElt*, K :: *FldPadExact*)
> 
> -> *BoolElt*, *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

True if `f` can be coerced to a polynomial over `K`. If so, also returns the coerced polynomial. If not, returns a string explaining why.




## Basic operations on polynomials

> **BaseRing** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *FldPadExact*
> {:.ret}
{:.intrinsic}

The base ring of `f`.


> **DotProduct** (fs :: [*RngMPolElt_FldPadExact*], xs :: [*FldPadExactElt*])
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Equivalent to `&+[fs[i]*xs[i] : i in [1..n]]` where `n` = `#fs` = `#xs`.


> **IsIntegral** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

True iff all coefficients of `f` have valuation at least 0.


> **ShiftArgument** (f :: *RngMPolElt_FldPadExact*, xs :: [*FldPadExactElt*])
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

The polynomial `f(X1+xs[1],X2+xs[2]...)`.


> **\'\*\'** (f :: *RngMPolElt_FldPadExact*, x :: *FldPadExactElt*)
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Multiplication of `f` by a scalar `x`.


> **ShiftValuation** (f :: *RngMPolElt_FldPadExact*, n)
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Shifts the valuation of the `e`th coefficient of `f` by `n(e)` where `n` is a valuation for `f`.


> **ShiftSlope** (f :: *RngMPolElt_FldPadExact*, ns :: [])
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Shifts the valuation of the `e`th coefficient of `f` by `ns.e`.


> **\'&+\'** (fs :: [*RngMPolElt_FldPadExact*])
> 
> -> *RngMPolElt_FldPadExact*
> {:.ret}
{:.intrinsic}

Sum.


## Approximation

Intrinsics to do with the current approximation of an exact p-adic polynomial.

> **_ExactpAdics_PrecisionRequired** (R :: *RngMPol_FldPadExact*, xf :: *RngMPolElt*, apr)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The (relative) precision required in the base ring to approximate `f` to absolue precision `apr`.


> **_ExactpAdics_WeakValuationOfApproximation** (R :: *RngMPol_FldPadExact*, xf :: *RngMPolElt*)
> 
> -> *Val_RngMPolElt_FldPad*
> {:.ret}
{:.intrinsic}

The weak valuation of `xf`.


> **_ExactpAdics_AbsolutePrecisionOfApproximation** (R :: *RngMPol_FldPadExact*, xf :: *RngMPolElt*)
> 
> -> *Val_RngMPolElt_FldPad*
> {:.ret}
{:.intrinsic}

The weak valuation of `xf`.


> **IncreaseAbsolutePrecision_Lazy** (R :: *RngMPol_FldPadExact*, pr :: *RngIntElt*)
> 
> -> *ExactpAdics_Gettr*
> {:.ret}
{:.intrinsic}

Increases the precision of the approximation to `R` to at least `pr`.


> **Approximation_Lazy** (R :: *RngMPol_FldPadExact*, pr :: *RngIntElt*)
> 
> -> *ExactpAdics_Gettr*
> {:.ret}
{:.intrinsic}

An approximation to `R` whose base field has default precision `pr`.


> **MinValuation** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *RngIntElt*
> {:.ret}
{:.intrinsic}

The smallest valuation of the coefficients of `f`.

**Parameters**
- `Strategy`

> **IsWeaklyZero** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *BoolElt*
> {:.ret}
{:.intrinsic}

True if `f` is weakly zero.

**Parameters**
- `Strategy`

## Printing

> **Format** (f :: *RngMPolElt_FldPadExact*)
> 
> -> *MonStgElt*
> {:.ret}
{:.intrinsic}

A string representation of `f`.


**Parameters**
- `APr`: Output to this absolute precision.

## Hensel lifting

> **IsHenselLiftable** (fs :: [*RngMPolElt_FldPadExact*], xs :: [*FldPadExactElt*])
> 
> -> *BoolElt*, []
> {:.ret}
{:.intrinsic}

True if `xs` are Hensel liftable to a system of roots of `fs`. If so, also returns the system of roots.

`fs` must be a system of `n` equations of rank `n`, and `xs` must be a sequence of `n` p-adic numbers.


**Parameters**
- `Strategy := "default"`: The precision strategy to use.
- `Slopes`: When given, must be a sequence of `n` rationals to slope the equations by. That is, conceptually we multiply the `i`th variable by `pi^Slopes[i]` and `xs[i]` correspondingly by `pi^-Slopes[i]`. When not given, the zero slope is used.
- `Shifts`: When given, must be a sequence of `n` rationals to shift the equations by. That is, conceptually we multiply the `i`th equation by `pi^Shifts[i]`. When not given, the best shifts are chosen.

