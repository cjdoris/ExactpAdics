// Suppose we have f(x), g(x), Pi(x), Rho(x) such that g(x) approximates an irreducible factor of f(x) uniquely, and Pi(x) is a uniformizer of and Rho(x) generates the residue class field of the extension defined by the factor. Can we prove that g(x) is close to an irreducible factor? Can we (Hensel) lift it to be closer to the factor? Consider f mod g in the basis {Rho^i * Pi^j mod g : i<F, j<E}, we should be able to Hensel-lift this directly.

///# Univariate polynomials
///## Root-finding and factorization

import "ExactpAdics.mag": CAP_APR, CHANGE_APR, WZERO, WVAL, VAL, APR;
OO := Infinity();
Z := Integers();
declare verbose ExactpAdics_Factorization, 2;
declare verbose ExactpAdics_Roots, 2;

function reslope(f, slope : pivot:=Degree(f))
  deg := Degree(f);
  return Parent(f) ! [ShiftValuation(Coefficient(f, i), slope*(i-pivot)) : i in [0..deg]];
end function;

function reslope0(f, slope)
  return reslope(f, slope : pivot:=0);
end function;

function deslope(f)
  deg := Degree(f);
  if deg le 0 then
    return f, 0;
  end if;
  np := NewtonPolygon([<i, v> : i in [0..deg] | v lt Infinity() where v:=Valuation(Coefficient(f,i))] : Faces:="Lower");
  slope := Ceiling(Max(Slopes(np)));
  return reslope(f, -slope), slope;
end function;

function reshift(f, shift)
  return Parent(f) ! [ShiftValuation(c, shift) : c in Coefficients(f)];
end function;

function integralize(f)
  deg := Degree(f);
  if deg lt 0 then
    return f, 0;
  end if;
  val := Min([Valuation(c) : c in Coefficients(f)]);
  return reshift(f, -val), val;
end function;

function nicen(f)
  f2, slope := deslope(f);
  f3, val := integralize(f2);
  return f3, slope, val;
end function;

CERT := recformat<E, F, Pi, Rho, IdealGen1, IdealGen2, Extension>;

/// The factorization of f as a sequence of `<factor, multiplicity>` pairs.
/// 
/// It is only possible to factorize squarefree polynomials, so `multiplicity` is always 1. The factors are monic; also returns the leading coefficient of `f`.
/// 
///param Strategy The precision strategy.
///param Certificates When `true`, also returns a corresponding sequence of certificates including fields `F`, `E`, `Rho` and `Pi`.
///param Extensions When `true` implies `Certificates` and also includes `Extension` in each certificate.
///param Ideals When `true` implies `Certificates` and also includes `IdealGen1` and `IdealGen2` in each certificate.
intrinsic Factorization(f :: RngUPolElt_FldPadExact : Strategy:="default", Certificates:=false, Extensions:=false, Ideals:=false) -> [], FldPadElt, []
  {The factorization of f.}
  Certificates or:= Extensions or Ideals;
  // approximate factorization
  degf := WeakDegree(f);
  R := Parent(f);
  K := BaseRing(R);
  ok, _, data := ExactpAdics_ExecutePrecisionStrategy(function (pr)
    vprint ExactpAdics_Factorization: "precision =", pr;
    xf, slope, shift := nicen(Approximation(f, BaselineValuation(f) + pr));
    xK := BaseRing(xf);
    // ensure full degree and monic
    if WZERO(Coefficient(xf, degf)) then
      return false, _;
    end if;
    xf /:= Coefficient(xf, degf);
    // try to factorize
    try
      xfacs, _, xcerts := Factorization(xf : IsSquarefree:=true, Certificates:=true, Extensions:=Extensions, Ideals:=Ideals);
    catch err
      if _ExactpAdics_IsPrecisionError(err) then
        vprint ExactpAdics_Factorization: "precision error";
        return false, _;
      else
        error err;
      end if;
    end try;
    // the factorization should be squarefree
    if exists{fac : fac in xfacs | fac[2] ne 1} then
      vprint ExactpAdics_Factorization: "not squarefree";
      return false, _;
    end if;
    assert &+[Degree(fac[1]) : fac in xfacs] eq Degree(xf);
    // check if each factor is hensel liftable
    facs := [];
    for i in [1..#xfacs] do
      xfac := xfacs[i][1];
      deg := Degree(xfac);
      xfac /:= Coefficient(xfac, deg);
      xcofac := xf div xfac;
      codeg := degf - deg;
      xfmodfac := xf mod xfac;
      s := Min([Valuation(c) : c in Coefficients(xfmodfac)]);
      M := Matrix([[j lt i select 0 else Coefficient(xcofac, j-i) : j in [0..degf-1]] : i in [0..deg-1]] cat [[j lt i select 0 else Coefficient(xfac, j-i) : j in [0..degf-1]] : i in [0..codeg-1]]);
      J := Determinant(M);
      if WZERO(J) then
        vprint ExactpAdics_Factorization: "resultant weakly zero";
        return false, _;
      end if;
      t := VAL(J);
      if s le 2*t then
        vprint ExactpAdics_Factorization: "not hensel liftable";
        return false, _;
      end if;
      // now do the lift
      init := reslope(Parent(xfac) ! [CAP_APR(c, s-t) : c in Coefficients(xfac)], slope);
      mkupdate := func<z | function (apr)
        xfac0 := GetData(z);
        pr := &join(apr - WVAL(z));
        return ExactpAdics_GeneralGetter(pr,
          procedure (~pr, ~dep)
            dep := Approximation_Lazy(f, BaselineValuation(f) + pr) mod func<xf | reshift(reslope(xf, -slope), -shift)>;
          end procedure,
          procedure (xf, ~pr, ~value)
            vprint ExactpAdics_Factorization, 2: "apr =", apr;
            vprint ExactpAdics_Factorization, 2: "pr =", pr;
            xR := Parent(xf);
            xK := BaseRing(xR);
            xpr := Max([VAL(c) lt OO select APR(c)-VAL(c) else 0 : c in Coefficients(xf)]);
            vprint ExactpAdics_Factorization, 2: "xpr =", xpr;
            incpr := func<pol | xR ! [WZERO(c) select 0 else CHANGE_APR(xK!c, VAL(c)+xpr) : c in Coefficients(pol)]>;
            xfac := incpr(xfac0);
            xcofac := incpr(xf div xfac);
            xerr := xf - xfac * xcofac;
            s := Min([Valuation(c) : c in Coefficients(xerr)]);
            vprint ExactpAdics_Factorization, 2: "s =", s;
            vprint ExactpAdics_Factorization, 2: "t =", t;
            assert s gt 2*t;
            while true do
              M := Matrix([[j lt i select 0 else Coefficient(xcofac, j-i) : j in [0..degf-1]] : i in [0..deg-1]] cat [[j lt i select 0 else Coefficient(xfac, j-i) : j in [0..degf-1]] : i in [0..codeg-1]]);
              J := Determinant(M);
              assert not WZERO(J);
              assert VAL(J) eq t;
              Minv := M^-1;
              delta := Vector([Coefficient(xerr, i) : i in [0..degf-1]]) * M^-1;
              new_xfac := xfac + xR!Eltseq(delta)[1..deg];
              new_xcofac := xcofac + xR!Eltseq(delta)[deg+1..deg+codeg];
              new_xerr := xf - new_xfac * new_xcofac;
              new_s := Min([Valuation(c) : c in Coefficients(new_xerr)]);
              vprint ExactpAdics_Factorization, 2: "new_s =", new_s;
              assert new_s gt 2*t;
              if new_s gt s then
                xfac := new_xfac;
                xcofac := new_xcofac;
                xerr := new_xerr;
                s := new_s;
              else
                xfac2 := reslope(xR![CAP_APR(c, new_s-t) : c in Coefficients(new_xfac)], slope);
                d := IntegerValue(&join[apr(i) - APR(Coefficient(xfac2, i)) : i in [0..deg]]);
                if d gt 0 then
                  pr +:= d;
                else
                  Update(z, xfac2);
                  SetData(z, xfac);
                  value := true;
                  vprint ExactpAdics_Factorization, 2: "success";
                end if;
                return;
              end if;
            end while;
          end procedure
        );
      end function>;
      fac := R ! <init, mkupdate, xfac>;
      Append(~facs, <fac, 1>);
    end for;
    // now make the certificates
    if Certificates then
      certs := [];
      for xcert in xcerts do
        cert := rec<CERT |
          E := xcert`E,
          F := xcert`F,
          Pi := WeakApproximation(R!reslope0(xcert`Pi, slope)),
          Rho := WeakApproximation(R!reslope0(xcert`Rho, slope))
        >;
        if Ideals then
          cert`IdealGen1 := WeakApproximation(K!xcert`IdealGen1);
          cert`IdealGen2 := WeakApproximation(R!reslope0(xcert`IdealGen2, slope));
        end if;
        if Extensions then
          try
            cert`Extension := ExactpAdicField(xcert`Extension, xK, K);
          catch err
            if Type(err`Object) eq MonStgElt and "does not define a unique extension" in err`Object then
              return false, _;
            else
              error err;
            end if;
          end try;
        end if;
        Append(~certs, cert);
      end for;
    else
      certs := false;
    end if;
    return true, [*facs, certs*];
  end function, Strategy);
  if not ok then
    error "precision error";
  end if;
  facs, certs := Explode(data);
  lc := WeakLeadingCoefficient(f);
  if Certificates then
    return facs, lc, certs;
  else
    return facs, lc, _;
  end if;
end intrinsic;

/// The roots of `f` as a sequence of `<root, multiplicity>` pairs.
/// 
/// `f` must not have repeated roots, and hence `multiplicity` will always be 1.
/// 
///param Strategy The precision strategy.
intrinsic Roots(f :: RngUPolElt_FldPadExact : Strategy:="default") -> []
  {The roots of f.}
  R := Parent(f);
  K := BaseRing(R);
  df := WeakDegree(f);
  ok, _, roots := ExactpAdics_ExecutePrecisionStrategy(function (pr)
    vprint ExactpAdics_Roots: "precision =", pr;
    // get an approximation
    xf, slope, shift := nicen(Approximation(f, BaselineValuation(f) + pr));
    vprint ExactpAdics_Roots: "xf =", xf;
    // require that we can see the full degree of xf
    if WZERO(Coefficient(xf, df)) then
      vprint ExactpAdics_Roots: "not full degree";
      return false, _;
    end if;
    // call Magma's root-finding routine
    try
      xroots := Roots(xf : IsSquarefree);
    catch err
      if _ExactpAdics_IsPrecisionError(err) then
        vprint ExactpAdics_Roots: "precision error";
        return false, _;
      else
        error err;
      end if;
    end try;
    vprint ExactpAdics_Roots: "xroots =", xroots;
    vprint ExactpAdics_Roots: "D =", Discriminant(xf);
    // the roots should be distinct
    if exists{r : r in xroots | r[2] ne 1} then
      vprint ExactpAdics_Roots: "repeated roots";
      return false, _;
    end if;
    // check they are hensel-liftable
    roots := [];
    for xr in xroots do
      ok, r := IsHenselLiftable(f, WeakApproximation(K ! ShiftValuation(xr[1], -slope)) : Strategy:=Strategy);
      if ok then
        Append(~roots, <r, 1>);
      else
        vprint ExactpAdics_Roots: "not Hensel liftable";
        return false, _;
      end if;
    end for;
    vprint ExactpAdics_Roots: "success";
    return true, roots;
  end function, Strategy);
  if ok then
    return roots;
  else
    error "precision error";
  end if;
end intrinsic;